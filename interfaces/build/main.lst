
build//main.exe:     file format elf32-littlearm


Disassembly of section .text:

00010000 <_sfixed>:
   10000:	20001220 	.word	0x20001220
   10004:	000119d9 	.word	0x000119d9
   10008:	000119d5 	.word	0x000119d5
   1000c:	000119d5 	.word	0x000119d5
   10010:	000119d5 	.word	0x000119d5
   10014:	000119d5 	.word	0x000119d5
   10018:	000119d5 	.word	0x000119d5
	...
   1002c:	000119d5 	.word	0x000119d5
   10030:	000119d5 	.word	0x000119d5
   10034:	00000000 	.word	0x00000000
   10038:	000119d5 	.word	0x000119d5
   1003c:	000119d5 	.word	0x000119d5
   10040:	000119d5 	.word	0x000119d5
   10044:	000119d5 	.word	0x000119d5
   10048:	000119d5 	.word	0x000119d5
   1004c:	000119d5 	.word	0x000119d5
   10050:	000119d5 	.word	0x000119d5
   10054:	000119d5 	.word	0x000119d5
   10058:	000119d5 	.word	0x000119d5
   1005c:	000119d5 	.word	0x000119d5
   10060:	000119d5 	.word	0x000119d5
   10064:	000119d5 	.word	0x000119d5
   10068:	000119d5 	.word	0x000119d5
   1006c:	000119d5 	.word	0x000119d5
   10070:	000119d5 	.word	0x000119d5
   10074:	000119d5 	.word	0x000119d5
   10078:	000119d5 	.word	0x000119d5
   1007c:	000119d5 	.word	0x000119d5
   10080:	000119d5 	.word	0x000119d5
   10084:	000119d5 	.word	0x000119d5
   10088:	000119d5 	.word	0x000119d5
   1008c:	000119d5 	.word	0x000119d5
   10090:	000119d5 	.word	0x000119d5
   10094:	000119d5 	.word	0x000119d5
   10098:	000119d5 	.word	0x000119d5
   1009c:	000119d5 	.word	0x000119d5
   100a0:	000119d5 	.word	0x000119d5
   100a4:	00010d21 	.word	0x00010d21
   100a8:	00010d35 	.word	0x00010d35
   100ac:	00010d81 	.word	0x00010d81
   100b0:	00010dcd 	.word	0x00010dcd
   100b4:	00010df1 	.word	0x00010df1
   100b8:	00010e05 	.word	0x00010e05
   100bc:	00010e51 	.word	0x00010e51
   100c0:	00010e5d 	.word	0x00010e5d
   100c4:	00010e69 	.word	0x00010e69
   100c8:	00010e7d 	.word	0x00010e7d
   100cc:	00010ec9 	.word	0x00010ec9
   100d0:	00010f15 	.word	0x00010f15
   100d4:	000119d5 	.word	0x000119d5
   100d8:	000119d5 	.word	0x000119d5
   100dc:	000119d5 	.word	0x000119d5
   100e0:	000119d5 	.word	0x000119d5
   100e4:	000119d5 	.word	0x000119d5
   100e8:	000119d5 	.word	0x000119d5
   100ec:	000119d5 	.word	0x000119d5
   100f0:	000119d5 	.word	0x000119d5
   100f4:	000119d5 	.word	0x000119d5
   100f8:	000119d5 	.word	0x000119d5
   100fc:	000119d5 	.word	0x000119d5
   10100:	000119d5 	.word	0x000119d5
   10104:	000119d5 	.word	0x000119d5
   10108:	000119d5 	.word	0x000119d5
   1010c:	000119d5 	.word	0x000119d5
   10110:	000119d5 	.word	0x000119d5
   10114:	000119d5 	.word	0x000119d5
   10118:	000119d5 	.word	0x000119d5
   1011c:	000119d5 	.word	0x000119d5
   10120:	000119d5 	.word	0x000119d5
   10124:	000119d5 	.word	0x000119d5
   10128:	000119d5 	.word	0x000119d5
   1012c:	000119d5 	.word	0x000119d5
   10130:	000119d5 	.word	0x000119d5
   10134:	000119d5 	.word	0x000119d5
   10138:	000119d5 	.word	0x000119d5
   1013c:	000119d5 	.word	0x000119d5
   10140:	000119d5 	.word	0x000119d5
   10144:	000112c1 	.word	0x000112c1
   10148:	000113f9 	.word	0x000113f9
   1014c:	00011531 	.word	0x00011531
   10150:	0001168d 	.word	0x0001168d
   10154:	000119d5 	.word	0x000119d5
   10158:	000119d5 	.word	0x000119d5
   1015c:	000119d5 	.word	0x000119d5
   10160:	000119d5 	.word	0x000119d5
   10164:	000119d5 	.word	0x000119d5
   10168:	000119d5 	.word	0x000119d5
   1016c:	000119d5 	.word	0x000119d5
   10170:	000119d5 	.word	0x000119d5
   10174:	000119d5 	.word	0x000119d5
   10178:	000119d5 	.word	0x000119d5
   1017c:	000119d5 	.word	0x000119d5

00010180 <HplSam4lGeneralIOP__8__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10180:	4b06      	ldr	r3, [pc, #24]	; (1019c <HplSam4lGeneralIOP__8__ByteIRQ__fired+0x1c>)
   10182:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10186:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1018a:	400a      	ands	r2, r1
   1018c:	05d2      	lsls	r2, r2, #23
        {
            PORT->ifrc = MASK;
   1018e:	bf44      	itt	mi
   10190:	f44f 7280 	movmi.w	r2, #256	; 0x100
   10194:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10198:	4770      	bx	lr
   1019a:	bf00      	nop
   1019c:	400e1000 	.word	0x400e1000

000101a0 <HplSam4lGeneralIOP__9__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   101a0:	4b06      	ldr	r3, [pc, #24]	; (101bc <HplSam4lGeneralIOP__9__ByteIRQ__fired+0x1c>)
   101a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   101a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   101aa:	400a      	ands	r2, r1
   101ac:	0591      	lsls	r1, r2, #22
        {
            PORT->ifrc = MASK;
   101ae:	bf44      	itt	mi
   101b0:	f44f 7200 	movmi.w	r2, #512	; 0x200
   101b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   101b8:	4770      	bx	lr
   101ba:	bf00      	nop
   101bc:	400e1000 	.word	0x400e1000

000101c0 <HplSam4lGeneralIOP__10__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   101c0:	4b06      	ldr	r3, [pc, #24]	; (101dc <HplSam4lGeneralIOP__10__ByteIRQ__fired+0x1c>)
   101c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   101c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   101ca:	400a      	ands	r2, r1
   101cc:	0550      	lsls	r0, r2, #21
        {
            PORT->ifrc = MASK;
   101ce:	bf44      	itt	mi
   101d0:	f44f 6280 	movmi.w	r2, #1024	; 0x400
   101d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   101d8:	4770      	bx	lr
   101da:	bf00      	nop
   101dc:	400e1000 	.word	0x400e1000

000101e0 <HplSam4lGeneralIOP__11__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   101e0:	4b06      	ldr	r3, [pc, #24]	; (101fc <HplSam4lGeneralIOP__11__ByteIRQ__fired+0x1c>)
   101e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   101e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   101ea:	400a      	ands	r2, r1
   101ec:	0512      	lsls	r2, r2, #20
        {
            PORT->ifrc = MASK;
   101ee:	bf44      	itt	mi
   101f0:	f44f 6200 	movmi.w	r2, #2048	; 0x800
   101f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   101f8:	4770      	bx	lr
   101fa:	bf00      	nop
   101fc:	400e1000 	.word	0x400e1000

00010200 <HplSam4lGeneralIOP__12__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10200:	4b06      	ldr	r3, [pc, #24]	; (1021c <HplSam4lGeneralIOP__12__ByteIRQ__fired+0x1c>)
   10202:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10206:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1020a:	400a      	ands	r2, r1
   1020c:	04d1      	lsls	r1, r2, #19
        {
            PORT->ifrc = MASK;
   1020e:	bf44      	itt	mi
   10210:	f44f 5280 	movmi.w	r2, #4096	; 0x1000
   10214:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10218:	4770      	bx	lr
   1021a:	bf00      	nop
   1021c:	400e1000 	.word	0x400e1000

00010220 <HplSam4lGeneralIOP__13__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10220:	4b06      	ldr	r3, [pc, #24]	; (1023c <HplSam4lGeneralIOP__13__ByteIRQ__fired+0x1c>)
   10222:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10226:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1022a:	400a      	ands	r2, r1
   1022c:	0490      	lsls	r0, r2, #18
        {
            PORT->ifrc = MASK;
   1022e:	bf44      	itt	mi
   10230:	f44f 5200 	movmi.w	r2, #8192	; 0x2000
   10234:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10238:	4770      	bx	lr
   1023a:	bf00      	nop
   1023c:	400e1000 	.word	0x400e1000

00010240 <HplSam4lGeneralIOP__14__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10240:	4b06      	ldr	r3, [pc, #24]	; (1025c <HplSam4lGeneralIOP__14__ByteIRQ__fired+0x1c>)
   10242:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10246:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1024a:	400a      	ands	r2, r1
   1024c:	0452      	lsls	r2, r2, #17
        {
            PORT->ifrc = MASK;
   1024e:	bf44      	itt	mi
   10250:	f44f 4280 	movmi.w	r2, #16384	; 0x4000
   10254:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10258:	4770      	bx	lr
   1025a:	bf00      	nop
   1025c:	400e1000 	.word	0x400e1000

00010260 <HplSam4lGeneralIOP__15__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10260:	4b06      	ldr	r3, [pc, #24]	; (1027c <HplSam4lGeneralIOP__15__ByteIRQ__fired+0x1c>)
   10262:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10266:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1026a:	400a      	ands	r2, r1
   1026c:	0411      	lsls	r1, r2, #16
        {
            PORT->ifrc = MASK;
   1026e:	bf44      	itt	mi
   10270:	f44f 4200 	movmi.w	r2, #32768	; 0x8000
   10274:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10278:	4770      	bx	lr
   1027a:	bf00      	nop
   1027c:	400e1000 	.word	0x400e1000

00010280 <HplSam4lGeneralIOP__16__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10280:	4b06      	ldr	r3, [pc, #24]	; (1029c <HplSam4lGeneralIOP__16__ByteIRQ__fired+0x1c>)
   10282:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10286:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1028a:	400a      	ands	r2, r1
   1028c:	03d0      	lsls	r0, r2, #15
        {
            PORT->ifrc = MASK;
   1028e:	bf44      	itt	mi
   10290:	f44f 3280 	movmi.w	r2, #65536	; 0x10000
   10294:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10298:	4770      	bx	lr
   1029a:	bf00      	nop
   1029c:	400e1000 	.word	0x400e1000

000102a0 <HplSam4lGeneralIOP__18__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   102a0:	4b06      	ldr	r3, [pc, #24]	; (102bc <HplSam4lGeneralIOP__18__ByteIRQ__fired+0x1c>)
   102a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   102a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   102aa:	400a      	ands	r2, r1
   102ac:	0352      	lsls	r2, r2, #13
        {
            PORT->ifrc = MASK;
   102ae:	bf44      	itt	mi
   102b0:	f44f 2280 	movmi.w	r2, #262144	; 0x40000
   102b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   102b8:	4770      	bx	lr
   102ba:	bf00      	nop
   102bc:	400e1000 	.word	0x400e1000

000102c0 <HplSam4lGeneralIOP__19__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   102c0:	4b06      	ldr	r3, [pc, #24]	; (102dc <HplSam4lGeneralIOP__19__ByteIRQ__fired+0x1c>)
   102c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   102c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   102ca:	400a      	ands	r2, r1
   102cc:	0311      	lsls	r1, r2, #12
        {
            PORT->ifrc = MASK;
   102ce:	bf44      	itt	mi
   102d0:	f44f 2200 	movmi.w	r2, #524288	; 0x80000
   102d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   102d8:	4770      	bx	lr
   102da:	bf00      	nop
   102dc:	400e1000 	.word	0x400e1000

000102e0 <HplSam4lGeneralIOP__20__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   102e0:	4b06      	ldr	r3, [pc, #24]	; (102fc <HplSam4lGeneralIOP__20__ByteIRQ__fired+0x1c>)
   102e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   102e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   102ea:	400a      	ands	r2, r1
   102ec:	02d0      	lsls	r0, r2, #11
        {
            PORT->ifrc = MASK;
   102ee:	bf44      	itt	mi
   102f0:	f44f 1280 	movmi.w	r2, #1048576	; 0x100000
   102f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   102f8:	4770      	bx	lr
   102fa:	bf00      	nop
   102fc:	400e1000 	.word	0x400e1000

00010300 <HplSam4lGeneralIOP__21__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10300:	4b06      	ldr	r3, [pc, #24]	; (1031c <HplSam4lGeneralIOP__21__ByteIRQ__fired+0x1c>)
   10302:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10306:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1030a:	400a      	ands	r2, r1
   1030c:	0292      	lsls	r2, r2, #10
        {
            PORT->ifrc = MASK;
   1030e:	bf44      	itt	mi
   10310:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   10314:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10318:	4770      	bx	lr
   1031a:	bf00      	nop
   1031c:	400e1000 	.word	0x400e1000

00010320 <HplSam4lGeneralIOP__22__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10320:	4b06      	ldr	r3, [pc, #24]	; (1033c <HplSam4lGeneralIOP__22__ByteIRQ__fired+0x1c>)
   10322:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10326:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1032a:	400a      	ands	r2, r1
   1032c:	0251      	lsls	r1, r2, #9
        {
            PORT->ifrc = MASK;
   1032e:	bf44      	itt	mi
   10330:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   10334:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10338:	4770      	bx	lr
   1033a:	bf00      	nop
   1033c:	400e1000 	.word	0x400e1000

00010340 <HplSam4lGeneralIOP__23__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10340:	4b06      	ldr	r3, [pc, #24]	; (1035c <HplSam4lGeneralIOP__23__ByteIRQ__fired+0x1c>)
   10342:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10346:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1034a:	400a      	ands	r2, r1
   1034c:	0210      	lsls	r0, r2, #8
        {
            PORT->ifrc = MASK;
   1034e:	bf44      	itt	mi
   10350:	f44f 0200 	movmi.w	r2, #8388608	; 0x800000
   10354:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10358:	4770      	bx	lr
   1035a:	bf00      	nop
   1035c:	400e1000 	.word	0x400e1000

00010360 <HplSam4lGeneralIOP__24__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10360:	4b06      	ldr	r3, [pc, #24]	; (1037c <HplSam4lGeneralIOP__24__ByteIRQ__fired+0x1c>)
   10362:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10366:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1036a:	400a      	ands	r2, r1
   1036c:	01d2      	lsls	r2, r2, #7
        {
            PORT->ifrc = MASK;
   1036e:	bf44      	itt	mi
   10370:	f04f 7280 	movmi.w	r2, #16777216	; 0x1000000
   10374:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10378:	4770      	bx	lr
   1037a:	bf00      	nop
   1037c:	400e1000 	.word	0x400e1000

00010380 <HplSam4lGeneralIOP__25__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10380:	4b06      	ldr	r3, [pc, #24]	; (1039c <HplSam4lGeneralIOP__25__ByteIRQ__fired+0x1c>)
   10382:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10386:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1038a:	400a      	ands	r2, r1
   1038c:	0191      	lsls	r1, r2, #6
        {
            PORT->ifrc = MASK;
   1038e:	bf44      	itt	mi
   10390:	f04f 7200 	movmi.w	r2, #33554432	; 0x2000000
   10394:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10398:	4770      	bx	lr
   1039a:	bf00      	nop
   1039c:	400e1000 	.word	0x400e1000

000103a0 <HplSam4lGeneralIOP__26__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   103a0:	4b06      	ldr	r3, [pc, #24]	; (103bc <HplSam4lGeneralIOP__26__ByteIRQ__fired+0x1c>)
   103a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   103a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   103aa:	400a      	ands	r2, r1
   103ac:	0150      	lsls	r0, r2, #5
        {
            PORT->ifrc = MASK;
   103ae:	bf44      	itt	mi
   103b0:	f04f 6280 	movmi.w	r2, #67108864	; 0x4000000
   103b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   103b8:	4770      	bx	lr
   103ba:	bf00      	nop
   103bc:	400e1000 	.word	0x400e1000

000103c0 <HplSam4lGeneralIOP__35__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   103c0:	4b06      	ldr	r3, [pc, #24]	; (103dc <HplSam4lGeneralIOP__35__ByteIRQ__fired+0x1c>)
   103c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   103c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   103ca:	400a      	ands	r2, r1
   103cc:	05d2      	lsls	r2, r2, #23
        {
            PORT->ifrc = MASK;
   103ce:	bf44      	itt	mi
   103d0:	f44f 7280 	movmi.w	r2, #256	; 0x100
   103d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   103d8:	4770      	bx	lr
   103da:	bf00      	nop
   103dc:	400e1200 	.word	0x400e1200

000103e0 <HplSam4lGeneralIOP__36__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   103e0:	4b06      	ldr	r3, [pc, #24]	; (103fc <HplSam4lGeneralIOP__36__ByteIRQ__fired+0x1c>)
   103e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   103e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   103ea:	400a      	ands	r2, r1
   103ec:	0591      	lsls	r1, r2, #22
        {
            PORT->ifrc = MASK;
   103ee:	bf44      	itt	mi
   103f0:	f44f 7200 	movmi.w	r2, #512	; 0x200
   103f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   103f8:	4770      	bx	lr
   103fa:	bf00      	nop
   103fc:	400e1200 	.word	0x400e1200

00010400 <HplSam4lGeneralIOP__37__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10400:	4b06      	ldr	r3, [pc, #24]	; (1041c <HplSam4lGeneralIOP__37__ByteIRQ__fired+0x1c>)
   10402:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10406:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1040a:	400a      	ands	r2, r1
   1040c:	0550      	lsls	r0, r2, #21
        {
            PORT->ifrc = MASK;
   1040e:	bf44      	itt	mi
   10410:	f44f 6280 	movmi.w	r2, #1024	; 0x400
   10414:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10418:	4770      	bx	lr
   1041a:	bf00      	nop
   1041c:	400e1200 	.word	0x400e1200

00010420 <HplSam4lGeneralIOP__38__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10420:	4b06      	ldr	r3, [pc, #24]	; (1043c <HplSam4lGeneralIOP__38__ByteIRQ__fired+0x1c>)
   10422:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10426:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1042a:	400a      	ands	r2, r1
   1042c:	0512      	lsls	r2, r2, #20
        {
            PORT->ifrc = MASK;
   1042e:	bf44      	itt	mi
   10430:	f44f 6200 	movmi.w	r2, #2048	; 0x800
   10434:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10438:	4770      	bx	lr
   1043a:	bf00      	nop
   1043c:	400e1200 	.word	0x400e1200

00010440 <HplSam4lGeneralIOP__39__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10440:	4b06      	ldr	r3, [pc, #24]	; (1045c <HplSam4lGeneralIOP__39__ByteIRQ__fired+0x1c>)
   10442:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10446:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1044a:	400a      	ands	r2, r1
   1044c:	04d1      	lsls	r1, r2, #19
        {
            PORT->ifrc = MASK;
   1044e:	bf44      	itt	mi
   10450:	f44f 5280 	movmi.w	r2, #4096	; 0x1000
   10454:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10458:	4770      	bx	lr
   1045a:	bf00      	nop
   1045c:	400e1200 	.word	0x400e1200

00010460 <HplSam4lGeneralIOP__40__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10460:	4b06      	ldr	r3, [pc, #24]	; (1047c <HplSam4lGeneralIOP__40__ByteIRQ__fired+0x1c>)
   10462:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10466:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1046a:	400a      	ands	r2, r1
   1046c:	0490      	lsls	r0, r2, #18
        {
            PORT->ifrc = MASK;
   1046e:	bf44      	itt	mi
   10470:	f44f 5200 	movmi.w	r2, #8192	; 0x2000
   10474:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10478:	4770      	bx	lr
   1047a:	bf00      	nop
   1047c:	400e1200 	.word	0x400e1200

00010480 <HplSam4lGeneralIOP__41__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10480:	4b06      	ldr	r3, [pc, #24]	; (1049c <HplSam4lGeneralIOP__41__ByteIRQ__fired+0x1c>)
   10482:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10486:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1048a:	400a      	ands	r2, r1
   1048c:	0452      	lsls	r2, r2, #17
        {
            PORT->ifrc = MASK;
   1048e:	bf44      	itt	mi
   10490:	f44f 4280 	movmi.w	r2, #16384	; 0x4000
   10494:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10498:	4770      	bx	lr
   1049a:	bf00      	nop
   1049c:	400e1200 	.word	0x400e1200

000104a0 <HplSam4lGeneralIOP__42__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   104a0:	4b06      	ldr	r3, [pc, #24]	; (104bc <HplSam4lGeneralIOP__42__ByteIRQ__fired+0x1c>)
   104a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   104a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   104aa:	400a      	ands	r2, r1
   104ac:	0411      	lsls	r1, r2, #16
        {
            PORT->ifrc = MASK;
   104ae:	bf44      	itt	mi
   104b0:	f44f 4200 	movmi.w	r2, #32768	; 0x8000
   104b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   104b8:	4770      	bx	lr
   104ba:	bf00      	nop
   104bc:	400e1200 	.word	0x400e1200

000104c0 <HplSam4lGeneralIOP__51__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   104c0:	4b06      	ldr	r3, [pc, #24]	; (104dc <HplSam4lGeneralIOP__51__ByteIRQ__fired+0x1c>)
   104c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   104c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   104ca:	400a      	ands	r2, r1
   104cc:	05d0      	lsls	r0, r2, #23
        {
            PORT->ifrc = MASK;
   104ce:	bf44      	itt	mi
   104d0:	f44f 7280 	movmi.w	r2, #256	; 0x100
   104d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   104d8:	4770      	bx	lr
   104da:	bf00      	nop
   104dc:	400e1400 	.word	0x400e1400

000104e0 <HplSam4lGeneralIOP__52__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   104e0:	4b06      	ldr	r3, [pc, #24]	; (104fc <HplSam4lGeneralIOP__52__ByteIRQ__fired+0x1c>)
   104e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   104e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   104ea:	400a      	ands	r2, r1
   104ec:	0592      	lsls	r2, r2, #22
        {
            PORT->ifrc = MASK;
   104ee:	bf44      	itt	mi
   104f0:	f44f 7200 	movmi.w	r2, #512	; 0x200
   104f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   104f8:	4770      	bx	lr
   104fa:	bf00      	nop
   104fc:	400e1400 	.word	0x400e1400

00010500 <HplSam4lGeneralIOP__53__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10500:	4b06      	ldr	r3, [pc, #24]	; (1051c <HplSam4lGeneralIOP__53__ByteIRQ__fired+0x1c>)
   10502:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10506:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1050a:	400a      	ands	r2, r1
   1050c:	0551      	lsls	r1, r2, #21
        {
            PORT->ifrc = MASK;
   1050e:	bf44      	itt	mi
   10510:	f44f 6280 	movmi.w	r2, #1024	; 0x400
   10514:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10518:	4770      	bx	lr
   1051a:	bf00      	nop
   1051c:	400e1400 	.word	0x400e1400

00010520 <HplSam4lGeneralIOP__54__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10520:	4b06      	ldr	r3, [pc, #24]	; (1053c <HplSam4lGeneralIOP__54__ByteIRQ__fired+0x1c>)
   10522:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10526:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1052a:	400a      	ands	r2, r1
   1052c:	0510      	lsls	r0, r2, #20
        {
            PORT->ifrc = MASK;
   1052e:	bf44      	itt	mi
   10530:	f44f 6200 	movmi.w	r2, #2048	; 0x800
   10534:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10538:	4770      	bx	lr
   1053a:	bf00      	nop
   1053c:	400e1400 	.word	0x400e1400

00010540 <HplSam4lGeneralIOP__55__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10540:	4b06      	ldr	r3, [pc, #24]	; (1055c <HplSam4lGeneralIOP__55__ByteIRQ__fired+0x1c>)
   10542:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10546:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1054a:	400a      	ands	r2, r1
   1054c:	04d2      	lsls	r2, r2, #19
        {
            PORT->ifrc = MASK;
   1054e:	bf44      	itt	mi
   10550:	f44f 5280 	movmi.w	r2, #4096	; 0x1000
   10554:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10558:	4770      	bx	lr
   1055a:	bf00      	nop
   1055c:	400e1400 	.word	0x400e1400

00010560 <HplSam4lGeneralIOP__56__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10560:	4b06      	ldr	r3, [pc, #24]	; (1057c <HplSam4lGeneralIOP__56__ByteIRQ__fired+0x1c>)
   10562:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10566:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1056a:	400a      	ands	r2, r1
   1056c:	0491      	lsls	r1, r2, #18
        {
            PORT->ifrc = MASK;
   1056e:	bf44      	itt	mi
   10570:	f44f 5200 	movmi.w	r2, #8192	; 0x2000
   10574:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10578:	4770      	bx	lr
   1057a:	bf00      	nop
   1057c:	400e1400 	.word	0x400e1400

00010580 <HplSam4lGeneralIOP__57__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10580:	4b06      	ldr	r3, [pc, #24]	; (1059c <HplSam4lGeneralIOP__57__ByteIRQ__fired+0x1c>)
   10582:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10586:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1058a:	400a      	ands	r2, r1
   1058c:	0450      	lsls	r0, r2, #17
        {
            PORT->ifrc = MASK;
   1058e:	bf44      	itt	mi
   10590:	f44f 4280 	movmi.w	r2, #16384	; 0x4000
   10594:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10598:	4770      	bx	lr
   1059a:	bf00      	nop
   1059c:	400e1400 	.word	0x400e1400

000105a0 <HplSam4lGeneralIOP__58__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   105a0:	4b06      	ldr	r3, [pc, #24]	; (105bc <HplSam4lGeneralIOP__58__ByteIRQ__fired+0x1c>)
   105a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   105a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   105aa:	400a      	ands	r2, r1
   105ac:	0412      	lsls	r2, r2, #16
        {
            PORT->ifrc = MASK;
   105ae:	bf44      	itt	mi
   105b0:	f44f 4200 	movmi.w	r2, #32768	; 0x8000
   105b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   105b8:	4770      	bx	lr
   105ba:	bf00      	nop
   105bc:	400e1400 	.word	0x400e1400

000105c0 <HplSam4lGeneralIOP__59__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   105c0:	4b06      	ldr	r3, [pc, #24]	; (105dc <HplSam4lGeneralIOP__59__ByteIRQ__fired+0x1c>)
   105c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   105c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   105ca:	400a      	ands	r2, r1
   105cc:	03d1      	lsls	r1, r2, #15
        {
            PORT->ifrc = MASK;
   105ce:	bf44      	itt	mi
   105d0:	f44f 3280 	movmi.w	r2, #65536	; 0x10000
   105d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   105d8:	4770      	bx	lr
   105da:	bf00      	nop
   105dc:	400e1400 	.word	0x400e1400

000105e0 <HplSam4lGeneralIOP__60__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   105e0:	4b06      	ldr	r3, [pc, #24]	; (105fc <HplSam4lGeneralIOP__60__ByteIRQ__fired+0x1c>)
   105e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   105e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   105ea:	400a      	ands	r2, r1
   105ec:	0390      	lsls	r0, r2, #14
        {
            PORT->ifrc = MASK;
   105ee:	bf44      	itt	mi
   105f0:	f44f 3200 	movmi.w	r2, #131072	; 0x20000
   105f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   105f8:	4770      	bx	lr
   105fa:	bf00      	nop
   105fc:	400e1400 	.word	0x400e1400

00010600 <HplSam4lGeneralIOP__61__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10600:	4b06      	ldr	r3, [pc, #24]	; (1061c <HplSam4lGeneralIOP__61__ByteIRQ__fired+0x1c>)
   10602:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10606:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1060a:	400a      	ands	r2, r1
   1060c:	0352      	lsls	r2, r2, #13
        {
            PORT->ifrc = MASK;
   1060e:	bf44      	itt	mi
   10610:	f44f 2280 	movmi.w	r2, #262144	; 0x40000
   10614:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10618:	4770      	bx	lr
   1061a:	bf00      	nop
   1061c:	400e1400 	.word	0x400e1400

00010620 <HplSam4lGeneralIOP__62__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10620:	4b06      	ldr	r3, [pc, #24]	; (1063c <HplSam4lGeneralIOP__62__ByteIRQ__fired+0x1c>)
   10622:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10626:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1062a:	400a      	ands	r2, r1
   1062c:	0311      	lsls	r1, r2, #12
        {
            PORT->ifrc = MASK;
   1062e:	bf44      	itt	mi
   10630:	f44f 2200 	movmi.w	r2, #524288	; 0x80000
   10634:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10638:	4770      	bx	lr
   1063a:	bf00      	nop
   1063c:	400e1400 	.word	0x400e1400

00010640 <HplSam4lGeneralIOP__63__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10640:	4b06      	ldr	r3, [pc, #24]	; (1065c <HplSam4lGeneralIOP__63__ByteIRQ__fired+0x1c>)
   10642:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10646:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1064a:	400a      	ands	r2, r1
   1064c:	02d0      	lsls	r0, r2, #11
        {
            PORT->ifrc = MASK;
   1064e:	bf44      	itt	mi
   10650:	f44f 1280 	movmi.w	r2, #1048576	; 0x100000
   10654:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10658:	4770      	bx	lr
   1065a:	bf00      	nop
   1065c:	400e1400 	.word	0x400e1400

00010660 <HplSam4lGeneralIOP__64__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10660:	4b06      	ldr	r3, [pc, #24]	; (1067c <HplSam4lGeneralIOP__64__ByteIRQ__fired+0x1c>)
   10662:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10666:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1066a:	400a      	ands	r2, r1
   1066c:	0292      	lsls	r2, r2, #10
        {
            PORT->ifrc = MASK;
   1066e:	bf44      	itt	mi
   10670:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   10674:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10678:	4770      	bx	lr
   1067a:	bf00      	nop
   1067c:	400e1400 	.word	0x400e1400

00010680 <HplSam4lGeneralIOP__65__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10680:	4b06      	ldr	r3, [pc, #24]	; (1069c <HplSam4lGeneralIOP__65__ByteIRQ__fired+0x1c>)
   10682:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10686:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1068a:	400a      	ands	r2, r1
   1068c:	0251      	lsls	r1, r2, #9
        {
            PORT->ifrc = MASK;
   1068e:	bf44      	itt	mi
   10690:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   10694:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10698:	4770      	bx	lr
   1069a:	bf00      	nop
   1069c:	400e1400 	.word	0x400e1400

000106a0 <HplSam4lGeneralIOP__66__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   106a0:	4b06      	ldr	r3, [pc, #24]	; (106bc <HplSam4lGeneralIOP__66__ByteIRQ__fired+0x1c>)
   106a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   106a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   106aa:	400a      	ands	r2, r1
   106ac:	0210      	lsls	r0, r2, #8
        {
            PORT->ifrc = MASK;
   106ae:	bf44      	itt	mi
   106b0:	f44f 0200 	movmi.w	r2, #8388608	; 0x800000
   106b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   106b8:	4770      	bx	lr
   106ba:	bf00      	nop
   106bc:	400e1400 	.word	0x400e1400

000106c0 <HplSam4lGeneralIOP__67__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   106c0:	4b06      	ldr	r3, [pc, #24]	; (106dc <HplSam4lGeneralIOP__67__ByteIRQ__fired+0x1c>)
   106c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   106c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   106ca:	400a      	ands	r2, r1
   106cc:	01d2      	lsls	r2, r2, #7
        {
            PORT->ifrc = MASK;
   106ce:	bf44      	itt	mi
   106d0:	f04f 7280 	movmi.w	r2, #16777216	; 0x1000000
   106d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   106d8:	4770      	bx	lr
   106da:	bf00      	nop
   106dc:	400e1400 	.word	0x400e1400

000106e0 <HplSam4lGeneralIOP__68__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   106e0:	4b06      	ldr	r3, [pc, #24]	; (106fc <HplSam4lGeneralIOP__68__ByteIRQ__fired+0x1c>)
   106e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   106e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   106ea:	400a      	ands	r2, r1
   106ec:	0191      	lsls	r1, r2, #6
        {
            PORT->ifrc = MASK;
   106ee:	bf44      	itt	mi
   106f0:	f04f 7200 	movmi.w	r2, #33554432	; 0x2000000
   106f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   106f8:	4770      	bx	lr
   106fa:	bf00      	nop
   106fc:	400e1400 	.word	0x400e1400

00010700 <HplSam4lGeneralIOP__69__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10700:	4b06      	ldr	r3, [pc, #24]	; (1071c <HplSam4lGeneralIOP__69__ByteIRQ__fired+0x1c>)
   10702:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10706:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1070a:	400a      	ands	r2, r1
   1070c:	0150      	lsls	r0, r2, #5
        {
            PORT->ifrc = MASK;
   1070e:	bf44      	itt	mi
   10710:	f04f 6280 	movmi.w	r2, #67108864	; 0x4000000
   10714:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10718:	4770      	bx	lr
   1071a:	bf00      	nop
   1071c:	400e1400 	.word	0x400e1400

00010720 <HplSam4lGeneralIOP__70__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10720:	4b06      	ldr	r3, [pc, #24]	; (1073c <HplSam4lGeneralIOP__70__ByteIRQ__fired+0x1c>)
   10722:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10726:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1072a:	400a      	ands	r2, r1
   1072c:	0112      	lsls	r2, r2, #4
        {
            PORT->ifrc = MASK;
   1072e:	bf44      	itt	mi
   10730:	f04f 6200 	movmi.w	r2, #134217728	; 0x8000000
   10734:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10738:	4770      	bx	lr
   1073a:	bf00      	nop
   1073c:	400e1400 	.word	0x400e1400

00010740 <HplSam4lGeneralIOP__71__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10740:	4b06      	ldr	r3, [pc, #24]	; (1075c <HplSam4lGeneralIOP__71__ByteIRQ__fired+0x1c>)
   10742:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10746:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1074a:	400a      	ands	r2, r1
   1074c:	00d1      	lsls	r1, r2, #3
        {
            PORT->ifrc = MASK;
   1074e:	bf44      	itt	mi
   10750:	f04f 5280 	movmi.w	r2, #268435456	; 0x10000000
   10754:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10758:	4770      	bx	lr
   1075a:	bf00      	nop
   1075c:	400e1400 	.word	0x400e1400

00010760 <HplSam4lGeneralIOP__72__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10760:	4b06      	ldr	r3, [pc, #24]	; (1077c <HplSam4lGeneralIOP__72__ByteIRQ__fired+0x1c>)
   10762:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10766:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1076a:	400a      	ands	r2, r1
   1076c:	0090      	lsls	r0, r2, #2
        {
            PORT->ifrc = MASK;
   1076e:	bf44      	itt	mi
   10770:	f04f 5200 	movmi.w	r2, #536870912	; 0x20000000
   10774:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10778:	4770      	bx	lr
   1077a:	bf00      	nop
   1077c:	400e1400 	.word	0x400e1400

00010780 <HplSam4lGeneralIOP__73__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10780:	4b06      	ldr	r3, [pc, #24]	; (1079c <HplSam4lGeneralIOP__73__ByteIRQ__fired+0x1c>)
   10782:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10786:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1078a:	400a      	ands	r2, r1
   1078c:	0052      	lsls	r2, r2, #1
        {
            PORT->ifrc = MASK;
   1078e:	bf44      	itt	mi
   10790:	f04f 4280 	movmi.w	r2, #1073741824	; 0x40000000
   10794:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10798:	4770      	bx	lr
   1079a:	bf00      	nop
   1079c:	400e1400 	.word	0x400e1400

000107a0 <HplSam4lGeneralIOP__74__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   107a0:	4b05      	ldr	r3, [pc, #20]	; (107b8 <HplSam4lGeneralIOP__74__ByteIRQ__fired+0x18>)
   107a2:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   107a6:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
   107aa:	4211      	tst	r1, r2
        {
            PORT->ifrc = MASK;
   107ac:	bf44      	itt	mi
   107ae:	f04f 4200 	movmi.w	r2, #2147483648	; 0x80000000
   107b2:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   107b6:	4770      	bx	lr
   107b8:	400e1400 	.word	0x400e1400

000107bc <SchedulerBasicP__popTask>:
  // move the head forward
  // if the head is at the end, mark the tail at the end, too
  // mark the task as not in the queue
  inline uint8_t popTask()
  {
    if( m_head != NO_TASK )
   107bc:	4906      	ldr	r1, [pc, #24]	; (107d8 <SchedulerBasicP__popTask+0x1c>)
   107be:	7808      	ldrb	r0, [r1, #0]
   107c0:	28ff      	cmp	r0, #255	; 0xff
   107c2:	d008      	beq.n	107d6 <SchedulerBasicP__popTask+0x1a>
    {
      uint8_t id = m_head;
      m_head = m_next[m_head];
   107c4:	4a05      	ldr	r2, [pc, #20]	; (107dc <SchedulerBasicP__popTask+0x20>)
   107c6:	5c13      	ldrb	r3, [r2, r0]
      if( m_head == NO_TASK )
   107c8:	2bff      	cmp	r3, #255	; 0xff
  inline uint8_t popTask()
  {
    if( m_head != NO_TASK )
    {
      uint8_t id = m_head;
      m_head = m_next[m_head];
   107ca:	700b      	strb	r3, [r1, #0]
      if( m_head == NO_TASK )
      {
	m_tail = NO_TASK;
   107cc:	bf04      	itt	eq
   107ce:	4904      	ldreq	r1, [pc, #16]	; (107e0 <SchedulerBasicP__popTask+0x24>)
   107d0:	700b      	strbeq	r3, [r1, #0]
      }
      m_next[id] = NO_TASK;
   107d2:	23ff      	movs	r3, #255	; 0xff
   107d4:	5413      	strb	r3, [r2, r0]
    }
    else
    {
      return NO_TASK;
    }
  }
   107d6:	4770      	bx	lr
   107d8:	20000210 	.word	0x20000210
   107dc:	20000048 	.word	0x20000048
   107e0:	2000021c 	.word	0x2000021c

000107e4 <McuSleepC__InterruptWrapper__preamble>:

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   107e4:	2201      	movs	r2, #1
   107e6:	f3ef 8310 	mrs	r3, PRIMASK
   107ea:	f382 8810 	msr	PRIMASK, r2
          // Default resume
          resumeFromSleepMode();
      }
      if(ps != S_AWAKE)
        commonResume();
      ps = S_AWAKE;
   107ee:	4a03      	ldr	r2, [pc, #12]	; (107fc <McuSleepC__InterruptWrapper__preamble+0x18>)
   107f0:	2100      	movs	r1, #0
   107f2:	6011      	str	r1, [r2, #0]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   107f4:	f383 8810 	msr	PRIMASK, r3
   107f8:	4770      	bx	lr
   107fa:	bf00      	nop
   107fc:	20000214 	.word	0x20000214

00010800 <HplSam4lUSARTP__3__usart__initUART>:

implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
   10800:	4b0f      	ldr	r3, [pc, #60]	; (10840 <HplSam4lUSARTP__3__usart__initUART+0x40>)
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   10802:	4910      	ldr	r1, [pc, #64]	; (10844 <HplSam4lUSARTP__3__usart__initUART+0x44>)

implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
   10804:	681a      	ldr	r2, [r3, #0]
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   10806:	4810      	ldr	r0, [pc, #64]	; (10848 <HplSam4lUSARTP__3__usart__initUART+0x48>)
implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
        shadow |= 1<<bit;
   10808:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
        PM->unlock = PM_UNLOCK_KEY | offset;
   1080c:	65c8      	str	r0, [r1, #92]	; 0x5c
        *((uint32_t volatile *)((void volatile *)PM + offset)) = shadow;
   1080e:	601a      	str	r2, [r3, #0]
		USART->mr.bits.par = 4;
	}
	async command void usart.initUART()
	{
	    call ClockCtl.enable();
		USART->mr.bits.chrl = 3; //8 bits
   10810:	4b0e      	ldr	r3, [pc, #56]	; (1084c <HplSam4lUSARTP__3__usart__initUART+0x4c>)
   10812:	685a      	ldr	r2, [r3, #4]
   10814:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
   10818:	605a      	str	r2, [r3, #4]
		USART->mr.bits.usclks = 0; //use clk_usart.
   1081a:	685a      	ldr	r2, [r3, #4]
   1081c:	f36f 1205 	bfc	r2, #4, #2
   10820:	605a      	str	r2, [r3, #4]
		USART->mr.bits.mode = 0; //UART
   10822:	685a      	ldr	r2, [r3, #4]
   10824:	f36f 0203 	bfc	r2, #0, #4
   10828:	605a      	str	r2, [r3, #4]
		USART->mr.bits.nbstop = 0; //1 stop
   1082a:	685a      	ldr	r2, [r3, #4]
   1082c:	f36f 320d 	bfc	r2, #12, #2
   10830:	605a      	str	r2, [r3, #4]
		USART->mr.bits.par = 4; //No parity
   10832:	6859      	ldr	r1, [r3, #4]
   10834:	2204      	movs	r2, #4
   10836:	f362 214b 	bfi	r1, r2, #9, #3
   1083a:	6059      	str	r1, [r3, #4]
		USART->ttgr = 4; //Space between bytes: 4 bits
   1083c:	629a      	str	r2, [r3, #40]	; 0x28
   1083e:	4770      	bx	lr
   10840:	400e0028 	.word	0x400e0028
   10844:	400e0000 	.word	0x400e0000
   10848:	aa000028 	.word	0xaa000028
   1084c:	40030000 	.word	0x40030000

00010850 <SchedulerBasicP__TaskBasic__postTask>:
  /**
   * Return SUCCESS if the post succeeded, EBUSY if it was already posted.
   */
  
  async command error_t TaskBasic.postTask[uint8_t id]()
  {
   10850:	b510      	push	{r4, lr}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   10852:	2301      	movs	r3, #1
   10854:	f3ef 8110 	mrs	r1, PRIMASK
   10858:	f383 8810 	msr	PRIMASK, r3
    }
  }
  
  bool isWaiting( uint8_t id )
  {
    return (m_next[id] != NO_TASK) || (m_tail == id);
   1085c:	4b0f      	ldr	r3, [pc, #60]	; (1089c <SchedulerBasicP__TaskBasic__postTask+0x4c>)
   1085e:	5c1a      	ldrb	r2, [r3, r0]
   10860:	2aff      	cmp	r2, #255	; 0xff
   10862:	461c      	mov	r4, r3
   10864:	d108      	bne.n	10878 <SchedulerBasicP__TaskBasic__postTask+0x28>
   10866:	4b0e      	ldr	r3, [pc, #56]	; (108a0 <SchedulerBasicP__TaskBasic__postTask+0x50>)
   10868:	781b      	ldrb	r3, [r3, #0]
   1086a:	ebb3 0c00 	subs.w	ip, r3, r0
   1086e:	f1dc 0300 	rsbs	r3, ip, #0
   10872:	eb53 030c 	adcs.w	r3, r3, ip
   10876:	e000      	b.n	1087a <SchedulerBasicP__TaskBasic__postTask+0x2a>
   10878:	2301      	movs	r3, #1
  }

  bool pushTask( uint8_t id )
  {
    if( !isWaiting(id) )
   1087a:	b95b      	cbnz	r3, 10894 <SchedulerBasicP__TaskBasic__postTask+0x44>
    {
      if( m_head == NO_TASK )
   1087c:	4a09      	ldr	r2, [pc, #36]	; (108a4 <SchedulerBasicP__TaskBasic__postTask+0x54>)
   1087e:	7813      	ldrb	r3, [r2, #0]
   10880:	2bff      	cmp	r3, #255	; 0xff
   10882:	4b07      	ldr	r3, [pc, #28]	; (108a0 <SchedulerBasicP__TaskBasic__postTask+0x50>)
      {
	m_head = id;
   10884:	bf0c      	ite	eq
   10886:	7010      	strbeq	r0, [r2, #0]
	m_tail = id;
      }
      else
      {
	m_next[m_tail] = id;
   10888:	781a      	ldrbne	r2, [r3, #0]
	m_tail = id;
   1088a:	7018      	strb	r0, [r3, #0]
	m_head = id;
	m_tail = id;
      }
      else
      {
	m_next[m_tail] = id;
   1088c:	bf18      	it	ne
   1088e:	54a0      	strbne	r0, [r4, r2]
   */
  
  async command error_t TaskBasic.postTask[uint8_t id]()
  {
    atomic { return pushTask(id) ? SUCCESS : EBUSY; }
  }
   10890:	2000      	movs	r0, #0
   10892:	e000      	b.n	10896 <SchedulerBasicP__TaskBasic__postTask+0x46>
   10894:	2005      	movs	r0, #5
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   10896:	f381 8810 	msr	PRIMASK, r1
   1089a:	bd10      	pop	{r4, pc}
   1089c:	20000048 	.word	0x20000048
   108a0:	2000021c 	.word	0x2000021c
   108a4:	20000210 	.word	0x20000210

000108a8 <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   108a8:	4b2c      	ldr	r3, [pc, #176]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0xb4>)
   108aa:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   108ae:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   108b2:	400a      	ands	r2, r1
   108b4:	07d0      	lsls	r0, r2, #31
        {
            PORT->ifrc = MASK;
   108b6:	bf44      	itt	mi
   108b8:	2201      	movmi	r2, #1
   108ba:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   108be:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   108c2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   108c6:	4013      	ands	r3, r2
   108c8:	0799      	lsls	r1, r3, #30
   108ca:	d503      	bpl.n	108d4 <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0x2c>
        {
            PORT->ifrc = MASK;
   108cc:	4b23      	ldr	r3, [pc, #140]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0xb4>)
   108ce:	2202      	movs	r2, #2
   108d0:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   108d4:	4b21      	ldr	r3, [pc, #132]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0xb4>)
   108d6:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   108da:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   108de:	400a      	ands	r2, r1
   108e0:	0752      	lsls	r2, r2, #29
        {
            PORT->ifrc = MASK;
   108e2:	bf44      	itt	mi
   108e4:	2204      	movmi	r2, #4
   108e6:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   108ea:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   108ee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   108f2:	4013      	ands	r3, r2
   108f4:	071b      	lsls	r3, r3, #28
   108f6:	d503      	bpl.n	10900 <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0x58>
        {
            PORT->ifrc = MASK;
   108f8:	4b18      	ldr	r3, [pc, #96]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0xb4>)
   108fa:	2208      	movs	r2, #8
   108fc:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10900:	4b16      	ldr	r3, [pc, #88]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0xb4>)
   10902:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10906:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1090a:	400a      	ands	r2, r1
   1090c:	06d0      	lsls	r0, r2, #27
        {
            PORT->ifrc = MASK;
   1090e:	bf44      	itt	mi
   10910:	2210      	movmi	r2, #16
   10912:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10916:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   1091a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   1091e:	4013      	ands	r3, r2
   10920:	0699      	lsls	r1, r3, #26
   10922:	d503      	bpl.n	1092c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0x84>
        {
            PORT->ifrc = MASK;
   10924:	4b0d      	ldr	r3, [pc, #52]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0xb4>)
   10926:	2220      	movs	r2, #32
   10928:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   1092c:	4b0b      	ldr	r3, [pc, #44]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0xb4>)
   1092e:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10932:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10936:	400a      	ands	r2, r1
   10938:	0652      	lsls	r2, r2, #25
        {
            PORT->ifrc = MASK;
   1093a:	bf44      	itt	mi
   1093c:	2240      	movmi	r2, #64	; 0x40
   1093e:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10942:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   10946:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   1094a:	4013      	ands	r3, r2
   1094c:	061b      	lsls	r3, r3, #24
   1094e:	d503      	bpl.n	10958 <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0xb0>
        {
            PORT->ifrc = MASK;
   10950:	4b02      	ldr	r3, [pc, #8]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.51+0xb4>)
   10952:	2280      	movs	r2, #128	; 0x80
   10954:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
   10958:	4770      	bx	lr
   1095a:	bf00      	nop
   1095c:	400e1000 	.word	0x400e1000

00010960 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10960:	4b2c      	ldr	r3, [pc, #176]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0xb4>)
   10962:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10966:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1096a:	400a      	ands	r2, r1
   1096c:	07d0      	lsls	r0, r2, #31
        {
            PORT->ifrc = MASK;
   1096e:	bf44      	itt	mi
   10970:	2201      	movmi	r2, #1
   10972:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10976:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   1097a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   1097e:	4013      	ands	r3, r2
   10980:	0799      	lsls	r1, r3, #30
   10982:	d503      	bpl.n	1098c <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0x2c>
        {
            PORT->ifrc = MASK;
   10984:	4b23      	ldr	r3, [pc, #140]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0xb4>)
   10986:	2202      	movs	r2, #2
   10988:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   1098c:	4b21      	ldr	r3, [pc, #132]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0xb4>)
   1098e:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10992:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10996:	400a      	ands	r2, r1
   10998:	0752      	lsls	r2, r2, #29
        {
            PORT->ifrc = MASK;
   1099a:	bf44      	itt	mi
   1099c:	2204      	movmi	r2, #4
   1099e:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   109a2:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   109a6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   109aa:	4013      	ands	r3, r2
   109ac:	071b      	lsls	r3, r3, #28
   109ae:	d503      	bpl.n	109b8 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0x58>
        {
            PORT->ifrc = MASK;
   109b0:	4b18      	ldr	r3, [pc, #96]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0xb4>)
   109b2:	2208      	movs	r2, #8
   109b4:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   109b8:	4b16      	ldr	r3, [pc, #88]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0xb4>)
   109ba:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   109be:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   109c2:	400a      	ands	r2, r1
   109c4:	06d0      	lsls	r0, r2, #27
        {
            PORT->ifrc = MASK;
   109c6:	bf44      	itt	mi
   109c8:	2210      	movmi	r2, #16
   109ca:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   109ce:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   109d2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   109d6:	4013      	ands	r3, r2
   109d8:	0699      	lsls	r1, r3, #26
   109da:	d503      	bpl.n	109e4 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0x84>
        {
            PORT->ifrc = MASK;
   109dc:	4b0d      	ldr	r3, [pc, #52]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0xb4>)
   109de:	2220      	movs	r2, #32
   109e0:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   109e4:	4b0b      	ldr	r3, [pc, #44]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0xb4>)
   109e6:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   109ea:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   109ee:	400a      	ands	r2, r1
   109f0:	0652      	lsls	r2, r2, #25
        {
            PORT->ifrc = MASK;
   109f2:	bf44      	itt	mi
   109f4:	2240      	movmi	r2, #64	; 0x40
   109f6:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   109fa:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   109fe:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   10a02:	4013      	ands	r3, r2
   10a04:	061b      	lsls	r3, r3, #24
   10a06:	d503      	bpl.n	10a10 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0xb0>
        {
            PORT->ifrc = MASK;
   10a08:	4b02      	ldr	r3, [pc, #8]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.53+0xb4>)
   10a0a:	2280      	movs	r2, #128	; 0x80
   10a0c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
   10a10:	4770      	bx	lr
   10a12:	bf00      	nop
   10a14:	400e1200 	.word	0x400e1200

00010a18 <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a18:	4b2c      	ldr	r3, [pc, #176]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0xb4>)
   10a1a:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10a1e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10a22:	400a      	ands	r2, r1
   10a24:	07d0      	lsls	r0, r2, #31
        {
            PORT->ifrc = MASK;
   10a26:	bf44      	itt	mi
   10a28:	2201      	movmi	r2, #1
   10a2a:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a2e:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   10a32:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   10a36:	4013      	ands	r3, r2
   10a38:	0799      	lsls	r1, r3, #30
   10a3a:	d503      	bpl.n	10a44 <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0x2c>
        {
            PORT->ifrc = MASK;
   10a3c:	4b23      	ldr	r3, [pc, #140]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0xb4>)
   10a3e:	2202      	movs	r2, #2
   10a40:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a44:	4b21      	ldr	r3, [pc, #132]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0xb4>)
   10a46:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10a4a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10a4e:	400a      	ands	r2, r1
   10a50:	0752      	lsls	r2, r2, #29
        {
            PORT->ifrc = MASK;
   10a52:	bf44      	itt	mi
   10a54:	2204      	movmi	r2, #4
   10a56:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a5a:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   10a5e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   10a62:	4013      	ands	r3, r2
   10a64:	071b      	lsls	r3, r3, #28
   10a66:	d503      	bpl.n	10a70 <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0x58>
        {
            PORT->ifrc = MASK;
   10a68:	4b18      	ldr	r3, [pc, #96]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0xb4>)
   10a6a:	2208      	movs	r2, #8
   10a6c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a70:	4b16      	ldr	r3, [pc, #88]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0xb4>)
   10a72:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10a76:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10a7a:	400a      	ands	r2, r1
   10a7c:	06d0      	lsls	r0, r2, #27
        {
            PORT->ifrc = MASK;
   10a7e:	bf44      	itt	mi
   10a80:	2210      	movmi	r2, #16
   10a82:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a86:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   10a8a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   10a8e:	4013      	ands	r3, r2
   10a90:	0699      	lsls	r1, r3, #26
   10a92:	d503      	bpl.n	10a9c <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0x84>
        {
            PORT->ifrc = MASK;
   10a94:	4b0d      	ldr	r3, [pc, #52]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0xb4>)
   10a96:	2220      	movs	r2, #32
   10a98:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a9c:	4b0b      	ldr	r3, [pc, #44]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0xb4>)
   10a9e:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10aa2:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10aa6:	400a      	ands	r2, r1
   10aa8:	0652      	lsls	r2, r2, #25
        {
            PORT->ifrc = MASK;
   10aaa:	bf44      	itt	mi
   10aac:	2240      	movmi	r2, #64	; 0x40
   10aae:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10ab2:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   10ab6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   10aba:	4013      	ands	r3, r2
   10abc:	061b      	lsls	r3, r3, #24
   10abe:	d503      	bpl.n	10ac8 <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0xb0>
        {
            PORT->ifrc = MASK;
   10ac0:	4b02      	ldr	r3, [pc, #8]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.55+0xb4>)
   10ac2:	2280      	movs	r2, #128	; 0x80
   10ac4:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
   10ac8:	4770      	bx	lr
   10aca:	bf00      	nop
   10acc:	400e1400 	.word	0x400e1400

00010ad0 <SerialPrintfP__mini_itoa.part.59>:
        unsigned int len = 0;
        while (s[len] != '\0') len++;
        return len;
    }

    unsigned int  mini_itoa(int value, unsigned int radix, unsigned int uppercase,
   10ad0:	b5f0      	push	{r4, r5, r6, r7, lr}

        /* No support for unusual radixes. */
        if (radix > 16)
            return 0;

        if (value < 0) {
   10ad2:	2800      	cmp	r0, #0
        unsigned int len = 0;
        while (s[len] != '\0') len++;
        return len;
    }

    unsigned int  mini_itoa(int value, unsigned int radix, unsigned int uppercase,
   10ad4:	9e05      	ldr	r6, [sp, #20]
        if (radix > 16)
            return 0;

        if (value < 0) {
            negative = 1;
            value = -value;
   10ad6:	bfba      	itte	lt
   10ad8:	4240      	neglt	r0, r0
        /* No support for unusual radixes. */
        if (radix > 16)
            return 0;

        if (value < 0) {
            negative = 1;
   10ada:	2501      	movlt	r5, #1

    unsigned int  mini_itoa(int value, unsigned int radix, unsigned int uppercase,
         char *buffer, unsigned int zero_pad)
    {
        char	*pbuffer = buffer;
        int	negative = 0;
   10adc:	2500      	movge	r5, #0
        /* No support for unusual radixes. */
        if (radix > 16)
            return 0;

        if (value < 0) {
            negative = 1;
   10ade:	461c      	mov	r4, r3
            value = -value;
        }

        /* This builds the string back to front ... */
        do {
            int digit = value % radix;
   10ae0:	fbb0 f7f1 	udiv	r7, r0, r1
   10ae4:	fb01 0017 	mls	r0, r1, r7, r0
            *(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
   10ae8:	2809      	cmp	r0, #9
   10aea:	f104 0401 	add.w	r4, r4, #1
   10aee:	dc01      	bgt.n	10af4 <SerialPrintfP__mini_itoa.part.59+0x24>
   10af0:	3030      	adds	r0, #48	; 0x30
   10af2:	e007      	b.n	10b04 <SerialPrintfP__mini_itoa.part.59+0x34>
   10af4:	2a00      	cmp	r2, #0
   10af6:	bf0c      	ite	eq
   10af8:	f04f 0c61 	moveq.w	ip, #97	; 0x61
   10afc:	f04f 0c41 	movne.w	ip, #65	; 0x41
   10b00:	380a      	subs	r0, #10
   10b02:	4460      	add	r0, ip
   10b04:	b2c0      	uxtb	r0, r0
   10b06:	f804 0c01 	strb.w	r0, [r4, #-1]
            value /= radix;
   10b0a:	4638      	mov	r0, r7
        } while (value > 0);
   10b0c:	2f00      	cmp	r7, #0
   10b0e:	d1e7      	bne.n	10ae0 <SerialPrintfP__mini_itoa.part.59+0x10>
        }

        /* This builds the string back to front ... */
        do {
            int digit = value % radix;
            *(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
   10b10:	4621      	mov	r1, r4
            value /= radix;
        } while (value > 0);

        for (i = (pbuffer - buffer); i < zero_pad; i++)
   10b12:	1ae0      	subs	r0, r4, r3
   10b14:	1a42      	subs	r2, r0, r1
   10b16:	4422      	add	r2, r4
   10b18:	42b2      	cmp	r2, r6
   10b1a:	d203      	bcs.n	10b24 <SerialPrintfP__mini_itoa.part.59+0x54>
            *(pbuffer++) = '0';
   10b1c:	2230      	movs	r2, #48	; 0x30
   10b1e:	f804 2b01 	strb.w	r2, [r4], #1
   10b22:	e7f7      	b.n	10b14 <SerialPrintfP__mini_itoa.part.59+0x44>
            int digit = value % radix;
            *(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
            value /= radix;
        } while (value > 0);

        for (i = (pbuffer - buffer); i < zero_pad; i++)
   10b24:	4622      	mov	r2, r4
            *(pbuffer++) = '0';

        if (negative)
   10b26:	b115      	cbz	r5, 10b2e <SerialPrintfP__mini_itoa.part.59+0x5e>
            *(pbuffer++) = '-';
   10b28:	212d      	movs	r1, #45	; 0x2d
   10b2a:	3401      	adds	r4, #1
   10b2c:	7011      	strb	r1, [r2, #0]

        *(pbuffer) = '\0';

        /* ... now we reverse it (could do it recursively but will
         * conserve the stack space) */
        len = (pbuffer - buffer);
   10b2e:	1ae0      	subs	r0, r4, r3
            *(pbuffer++) = '0';

        if (negative)
            *(pbuffer++) = '-';

        *(pbuffer) = '\0';
   10b30:	2200      	movs	r2, #0
   10b32:	7022      	strb	r2, [r4, #0]
   10b34:	1819      	adds	r1, r3, r0

        /* ... now we reverse it (could do it recursively but will
         * conserve the stack space) */
        len = (pbuffer - buffer);
        for (i = 0; i < len / 2; i++) {
   10b36:	0844      	lsrs	r4, r0, #1
   10b38:	42a2      	cmp	r2, r4
   10b3a:	d007      	beq.n	10b4c <SerialPrintfP__mini_itoa.part.59+0x7c>
            char j = buffer[i];
   10b3c:	5c9d      	ldrb	r5, [r3, r2]
            buffer[i] = buffer[len-i-1];
   10b3e:	f811 6c01 	ldrb.w	r6, [r1, #-1]
   10b42:	549e      	strb	r6, [r3, r2]
            buffer[len-i-1] = j;
   10b44:	f801 5d01 	strb.w	r5, [r1, #-1]!
        *(pbuffer) = '\0';

        /* ... now we reverse it (could do it recursively but will
         * conserve the stack space) */
        len = (pbuffer - buffer);
        for (i = 0; i < len / 2; i++) {
   10b48:	3201      	adds	r2, #1
   10b4a:	e7f5      	b.n	10b38 <SerialPrintfP__mini_itoa.part.59+0x68>
            buffer[i] = buffer[len-i-1];
            buffer[len-i-1] = j;
        }

        return len;
    }
   10b4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00010b50 <HalSam4lUSARTP__2__SpiPacket__send.constprop.67>:
    *
    * @return SUCCESS if the request was accepted for transfer
    */
    async command error_t SpiPacket.send( uint8_t* txBuf, uint8_t* rxBuf, uint16_t len )
    {
        if (tx_buf != NULL && rx_buf != NULL)
   10b50:	4b12      	ldr	r3, [pc, #72]	; (10b9c <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x4c>)
   10b52:	4a13      	ldr	r2, [pc, #76]	; (10ba0 <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x50>)
   10b54:	6819      	ldr	r1, [r3, #0]
   10b56:	4618      	mov	r0, r3
   10b58:	b119      	cbz	r1, 10b62 <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x12>
   10b5a:	6811      	ldr	r1, [r2, #0]
   10b5c:	b109      	cbz	r1, 10b62 <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x12>
        {
            return FAIL;
   10b5e:	2001      	movs	r0, #1
   10b60:	4770      	bx	lr
        }
        irqmode_spi = TRUE;
   10b62:	4910      	ldr	r1, [pc, #64]	; (10ba4 <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x54>)
   10b64:	2301      	movs	r3, #1
   10b66:	700b      	strb	r3, [r1, #0]
        tx_buf = txBuf;
   10b68:	490f      	ldr	r1, [pc, #60]	; (10ba8 <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x58>)
   10b6a:	6001      	str	r1, [r0, #0]
        rx_buf = rxBuf;
   10b6c:	490f      	ldr	r1, [pc, #60]	; (10bac <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x5c>)
   10b6e:	6011      	str	r1, [r2, #0]
        tx_len = len;
   10b70:	4a0f      	ldr	r2, [pc, #60]	; (10bb0 <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x60>)
	default async event void usart1irq.RXRdyFired(){}
	default async event void usart1irq.TXRdyFired(){}

	void enableUSART2IRQ()
    {
		NVIC->iser.flat[2] = 1 << (3);
   10b72:	4910      	ldr	r1, [pc, #64]	; (10bb4 <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x64>)
   10b74:	8013      	strh	r3, [r2, #0]
        tx_ptr = 0;
   10b76:	4a10      	ldr	r2, [pc, #64]	; (10bb8 <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x68>)
   10b78:	2300      	movs	r3, #0
   10b7a:	8013      	strh	r3, [r2, #0]
        rx_ptr = 0;
   10b7c:	4a0f      	ldr	r2, [pc, #60]	; (10bbc <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x6c>)
   10b7e:	2008      	movs	r0, #8
   10b80:	8013      	strh	r3, [r2, #0]
    }
    async command void usart2irq.enableTXRdyIRQ()
    {
        enableUSART2IRQ();
        USART2->ier.bits.txrdy = 1;
   10b82:	4b0f      	ldr	r3, [pc, #60]	; (10bc0 <HalSam4lUSARTP__2__SpiPacket__send.constprop.67+0x70>)
	default async event void usart1irq.RXRdyFired(){}
	default async event void usart1irq.TXRdyFired(){}

	void enableUSART2IRQ()
    {
		NVIC->iser.flat[2] = 1 << (3);
   10b84:	6088      	str	r0, [r1, #8]
    }
    async command void usart2irq.enableTXRdyIRQ()
    {
        enableUSART2IRQ();
        USART2->ier.bits.txrdy = 1;
   10b86:	689a      	ldr	r2, [r3, #8]
   10b88:	f042 0202 	orr.w	r2, r2, #2
   10b8c:	609a      	str	r2, [r3, #8]
	default async event void usart1irq.RXRdyFired(){}
	default async event void usart1irq.TXRdyFired(){}

	void enableUSART2IRQ()
    {
		NVIC->iser.flat[2] = 1 << (3);
   10b8e:	6088      	str	r0, [r1, #8]
	    USART2->idr.bits.txrdy = 1;
	}
	async command void usart2irq.enableRXRdyIRQ()
	{
        enableUSART2IRQ();
	    USART2->ier.bits.rxrdy = 1;
   10b90:	689a      	ldr	r2, [r3, #8]
   10b92:	f042 0201 	orr.w	r2, r2, #1
   10b96:	609a      	str	r2, [r3, #8]
        call usart_irq.enableTXRdyIRQ();
        call usart_irq.enableRXRdyIRQ();
    }
   10b98:	4770      	bx	lr
   10b9a:	bf00      	nop
   10b9c:	20000010 	.word	0x20000010
   10ba0:	20000018 	.word	0x20000018
   10ba4:	2000001c 	.word	0x2000001c
   10ba8:	200000b8 	.word	0x200000b8
   10bac:	20000065 	.word	0x20000065
   10bb0:	20000050 	.word	0x20000050
   10bb4:	e000e100 	.word	0xe000e100
   10bb8:	2000020e 	.word	0x2000020e
   10bbc:	20000052 	.word	0x20000052
   10bc0:	4002c000 	.word	0x4002c000

00010bc4 <HplSam4lGeneralIOP__17__ByteIRQ__fired>:
    }

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
   10bc4:	b510      	push	{r4, lr}
        if (PORT->ifr & PORT->ier & MASK)
   10bc6:	4b0d      	ldr	r3, [pc, #52]	; (10bfc <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x38>)
   10bc8:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10bcc:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10bd0:	400a      	ands	r2, r1
   10bd2:	0394      	lsls	r4, r2, #14
   10bd4:	d510      	bpl.n	10bf8 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x34>
        {
            PORT->ifrc = MASK;
   10bd6:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   10bda:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
    spiqueued = 1;
  }

  async event void Int.fired()
  {
    if (spiqueued) {
   10bde:	4b08      	ldr	r3, [pc, #32]	; (10c00 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x3c>)
   10be0:	4c08      	ldr	r4, [pc, #32]	; (10c04 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x40>)
   10be2:	781b      	ldrb	r3, [r3, #0]
   10be4:	b133      	cbz	r3, 10bf4 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x30>
        PORT->ovrs = MASK;
	}

	async command void IO.clr()
	{
        PORT->ovrc = MASK;
   10be6:	4b08      	ldr	r3, [pc, #32]	; (10c08 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x44>)
   10be8:	2280      	movs	r2, #128	; 0x80
   10bea:	659a      	str	r2, [r3, #88]	; 0x58
   *              parameters must be AT LEAST as large as len, or the SPI
   *              will overflow a buffer.
   *
   * @return SUCCESS if the request was accepted for transfer
   */
  async command error_t send( uint8_t* txBuf, uint8_t* rxBuf, uint16_t len );
   10bec:	4b07      	ldr	r3, [pc, #28]	; (10c0c <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x48>)
   10bee:	4798      	blx	r3
      call CS.clr();
      call SpiPacket.send(txbuf, rxbuf, 1);
      spiready = 0;
   10bf0:	2300      	movs	r3, #0
   10bf2:	e000      	b.n	10bf6 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x32>
    } else {
      spiready = 1;
   10bf4:	2301      	movs	r3, #1
   10bf6:	7023      	strb	r3, [r4, #0]
   10bf8:	bd10      	pop	{r4, pc}
   10bfa:	bf00      	nop
   10bfc:	400e1000 	.word	0x400e1000
   10c00:	20000034 	.word	0x20000034
   10c04:	20000015 	.word	0x20000015
   10c08:	400e1400 	.word	0x400e1400
   10c0c:	00010b51 	.word	0x00010b51

00010c10 <SchedulerBasicP__TaskBasic__runTask>:
   * Event from the scheduler to run this task. Following the TinyOS
   * concurrency model, the codes invoked from <tt>run()</tt> signals
   * execute atomically with respect to one another, but can be
   * preempted by async commands/events.
   */
  event void runTask();
   10c10:	b508      	push	{r3, lr}
   10c12:	2806      	cmp	r0, #6
   10c14:	d858      	bhi.n	10cc8 <SchedulerBasicP__TaskBasic__runTask+0xb8>
   10c16:	e8df f000 	tbb	[pc, r0]
   10c1a:	1404      	.short	0x1404
   10c1c:	3d312519 	.word	0x3d312519
   10c20:	49          	.byte	0x49
   10c21:	00          	.byte	0x00
   10c22:	4b2a      	ldr	r3, [pc, #168]	; (10ccc <SchedulerBasicP__TaskBasic__runTask+0xbc>)
   10c24:	2280      	movs	r2, #128	; 0x80
   10c26:	659a      	str	r2, [r3, #88]	; 0x58
    return SUCCESS;
  }

  command error_t BlePeripheral.startAdvertising() {
    call CS.clr();
    txbuf[0] = 2;
   10c28:	4b29      	ldr	r3, [pc, #164]	; (10cd0 <SchedulerBasicP__TaskBasic__runTask+0xc0>)
   10c2a:	2202      	movs	r2, #2
   10c2c:	701a      	strb	r2, [r3, #0]
    if (spiready) {
   10c2e:	4b29      	ldr	r3, [pc, #164]	; (10cd4 <SchedulerBasicP__TaskBasic__runTask+0xc4>)
   10c30:	781b      	ldrb	r3, [r3, #0]
   10c32:	b113      	cbz	r3, 10c3a <SchedulerBasicP__TaskBasic__runTask+0x2a>
   10c34:	4b28      	ldr	r3, [pc, #160]	; (10cd8 <SchedulerBasicP__TaskBasic__runTask+0xc8>)
   10c36:	4798      	blx	r3
   10c38:	bd08      	pop	{r3, pc}
      call SpiPacket.send(txbuf, rxbuf, 1);
    } else {
      spiqueued = 1;
   10c3a:	4b28      	ldr	r3, [pc, #160]	; (10cdc <SchedulerBasicP__TaskBasic__runTask+0xcc>)
   10c3c:	2201      	movs	r2, #1
   10c3e:	701a      	strb	r2, [r3, #0]
   10c40:	bd08      	pop	{r3, pc}
        return (PORT->pvr & MASK) != 0;
	}

	async command void IO.set()
	{
        PORT->ovrs = MASK;
   10c42:	4b22      	ldr	r3, [pc, #136]	; (10ccc <SchedulerBasicP__TaskBasic__runTask+0xbc>)
   10c44:	f44f 6280 	mov.w	r2, #1024	; 0x400
   10c48:	655a      	str	r2, [r3, #84]	; 0x54
   10c4a:	bd08      	pop	{r3, pc}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   10c4c:	2201      	movs	r2, #1
   10c4e:	f3ef 8310 	mrs	r3, PRIMASK
   10c52:	f382 8810 	msr	PRIMASK, r2
                && (state == RES_GRANTING || state == RES_IMM_GRANTING)));
  }
  
  task void grantedTask() {
    atomic {
      resId = reqResId;
   10c56:	4a22      	ldr	r2, [pc, #136]	; (10ce0 <SchedulerBasicP__TaskBasic__runTask+0xd0>)
   10c58:	7811      	ldrb	r1, [r2, #0]
   10c5a:	4a22      	ldr	r2, [pc, #136]	; (10ce4 <SchedulerBasicP__TaskBasic__runTask+0xd4>)
   10c5c:	7011      	strb	r1, [r2, #0]
      state = RES_BUSY;
   10c5e:	2103      	movs	r1, #3
   10c60:	4a21      	ldr	r2, [pc, #132]	; (10ce8 <SchedulerBasicP__TaskBasic__runTask+0xd8>)
   10c62:	e02e      	b.n	10cc2 <SchedulerBasicP__TaskBasic__runTask+0xb2>
   10c64:	2201      	movs	r2, #1
   10c66:	f3ef 8310 	mrs	r3, PRIMASK
   10c6a:	f382 8810 	msr	PRIMASK, r2
                && (state == RES_GRANTING || state == RES_IMM_GRANTING)));
  }
  
  task void grantedTask() {
    atomic {
      resId = reqResId;
   10c6e:	4a1f      	ldr	r2, [pc, #124]	; (10cec <SchedulerBasicP__TaskBasic__runTask+0xdc>)
   10c70:	7811      	ldrb	r1, [r2, #0]
   10c72:	4a1f      	ldr	r2, [pc, #124]	; (10cf0 <SchedulerBasicP__TaskBasic__runTask+0xe0>)
   10c74:	7011      	strb	r1, [r2, #0]
      state = RES_BUSY;
   10c76:	2103      	movs	r1, #3
   10c78:	4a1e      	ldr	r2, [pc, #120]	; (10cf4 <SchedulerBasicP__TaskBasic__runTask+0xe4>)
   10c7a:	e022      	b.n	10cc2 <SchedulerBasicP__TaskBasic__runTask+0xb2>
   10c7c:	2201      	movs	r2, #1
   10c7e:	f3ef 8310 	mrs	r3, PRIMASK
   10c82:	f382 8810 	msr	PRIMASK, r2
                && (state == RES_GRANTING || state == RES_IMM_GRANTING)));
  }
  
  task void grantedTask() {
    atomic {
      resId = reqResId;
   10c86:	4a1c      	ldr	r2, [pc, #112]	; (10cf8 <SchedulerBasicP__TaskBasic__runTask+0xe8>)
   10c88:	7811      	ldrb	r1, [r2, #0]
   10c8a:	4a1c      	ldr	r2, [pc, #112]	; (10cfc <SchedulerBasicP__TaskBasic__runTask+0xec>)
   10c8c:	7011      	strb	r1, [r2, #0]
      state = RES_BUSY;
   10c8e:	2103      	movs	r1, #3
   10c90:	4a1b      	ldr	r2, [pc, #108]	; (10d00 <SchedulerBasicP__TaskBasic__runTask+0xf0>)
   10c92:	e016      	b.n	10cc2 <SchedulerBasicP__TaskBasic__runTask+0xb2>
   10c94:	2201      	movs	r2, #1
   10c96:	f3ef 8310 	mrs	r3, PRIMASK
   10c9a:	f382 8810 	msr	PRIMASK, r2
                && (state == RES_GRANTING || state == RES_IMM_GRANTING)));
  }
  
  task void grantedTask() {
    atomic {
      resId = reqResId;
   10c9e:	4a19      	ldr	r2, [pc, #100]	; (10d04 <SchedulerBasicP__TaskBasic__runTask+0xf4>)
   10ca0:	7811      	ldrb	r1, [r2, #0]
   10ca2:	4a19      	ldr	r2, [pc, #100]	; (10d08 <SchedulerBasicP__TaskBasic__runTask+0xf8>)
   10ca4:	7011      	strb	r1, [r2, #0]
      state = RES_BUSY;
   10ca6:	2103      	movs	r1, #3
   10ca8:	4a18      	ldr	r2, [pc, #96]	; (10d0c <SchedulerBasicP__TaskBasic__runTask+0xfc>)
   10caa:	e00a      	b.n	10cc2 <SchedulerBasicP__TaskBasic__runTask+0xb2>
   10cac:	2201      	movs	r2, #1
   10cae:	f3ef 8310 	mrs	r3, PRIMASK
   10cb2:	f382 8810 	msr	PRIMASK, r2
                && (state == RES_GRANTING || state == RES_IMM_GRANTING)));
  }
  
  task void grantedTask() {
    atomic {
      resId = reqResId;
   10cb6:	4a16      	ldr	r2, [pc, #88]	; (10d10 <SchedulerBasicP__TaskBasic__runTask+0x100>)
   10cb8:	7811      	ldrb	r1, [r2, #0]
   10cba:	4a16      	ldr	r2, [pc, #88]	; (10d14 <SchedulerBasicP__TaskBasic__runTask+0x104>)
   10cbc:	7011      	strb	r1, [r2, #0]
      state = RES_BUSY;
   10cbe:	4a16      	ldr	r2, [pc, #88]	; (10d18 <SchedulerBasicP__TaskBasic__runTask+0x108>)
   10cc0:	2103      	movs	r1, #3
   10cc2:	7011      	strb	r1, [r2, #0]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   10cc4:	f383 8810 	msr	PRIMASK, r3
   10cc8:	bd08      	pop	{r3, pc}
   10cca:	bf00      	nop
   10ccc:	400e1400 	.word	0x400e1400
   10cd0:	200000b8 	.word	0x200000b8
   10cd4:	20000015 	.word	0x20000015
   10cd8:	00010b51 	.word	0x00010b51
   10cdc:	20000034 	.word	0x20000034
   10ce0:	2000010a 	.word	0x2000010a
   10ce4:	2000000b 	.word	0x2000000b
   10ce8:	2000000a 	.word	0x2000000a
   10cec:	2000005e 	.word	0x2000005e
   10cf0:	20000038 	.word	0x20000038
   10cf4:	20000037 	.word	0x20000037
   10cf8:	2000004f 	.word	0x2000004f
   10cfc:	20000002 	.word	0x20000002
   10d00:	2000001e 	.word	0x2000001e
   10d04:	20000064 	.word	0x20000064
   10d08:	20000001 	.word	0x20000001
   10d0c:	20000008 	.word	0x20000008
   10d10:	20000040 	.word	0x20000040
   10d14:	20000000 	.word	0x20000000
   10d18:	20000035 	.word	0x20000035

00010d1c <sam4LowPowerConfigure>:
  norace struct {
  } wait_restore;
  
  // This C function is defined so that we can call it
  // from platform_bootstrap(), as defined in platform.h
  void sam4LowPowerConfigure() @C() @spontaneous() {
   10d1c:	4770      	bx	lr
	...

00010d20 <GPIO_0_Handler>:
    default async event void PortA_IRQ.fired[uint8_t i](){}
    default async event void PortB_IRQ.fired[uint8_t i](){}
    default async event void PortC_IRQ.fired[uint8_t i](){}

    void GPIO_0_Handler() @C() @spontaneous()
    {
   10d20:	b508      	push	{r3, lr}
/**
 * @author Kevin Klues <Kevin.Klues@csiro.au>
 */

interface FunctionWrapper {
  async command void preamble();
   10d22:	4b02      	ldr	r3, [pc, #8]	; (10d2c <GPIO_0_Handler+0xc>)
   10d24:	4798      	blx	r3
   10d26:	4b02      	ldr	r3, [pc, #8]	; (10d30 <GPIO_0_Handler+0x10>)
   10d28:	4798      	blx	r3
   10d2a:	bd08      	pop	{r3, pc}
   10d2c:	000107e5 	.word	0x000107e5
   10d30:	000108a9 	.word	0x000108a9

00010d34 <GPIO_1_Handler>:
        signal PortA_IRQ.fired[0]();
        call IRQWrapper.postamble();
    }

    void GPIO_1_Handler() @C() @spontaneous()
    {
   10d34:	b508      	push	{r3, lr}
   10d36:	4b09      	ldr	r3, [pc, #36]	; (10d5c <GPIO_1_Handler+0x28>)
   10d38:	4798      	blx	r3
interface ByteIRQ
{
    async event void fired();
   10d3a:	4b09      	ldr	r3, [pc, #36]	; (10d60 <GPIO_1_Handler+0x2c>)
   10d3c:	4798      	blx	r3
   10d3e:	4b09      	ldr	r3, [pc, #36]	; (10d64 <GPIO_1_Handler+0x30>)
   10d40:	4798      	blx	r3
   10d42:	4b09      	ldr	r3, [pc, #36]	; (10d68 <GPIO_1_Handler+0x34>)
   10d44:	4798      	blx	r3
   10d46:	4b09      	ldr	r3, [pc, #36]	; (10d6c <GPIO_1_Handler+0x38>)
   10d48:	4798      	blx	r3
   10d4a:	4b09      	ldr	r3, [pc, #36]	; (10d70 <GPIO_1_Handler+0x3c>)
   10d4c:	4798      	blx	r3
   10d4e:	4b09      	ldr	r3, [pc, #36]	; (10d74 <GPIO_1_Handler+0x40>)
   10d50:	4798      	blx	r3
   10d52:	4b09      	ldr	r3, [pc, #36]	; (10d78 <GPIO_1_Handler+0x44>)
   10d54:	4798      	blx	r3
   10d56:	4b09      	ldr	r3, [pc, #36]	; (10d7c <GPIO_1_Handler+0x48>)
   10d58:	4798      	blx	r3
   10d5a:	bd08      	pop	{r3, pc}
   10d5c:	000107e5 	.word	0x000107e5
   10d60:	00010181 	.word	0x00010181
   10d64:	000101a1 	.word	0x000101a1
   10d68:	000101c1 	.word	0x000101c1
   10d6c:	000101e1 	.word	0x000101e1
   10d70:	00010201 	.word	0x00010201
   10d74:	00010221 	.word	0x00010221
   10d78:	00010241 	.word	0x00010241
   10d7c:	00010261 	.word	0x00010261

00010d80 <GPIO_2_Handler>:
        signal PortA_IRQ.fired[1]();
        call IRQWrapper.postamble();
    }

    void GPIO_2_Handler() @C() @spontaneous()
    {
   10d80:	b508      	push	{r3, lr}
   10d82:	4b09      	ldr	r3, [pc, #36]	; (10da8 <GPIO_2_Handler+0x28>)
   10d84:	4798      	blx	r3
   10d86:	4b09      	ldr	r3, [pc, #36]	; (10dac <GPIO_2_Handler+0x2c>)
   10d88:	4798      	blx	r3
   10d8a:	4b09      	ldr	r3, [pc, #36]	; (10db0 <GPIO_2_Handler+0x30>)
   10d8c:	4798      	blx	r3
   10d8e:	4b09      	ldr	r3, [pc, #36]	; (10db4 <GPIO_2_Handler+0x34>)
   10d90:	4798      	blx	r3
   10d92:	4b09      	ldr	r3, [pc, #36]	; (10db8 <GPIO_2_Handler+0x38>)
   10d94:	4798      	blx	r3
   10d96:	4b09      	ldr	r3, [pc, #36]	; (10dbc <GPIO_2_Handler+0x3c>)
   10d98:	4798      	blx	r3
   10d9a:	4b09      	ldr	r3, [pc, #36]	; (10dc0 <GPIO_2_Handler+0x40>)
   10d9c:	4798      	blx	r3
   10d9e:	4b09      	ldr	r3, [pc, #36]	; (10dc4 <GPIO_2_Handler+0x44>)
   10da0:	4798      	blx	r3
   10da2:	4b09      	ldr	r3, [pc, #36]	; (10dc8 <GPIO_2_Handler+0x48>)
   10da4:	4798      	blx	r3
   10da6:	bd08      	pop	{r3, pc}
   10da8:	000107e5 	.word	0x000107e5
   10dac:	00010281 	.word	0x00010281
   10db0:	00010bc5 	.word	0x00010bc5
   10db4:	000102a1 	.word	0x000102a1
   10db8:	000102c1 	.word	0x000102c1
   10dbc:	000102e1 	.word	0x000102e1
   10dc0:	00010301 	.word	0x00010301
   10dc4:	00010321 	.word	0x00010321
   10dc8:	00010341 	.word	0x00010341

00010dcc <GPIO_3_Handler>:
        signal PortA_IRQ.fired[2]();
        call IRQWrapper.postamble();
    }

    void GPIO_3_Handler() @C() @spontaneous()
    {
   10dcc:	b508      	push	{r3, lr}
   10dce:	4b04      	ldr	r3, [pc, #16]	; (10de0 <GPIO_3_Handler+0x14>)
   10dd0:	4798      	blx	r3
   10dd2:	4b04      	ldr	r3, [pc, #16]	; (10de4 <GPIO_3_Handler+0x18>)
   10dd4:	4798      	blx	r3
   10dd6:	4b04      	ldr	r3, [pc, #16]	; (10de8 <GPIO_3_Handler+0x1c>)
   10dd8:	4798      	blx	r3
   10dda:	4b04      	ldr	r3, [pc, #16]	; (10dec <GPIO_3_Handler+0x20>)
   10ddc:	4798      	blx	r3
   10dde:	bd08      	pop	{r3, pc}
   10de0:	000107e5 	.word	0x000107e5
   10de4:	00010361 	.word	0x00010361
   10de8:	00010381 	.word	0x00010381
   10dec:	000103a1 	.word	0x000103a1

00010df0 <GPIO_4_Handler>:
        signal PortA_IRQ.fired[3]();
        call IRQWrapper.postamble();
    }

    void GPIO_4_Handler() @C() @spontaneous()
    {
   10df0:	b508      	push	{r3, lr}
   10df2:	4b02      	ldr	r3, [pc, #8]	; (10dfc <GPIO_4_Handler+0xc>)
   10df4:	4798      	blx	r3
   10df6:	4b02      	ldr	r3, [pc, #8]	; (10e00 <GPIO_4_Handler+0x10>)
   10df8:	4798      	blx	r3
   10dfa:	bd08      	pop	{r3, pc}
   10dfc:	000107e5 	.word	0x000107e5
   10e00:	00010961 	.word	0x00010961

00010e04 <GPIO_5_Handler>:
        signal PortB_IRQ.fired[0]();
        call IRQWrapper.postamble();
    }

    void GPIO_5_Handler() @C() @spontaneous()
    {
   10e04:	b508      	push	{r3, lr}
   10e06:	4b09      	ldr	r3, [pc, #36]	; (10e2c <GPIO_5_Handler+0x28>)
   10e08:	4798      	blx	r3
   10e0a:	4b09      	ldr	r3, [pc, #36]	; (10e30 <GPIO_5_Handler+0x2c>)
   10e0c:	4798      	blx	r3
   10e0e:	4b09      	ldr	r3, [pc, #36]	; (10e34 <GPIO_5_Handler+0x30>)
   10e10:	4798      	blx	r3
   10e12:	4b09      	ldr	r3, [pc, #36]	; (10e38 <GPIO_5_Handler+0x34>)
   10e14:	4798      	blx	r3
   10e16:	4b09      	ldr	r3, [pc, #36]	; (10e3c <GPIO_5_Handler+0x38>)
   10e18:	4798      	blx	r3
   10e1a:	4b09      	ldr	r3, [pc, #36]	; (10e40 <GPIO_5_Handler+0x3c>)
   10e1c:	4798      	blx	r3
   10e1e:	4b09      	ldr	r3, [pc, #36]	; (10e44 <GPIO_5_Handler+0x40>)
   10e20:	4798      	blx	r3
   10e22:	4b09      	ldr	r3, [pc, #36]	; (10e48 <GPIO_5_Handler+0x44>)
   10e24:	4798      	blx	r3
   10e26:	4b09      	ldr	r3, [pc, #36]	; (10e4c <GPIO_5_Handler+0x48>)
   10e28:	4798      	blx	r3
   10e2a:	bd08      	pop	{r3, pc}
   10e2c:	000107e5 	.word	0x000107e5
   10e30:	000103c1 	.word	0x000103c1
   10e34:	000103e1 	.word	0x000103e1
   10e38:	00010401 	.word	0x00010401
   10e3c:	00010421 	.word	0x00010421
   10e40:	00010441 	.word	0x00010441
   10e44:	00010461 	.word	0x00010461
   10e48:	00010481 	.word	0x00010481
   10e4c:	000104a1 	.word	0x000104a1

00010e50 <GPIO_6_Handler>:
        signal PortB_IRQ.fired[1]();
        call IRQWrapper.postamble();
    }

    void GPIO_6_Handler() @C() @spontaneous()
    {
   10e50:	b508      	push	{r3, lr}
   10e52:	4b01      	ldr	r3, [pc, #4]	; (10e58 <GPIO_6_Handler+0x8>)
   10e54:	4798      	blx	r3
   10e56:	bd08      	pop	{r3, pc}
   10e58:	000107e5 	.word	0x000107e5

00010e5c <GPIO_7_Handler>:
        signal PortB_IRQ.fired[2]();
        call IRQWrapper.postamble();
    }

    void GPIO_7_Handler() @C() @spontaneous()
    {
   10e5c:	b508      	push	{r3, lr}
   10e5e:	4b01      	ldr	r3, [pc, #4]	; (10e64 <GPIO_7_Handler+0x8>)
   10e60:	4798      	blx	r3
   10e62:	bd08      	pop	{r3, pc}
   10e64:	000107e5 	.word	0x000107e5

00010e68 <GPIO_8_Handler>:
        signal PortB_IRQ.fired[3]();
        call IRQWrapper.postamble();
    }

    void GPIO_8_Handler() @C() @spontaneous()
    {
   10e68:	b508      	push	{r3, lr}
   10e6a:	4b02      	ldr	r3, [pc, #8]	; (10e74 <GPIO_8_Handler+0xc>)
   10e6c:	4798      	blx	r3
   10e6e:	4b02      	ldr	r3, [pc, #8]	; (10e78 <GPIO_8_Handler+0x10>)
   10e70:	4798      	blx	r3
   10e72:	bd08      	pop	{r3, pc}
   10e74:	000107e5 	.word	0x000107e5
   10e78:	00010a19 	.word	0x00010a19

00010e7c <GPIO_9_Handler>:
        signal PortC_IRQ.fired[0]();
        call IRQWrapper.postamble();
    }

    void GPIO_9_Handler() @C() @spontaneous()
    {
   10e7c:	b508      	push	{r3, lr}
   10e7e:	4b09      	ldr	r3, [pc, #36]	; (10ea4 <GPIO_9_Handler+0x28>)
   10e80:	4798      	blx	r3
   10e82:	4b09      	ldr	r3, [pc, #36]	; (10ea8 <GPIO_9_Handler+0x2c>)
   10e84:	4798      	blx	r3
   10e86:	4b09      	ldr	r3, [pc, #36]	; (10eac <GPIO_9_Handler+0x30>)
   10e88:	4798      	blx	r3
   10e8a:	4b09      	ldr	r3, [pc, #36]	; (10eb0 <GPIO_9_Handler+0x34>)
   10e8c:	4798      	blx	r3
   10e8e:	4b09      	ldr	r3, [pc, #36]	; (10eb4 <GPIO_9_Handler+0x38>)
   10e90:	4798      	blx	r3
   10e92:	4b09      	ldr	r3, [pc, #36]	; (10eb8 <GPIO_9_Handler+0x3c>)
   10e94:	4798      	blx	r3
   10e96:	4b09      	ldr	r3, [pc, #36]	; (10ebc <GPIO_9_Handler+0x40>)
   10e98:	4798      	blx	r3
   10e9a:	4b09      	ldr	r3, [pc, #36]	; (10ec0 <GPIO_9_Handler+0x44>)
   10e9c:	4798      	blx	r3
   10e9e:	4b09      	ldr	r3, [pc, #36]	; (10ec4 <GPIO_9_Handler+0x48>)
   10ea0:	4798      	blx	r3
   10ea2:	bd08      	pop	{r3, pc}
   10ea4:	000107e5 	.word	0x000107e5
   10ea8:	000104c1 	.word	0x000104c1
   10eac:	000104e1 	.word	0x000104e1
   10eb0:	00010501 	.word	0x00010501
   10eb4:	00010521 	.word	0x00010521
   10eb8:	00010541 	.word	0x00010541
   10ebc:	00010561 	.word	0x00010561
   10ec0:	00010581 	.word	0x00010581
   10ec4:	000105a1 	.word	0x000105a1

00010ec8 <GPIO_10_Handler>:
        signal PortC_IRQ.fired[1]();
        call IRQWrapper.postamble();
    }

    void GPIO_10_Handler() @C() @spontaneous()
    {
   10ec8:	b508      	push	{r3, lr}
   10eca:	4b09      	ldr	r3, [pc, #36]	; (10ef0 <GPIO_10_Handler+0x28>)
   10ecc:	4798      	blx	r3
   10ece:	4b09      	ldr	r3, [pc, #36]	; (10ef4 <GPIO_10_Handler+0x2c>)
   10ed0:	4798      	blx	r3
   10ed2:	4b09      	ldr	r3, [pc, #36]	; (10ef8 <GPIO_10_Handler+0x30>)
   10ed4:	4798      	blx	r3
   10ed6:	4b09      	ldr	r3, [pc, #36]	; (10efc <GPIO_10_Handler+0x34>)
   10ed8:	4798      	blx	r3
   10eda:	4b09      	ldr	r3, [pc, #36]	; (10f00 <GPIO_10_Handler+0x38>)
   10edc:	4798      	blx	r3
   10ede:	4b09      	ldr	r3, [pc, #36]	; (10f04 <GPIO_10_Handler+0x3c>)
   10ee0:	4798      	blx	r3
   10ee2:	4b09      	ldr	r3, [pc, #36]	; (10f08 <GPIO_10_Handler+0x40>)
   10ee4:	4798      	blx	r3
   10ee6:	4b09      	ldr	r3, [pc, #36]	; (10f0c <GPIO_10_Handler+0x44>)
   10ee8:	4798      	blx	r3
   10eea:	4b09      	ldr	r3, [pc, #36]	; (10f10 <GPIO_10_Handler+0x48>)
   10eec:	4798      	blx	r3
   10eee:	bd08      	pop	{r3, pc}
   10ef0:	000107e5 	.word	0x000107e5
   10ef4:	000105c1 	.word	0x000105c1
   10ef8:	000105e1 	.word	0x000105e1
   10efc:	00010601 	.word	0x00010601
   10f00:	00010621 	.word	0x00010621
   10f04:	00010641 	.word	0x00010641
   10f08:	00010661 	.word	0x00010661
   10f0c:	00010681 	.word	0x00010681
   10f10:	000106a1 	.word	0x000106a1

00010f14 <GPIO_11_Handler>:
        signal PortC_IRQ.fired[2]();
        call IRQWrapper.postamble();
    }

    void GPIO_11_Handler() @C() @spontaneous()
    {
   10f14:	b508      	push	{r3, lr}
   10f16:	4b09      	ldr	r3, [pc, #36]	; (10f3c <GPIO_11_Handler+0x28>)
   10f18:	4798      	blx	r3
   10f1a:	4b09      	ldr	r3, [pc, #36]	; (10f40 <GPIO_11_Handler+0x2c>)
   10f1c:	4798      	blx	r3
   10f1e:	4b09      	ldr	r3, [pc, #36]	; (10f44 <GPIO_11_Handler+0x30>)
   10f20:	4798      	blx	r3
   10f22:	4b09      	ldr	r3, [pc, #36]	; (10f48 <GPIO_11_Handler+0x34>)
   10f24:	4798      	blx	r3
   10f26:	4b09      	ldr	r3, [pc, #36]	; (10f4c <GPIO_11_Handler+0x38>)
   10f28:	4798      	blx	r3
   10f2a:	4b09      	ldr	r3, [pc, #36]	; (10f50 <GPIO_11_Handler+0x3c>)
   10f2c:	4798      	blx	r3
   10f2e:	4b09      	ldr	r3, [pc, #36]	; (10f54 <GPIO_11_Handler+0x40>)
   10f30:	4798      	blx	r3
   10f32:	4b09      	ldr	r3, [pc, #36]	; (10f58 <GPIO_11_Handler+0x44>)
   10f34:	4798      	blx	r3
   10f36:	4b09      	ldr	r3, [pc, #36]	; (10f5c <GPIO_11_Handler+0x48>)
   10f38:	4798      	blx	r3
   10f3a:	bd08      	pop	{r3, pc}
   10f3c:	000107e5 	.word	0x000107e5
   10f40:	000106c1 	.word	0x000106c1
   10f44:	000106e1 	.word	0x000106e1
   10f48:	00010701 	.word	0x00010701
   10f4c:	00010721 	.word	0x00010721
   10f50:	00010741 	.word	0x00010741
   10f54:	00010761 	.word	0x00010761
   10f58:	00010781 	.word	0x00010781
   10f5c:	000107a1 	.word	0x000107a1

00010f60 <main>:
  uses interface Scheduler;
  uses interface Init as PlatformInit;
  uses interface Init as SoftwareInit;
}
implementation {
  int main() @C() @spontaneous() {
   10f60:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   10f64:	2301      	movs	r3, #1
   10f66:	f3ef 8510 	mrs	r5, PRIMASK
   10f6a:	f383 8810 	msr	PRIMASK, r3
  
  command void Scheduler.init()
  {
    atomic
    {
      memset( (void *)m_next, NO_TASK, sizeof(m_next) );
   10f6e:	21ff      	movs	r1, #255	; 0xff
   10f70:	2207      	movs	r2, #7
   10f72:	4bad      	ldr	r3, [pc, #692]	; (11228 <main+0x2c8>)
   10f74:	48ad      	ldr	r0, [pc, #692]	; (1122c <main+0x2cc>)

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   10f76:	f8df 932c 	ldr.w	r9, [pc, #812]	; 112a4 <main+0x344>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   10f7a:	f8df 832c 	ldr.w	r8, [pc, #812]	; 112a8 <main+0x348>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   10f7e:	4fac      	ldr	r7, [pc, #688]	; (11230 <main+0x2d0>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   10f80:	4eac      	ldr	r6, [pc, #688]	; (11234 <main+0x2d4>)
   10f82:	4798      	blx	r3
      m_head = NO_TASK;
   10f84:	4aac      	ldr	r2, [pc, #688]	; (11238 <main+0x2d8>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   10f86:	48ad      	ldr	r0, [pc, #692]	; (1123c <main+0x2dc>)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   10f88:	f8df e320 	ldr.w	lr, [pc, #800]	; 112ac <main+0x34c>
   10f8c:	23ff      	movs	r3, #255	; 0xff
   10f8e:	7013      	strb	r3, [r2, #0]
      m_tail = NO_TASK;
   10f90:	4aab      	ldr	r2, [pc, #684]	; (11240 <main+0x2e0>)
   10f92:	7013      	strb	r3, [r2, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   10f94:	4aab      	ldr	r2, [pc, #684]	; (11244 <main+0x2e4>)
    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   10f96:	2400      	movs	r4, #0

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   10f98:	f44f 6380 	mov.w	r3, #1024	; 0x400
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   10f9c:	f44f 6100 	mov.w	r1, #2048	; 0x800
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   10fa0:	f44f 5c80 	mov.w	ip, #4096	; 0x1000

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   10fa4:	f8c9 3000 	str.w	r3, [r9]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   10fa8:	f8c8 4000 	str.w	r4, [r8]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   10fac:	f8ce 3000 	str.w	r3, [lr]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   10fb0:	603c      	str	r4, [r7, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   10fb2:	6031      	str	r1, [r6, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   10fb4:	6004      	str	r4, [r0, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   10fb6:	f8c2 c000 	str.w	ip, [r2]

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   10fba:	f44f 7c00 	mov.w	ip, #512	; 0x200
   10fbe:	f8c9 c000 	str.w	ip, [r9]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   10fc2:	f8c8 4000 	str.w	r4, [r8]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   10fc6:	f8ce c000 	str.w	ip, [lr]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   10fca:	603c      	str	r4, [r7, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   10fcc:	6033      	str	r3, [r6, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   10fce:	6004      	str	r4, [r0, #0]
#include <usarthardware.h>
interface HplSam4lUSART
{
    async command void initUART();
   10fd0:	4b9d      	ldr	r3, [pc, #628]	; (11248 <main+0x2e8>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   10fd2:	6011      	str	r1, [r2, #0]
   10fd4:	4798      	blx	r3
    }
    async command void usart.enableTX()
	{
		USART->cr.bits.txen = 1;
   10fd6:	4b9d      	ldr	r3, [pc, #628]	; (1124c <main+0x2ec>)
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   10fd8:	489d      	ldr	r0, [pc, #628]	; (11250 <main+0x2f0>)
   10fda:	681a      	ldr	r2, [r3, #0]
   10fdc:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   10fe0:	601a      	str	r2, [r3, #0]
	{
		USART->cr.bits.rsttx = 1;
	}
	async command void usart.enableRX()
	{
		USART->cr.bits.rxen = 1;
   10fe2:	681a      	ldr	r2, [r3, #0]
   10fe4:	f042 0210 	orr.w	r2, r2, #16
   10fe8:	601a      	str	r2, [r3, #0]
		//cd = clk / 16*baud
		//   = gmclk*1000 / (16*b)
		//   = gmclk*625 / b*10
		uint32_t cd = (call MainClock.getMainClockSpeed())*625;
		cd /= (b*10);
		USART->brgr.bits.cd = cd;
   10fea:	6a1a      	ldr	r2, [r3, #32]
   10fec:	211a      	movs	r1, #26
   10fee:	f361 020f 	bfi	r2, r1, #0, #16
   10ff2:	621a      	str	r2, [r3, #32]

implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
   10ff4:	4b97      	ldr	r3, [pc, #604]	; (11254 <main+0x2f4>)
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   10ff6:	4998      	ldr	r1, [pc, #608]	; (11258 <main+0x2f8>)

implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
   10ff8:	681a      	ldr	r2, [r3, #0]
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   10ffa:	65c8      	str	r0, [r1, #92]	; 0x5c
implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
        shadow |= 1<<bit;
   10ffc:	f042 0202 	orr.w	r2, r2, #2
        PM->unlock = PM_UNLOCK_KEY | offset;
        *((uint32_t volatile *)((void volatile *)PM + offset)) = shadow;
   11000:	601a      	str	r2, [r3, #0]
	    return SUCCESS;
	}
	async command void HplSam4lSPIControl.enable()
	{
	    call SPIClockCtl.enable();
	    SPI->mr.bits.ps = 1; //Use variable peripheral select
   11002:	4b96      	ldr	r3, [pc, #600]	; (1125c <main+0x2fc>)
   11004:	685a      	ldr	r2, [r3, #4]
   11006:	f042 0202 	orr.w	r2, r2, #2
   1100a:	605a      	str	r2, [r3, #4]
		SPI->mr.bits.mstr = 1; //Master mode
   1100c:	685a      	ldr	r2, [r3, #4]
   1100e:	f042 0201 	orr.w	r2, r2, #1
   11012:	605a      	str	r2, [r3, #4]
		SPI->mr.bits.rxfifoen = 0; //Disable RX fifo
   11014:	685a      	ldr	r2, [r3, #4]
   11016:	f364 1286 	bfi	r2, r4, #6, #1
   1101a:	605a      	str	r2, [r3, #4]
		SPI->mr.bits.modfdis = 1; //Disable mode fault
   1101c:	685a      	ldr	r2, [r3, #4]
   1101e:	f042 0210 	orr.w	r2, r2, #16
   11022:	605a      	str	r2, [r3, #4]
	    SPI->cr.bits.spien = 1;
   11024:	681a      	ldr	r2, [r3, #0]
   11026:	f042 0201 	orr.w	r2, r2, #1
   1102a:	601a      	str	r2, [r3, #0]
        SPI->csr[0].bits.scbr = 8;
   1102c:	6b19      	ldr	r1, [r3, #48]	; 0x30
   1102e:	2208      	movs	r2, #8
   11030:	f362 210f 	bfi	r1, r2, #8, #8
   11034:	6319      	str	r1, [r3, #48]	; 0x30
        SPI->csr[1].bits.scbr = 8;
   11036:	6b59      	ldr	r1, [r3, #52]	; 0x34
   11038:	f362 210f 	bfi	r1, r2, #8, #8
   1103c:	6359      	str	r1, [r3, #52]	; 0x34
        SPI->csr[2].bits.scbr = 8;
   1103e:	6b99      	ldr	r1, [r3, #56]	; 0x38
   11040:	f362 210f 	bfi	r1, r2, #8, #8
   11044:	6399      	str	r1, [r3, #56]	; 0x38
        SPI->csr[3].bits.scbr = 8;
   11046:	6bd9      	ldr	r1, [r3, #60]	; 0x3c
   11048:	f362 210f 	bfi	r1, r2, #8, #8
   1104c:	63d9      	str	r1, [r3, #60]	; 0x3c
        SPI->csr[3].bits.ncpha = 1;
   1104e:	6bda      	ldr	r2, [r3, #60]	; 0x3c
   11050:	f042 0202 	orr.w	r2, r2, #2
   11054:	63da      	str	r2, [r3, #60]	; 0x3c
        return (PORT->oder & MASK) == 0;
	}

    async command void HplSam4lGeneralIO.selectPeripheralA()
    {
        PORT->pmr0c = MASK;
   11056:	4b82      	ldr	r3, [pc, #520]	; (11260 <main+0x300>)
   11058:	2220      	movs	r2, #32
   1105a:	619a      	str	r2, [r3, #24]
        PORT->pmr1c = MASK;
   1105c:	629a      	str	r2, [r3, #40]	; 0x28
        PORT->pmr2c = MASK;
   1105e:	639a      	str	r2, [r3, #56]	; 0x38
        PORT->gperc = MASK;
   11060:	609a      	str	r2, [r3, #8]
        return (PORT->oder & MASK) == 0;
	}

    async command void HplSam4lGeneralIO.selectPeripheralA()
    {
        PORT->pmr0c = MASK;
   11062:	2210      	movs	r2, #16
   11064:	619a      	str	r2, [r3, #24]
        PORT->pmr1c = MASK;
   11066:	629a      	str	r2, [r3, #40]	; 0x28
        PORT->pmr2c = MASK;
   11068:	639a      	str	r2, [r3, #56]	; 0x38
        PORT->gperc = MASK;
   1106a:	609a      	str	r2, [r3, #8]
        return (PORT->oder & MASK) == 0;
	}

    async command void HplSam4lGeneralIO.selectPeripheralA()
    {
        PORT->pmr0c = MASK;
   1106c:	2240      	movs	r2, #64	; 0x40
   1106e:	619a      	str	r2, [r3, #24]
        PORT->pmr1c = MASK;
   11070:	629a      	str	r2, [r3, #40]	; 0x28
        PORT->pmr2c = MASK;
   11072:	639a      	str	r2, [r3, #56]	; 0x38
        PORT->gperc = MASK;
   11074:	609a      	str	r2, [r3, #8]
  command bool Scheduler.runNextTask()
  {
    uint8_t nextTask;
    atomic
    {
      nextTask = popTask();
   11076:	4c7b      	ldr	r4, [pc, #492]	; (11264 <main+0x304>)
   11078:	47a0      	blx	r4
      if( nextTask == NO_TASK )
   1107a:	28ff      	cmp	r0, #255	; 0xff
   1107c:	d002      	beq.n	11084 <main+0x124>
      {
	return FALSE;
      }
    }
    signal TaskBasic.runTask[nextTask]();
   1107e:	4b7a      	ldr	r3, [pc, #488]	; (11268 <main+0x308>)
   11080:	4798      	blx	r3
   11082:	e7f8      	b.n	11076 <main+0x116>
  uint8_t resQ[size];
  uint8_t qHead = NO_ENTRY;
  uint8_t qTail = NO_ENTRY;

  command error_t Init.init() {
    memset(resQ, NO_ENTRY, sizeof(resQ));
   11084:	4a79      	ldr	r2, [pc, #484]	; (1126c <main+0x30c>)
implementation
{

    command error_t Init.init()
    {
        SYSTICK->csr.bits.clksource = 1;
   11086:	4b7a      	ldr	r3, [pc, #488]	; (11270 <main+0x310>)
   11088:	7010      	strb	r0, [r2, #0]
   1108a:	4a7a      	ldr	r2, [pc, #488]	; (11274 <main+0x314>)
   1108c:	7010      	strb	r0, [r2, #0]
   1108e:	4a7a      	ldr	r2, [pc, #488]	; (11278 <main+0x318>)
   11090:	7010      	strb	r0, [r2, #0]
   11092:	681a      	ldr	r2, [r3, #0]
   11094:	f042 0204 	orr.w	r2, r2, #4
   11098:	601a      	str	r2, [r3, #0]
        SYSTICK->csr.bits.tickint = 0;
   1109a:	681a      	ldr	r2, [r3, #0]
   1109c:	f36f 0241 	bfc	r2, #1, #1
   110a0:	601a      	str	r2, [r3, #0]
        SYSTICK->rvr = 0xFFFFFF;
   110a2:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
   110a6:	605a      	str	r2, [r3, #4]
        SYSTICK->csr.bits.enable = 1;
   110a8:	681a      	ldr	r2, [r3, #0]
   110aa:	f042 0201 	orr.w	r2, r2, #1
   110ae:	601a      	str	r2, [r3, #0]
  command bool Scheduler.runNextTask()
  {
    uint8_t nextTask;
    atomic
    {
      nextTask = popTask();
   110b0:	47a0      	blx	r4
      if( nextTask == NO_TASK )
   110b2:	28ff      	cmp	r0, #255	; 0xff
   110b4:	d002      	beq.n	110bc <main+0x15c>
      {
	return FALSE;
      }
    }
    signal TaskBasic.runTask[nextTask]();
   110b6:	4b6c      	ldr	r3, [pc, #432]	; (11268 <main+0x308>)
   110b8:	4798      	blx	r3
   110ba:	e7f9      	b.n	110b0 <main+0x150>
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   110bc:	f385 8810 	msr	PRIMASK, r5
// Enables all exceptions except hard fault and NMI
inline void __nesc_enable_interrupt() __attribute__((always_inline))
{
	__nesc_atomic_t newState = 0;

	asm volatile(
   110c0:	2300      	movs	r3, #0
   110c2:	f383 8810 	msr	PRIMASK, r3
        PORT->sters = MASK;
    }

	async command void IO.makeOutput()
	{
        PORT->gpers = MASK;
   110c6:	4966      	ldr	r1, [pc, #408]	; (11260 <main+0x300>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   110c8:	4e6c      	ldr	r6, [pc, #432]	; (1127c <main+0x31c>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   110ca:	486d      	ldr	r0, [pc, #436]	; (11280 <main+0x320>)

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   110cc:	f8df a1e0 	ldr.w	sl, [pc, #480]	; 112b0 <main+0x350>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   110d0:	f8df 81e0 	ldr.w	r8, [pc, #480]	; 112b4 <main+0x354>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   110d4:	f8df c1e0 	ldr.w	ip, [pc, #480]	; 112b8 <main+0x358>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   110d8:	f8df e1e0 	ldr.w	lr, [pc, #480]	; 112bc <main+0x35c>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   110dc:	4f69      	ldr	r7, [pc, #420]	; (11284 <main+0x324>)
   110de:	f44f 6380 	mov.w	r3, #1024	; 0x400
   110e2:	604b      	str	r3, [r1, #4]
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   110e4:	2200      	movs	r2, #0
        PORT->oders = MASK;
   110e6:	644b      	str	r3, [r1, #68]	; 0x44
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   110e8:	f44f 5500 	mov.w	r5, #8192	; 0x2000
        PORT->sterc = MASK;
   110ec:	f8c1 3168 	str.w	r3, [r1, #360]	; 0x168
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   110f0:	f44f 4980 	mov.w	r9, #16384	; 0x4000
        PORT->ovrs = MASK;
	}

	async command void IO.clr()
	{
        PORT->ovrc = MASK;
   110f4:	658b      	str	r3, [r1, #88]	; 0x58

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   110f6:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   110fa:	f8ca 3000 	str.w	r3, [sl]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   110fe:	f8c8 3000 	str.w	r3, [r8]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   11102:	f8cc 2000 	str.w	r2, [ip]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   11106:	f8ce 2000 	str.w	r2, [lr]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   1110a:	603d      	str	r5, [r7, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   1110c:	6032      	str	r2, [r6, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   1110e:	f8c0 9000 	str.w	r9, [r0]

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   11112:	f44f 6900 	mov.w	r9, #2048	; 0x800
   11116:	f8ca 9000 	str.w	r9, [sl]
   1111a:	f5a0 6086 	sub.w	r0, r0, #1072	; 0x430
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   1111e:	f8c8 9000 	str.w	r9, [r8]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   11122:	f8cc 2000 	str.w	r2, [ip]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   11126:	f8ce 2000 	str.w	r2, [lr]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   1112a:	603b      	str	r3, [r7, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   1112c:	6032      	str	r2, [r6, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   1112e:	f8c0 5430 	str.w	r5, [r0, #1072]	; 0x430

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   11132:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   11136:	6003      	str	r3, [r0, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   11138:	60c2      	str	r2, [r0, #12]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   1113a:	6103      	str	r3, [r0, #16]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   1113c:	4b52      	ldr	r3, [pc, #328]	; (11288 <main+0x328>)
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   1113e:	4d46      	ldr	r5, [pc, #280]	; (11258 <main+0x2f8>)
   11140:	601a      	str	r2, [r3, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   11142:	f44f 2000 	mov.w	r0, #524288	; 0x80000
   11146:	6058      	str	r0, [r3, #4]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   11148:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   1114c:	611a      	str	r2, [r3, #16]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   1114e:	6158      	str	r0, [r3, #20]

implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
   11150:	4b40      	ldr	r3, [pc, #256]	; (11254 <main+0x2f4>)
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   11152:	4e3f      	ldr	r6, [pc, #252]	; (11250 <main+0x2f0>)

implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
   11154:	6818      	ldr	r0, [r3, #0]
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   11156:	65ee      	str	r6, [r5, #92]	; 0x5c
implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
        shadow |= 1<<bit;
   11158:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
        PM->unlock = PM_UNLOCK_KEY | offset;
        *((uint32_t volatile *)((void volatile *)PM + offset)) = shadow;
   1115c:	6018      	str	r0, [r3, #0]
		USART->ttgr = 4; //Space between bytes: 4 bits
	}
	async command void usart.initSPIMaster()
	{
	    call ClockCtl.enable();
	    USART->mr.bits.chrl = 3; //8 bits
   1115e:	4b4b      	ldr	r3, [pc, #300]	; (1128c <main+0x32c>)
   11160:	6858      	ldr	r0, [r3, #4]
   11162:	f040 00c0 	orr.w	r0, r0, #192	; 0xc0
   11166:	6058      	str	r0, [r3, #4]
	    USART->mr.bits.usclks = 0; //use clk_usart.
   11168:	6858      	ldr	r0, [r3, #4]
   1116a:	f362 1005 	bfi	r0, r2, #4, #2
   1116e:	6058      	str	r0, [r3, #4]
		USART->mr.bits.mode = 0b1110; //SPI Master
   11170:	6858      	ldr	r0, [r3, #4]
   11172:	250e      	movs	r5, #14
   11174:	f365 0003 	bfi	r0, r5, #0, #4
   11178:	6058      	str	r0, [r3, #4]
		USART->mr.bits.clko = 1;
   1117a:	6858      	ldr	r0, [r3, #4]
   1117c:	f440 2080 	orr.w	r0, r0, #262144	; 0x40000
   11180:	6058      	str	r0, [r3, #4]
		USART->ttgr = 4;
   11182:	2004      	movs	r0, #4
   11184:	6298      	str	r0, [r3, #40]	; 0x28
    {
        USART->cr.bits.rtsdis_rcs = 1;
    }
    async command void usart.setSPIMode(uint8_t cpol, uint8_t cpha)
    {
        USART->mr.bits.msbf_cpol = (cpol != 0);
   11186:	6858      	ldr	r0, [r3, #4]
   11188:	f362 4010 	bfi	r0, r2, #16, #1
   1118c:	6058      	str	r0, [r3, #4]
        //ATMEL's definition of CPHA is different from everyone else, so we invert it.
        //Don't hate, appreciate.
        USART->mr.bits.sync_cpha = (cpha == 0);
   1118e:	685a      	ldr	r2, [r3, #4]
   11190:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   11194:	605a      	str	r2, [r3, #4]
	{
		//cd = clk / baud
		//   = gmclk*1000 / b
		uint32_t cd = (call MainClock.getMainClockSpeed())*1000;
		cd /= b;
		USART->brgr.bits.cd = cd;
   11196:	6a1a      	ldr	r2, [r3, #32]
   11198:	f44f 6016 	mov.w	r0, #2400	; 0x960
   1119c:	f360 020f 	bfi	r2, r0, #0, #16
   111a0:	621a      	str	r2, [r3, #32]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
    }
    async command void usart.enableTX()
	{
		USART->cr.bits.txen = 1;
   111a2:	681a      	ldr	r2, [r3, #0]
   111a4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   111a8:	601a      	str	r2, [r3, #0]
	{
		USART->cr.bits.rsttx = 1;
	}
	async command void usart.enableRX()
	{
		USART->cr.bits.rxen = 1;
   111aa:	681a      	ldr	r2, [r3, #0]
   111ac:	f042 0210 	orr.w	r2, r2, #16
   111b0:	601a      	str	r2, [r3, #0]
        PORT->sters = MASK;
    }

	async command void IO.makeOutput()
	{
        PORT->gpers = MASK;
   111b2:	2380      	movs	r3, #128	; 0x80
   111b4:	604b      	str	r3, [r1, #4]
        PORT->oders = MASK;
   111b6:	644b      	str	r3, [r1, #68]	; 0x44
        PORT->sterc = MASK;
   111b8:	f8c1 3168 	str.w	r3, [r1, #360]	; 0x168
        return (PORT->pvr & MASK) != 0;
	}

	async command void IO.set()
	{
        PORT->ovrs = MASK;
   111bc:	654b      	str	r3, [r1, #84]	; 0x54
        PORT->ovrt = MASK;
	}

	async command void IO.makeInput()
	{
        PORT->gpers = MASK;
   111be:	4b34      	ldr	r3, [pc, #208]	; (11290 <main+0x330>)
            call GPIOClock.disable();
        }
    }
    async command void PortA.enableIRQ(uint8_t bit)
    {
        NVIC->iser.flat[0] = 1 << (25 + (bit>>3));
   111c0:	4934      	ldr	r1, [pc, #208]	; (11294 <main+0x334>)
   111c2:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   111c6:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
   111ca:	605a      	str	r2, [r3, #4]
        PORT->oderc = MASK;
   111cc:	649a      	str	r2, [r3, #72]	; 0x48
        PORT->sters = MASK;
   111ce:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164
    {
        PORT->ifrc = MASK;
    }
    async command error_t IRQ.enableRisingEdge()
    {
        PORT->imr0s = MASK;
   111d2:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
        PORT->imr1c = MASK;
   111d6:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
   111da:	6008      	str	r0, [r1, #0]
        GPIO_PORT_A->iers = 1 << bit;
   111dc:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
        call HplSam4lGeneralIOPort.enableIRQ(bit);
        return SUCCESS;
    }
    async command error_t IRQ.enableFallingEdge()
    {
        PORT->imr0c = MASK;
   111e0:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
        PORT->imr1s = MASK;
   111e4:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
            call GPIOClock.disable();
        }
    }
    async command void PortA.enableIRQ(uint8_t bit)
    {
        NVIC->iser.flat[0] = 1 << (25 + (bit>>3));
   111e8:	6008      	str	r0, [r1, #0]
        GPIO_PORT_A->iers = 1 << bit;
   111ea:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    call CS.makeOutput();
    call CS.set();
    call IntPort.makeInput();
    call Int.enableRisingEdge();
    call Int.enableFallingEdge();
    txbuf[0] = 1;
   111ee:	4a2a      	ldr	r2, [pc, #168]	; (11298 <main+0x338>)
   111f0:	2301      	movs	r3, #1
   111f2:	7013      	strb	r3, [r2, #0]
    spiqueued = 1;
   111f4:	4a29      	ldr	r2, [pc, #164]	; (1129c <main+0x33c>)
   111f6:	7013      	strb	r3, [r2, #0]

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   111f8:	2301      	movs	r3, #1
   111fa:	f3ef 8510 	mrs	r5, PRIMASK
   111fe:	f383 8810 	msr	PRIMASK, r3
    {
      uint8_t nextTask;

      atomic
      {
	while ((nextTask = popTask()) == NO_TASK)
   11202:	47a0      	blx	r4
   11204:	28ff      	cmp	r0, #255	; 0xff
   11206:	d10a      	bne.n	1121e <main+0x2be>
  }

  async command void McuSleep.sleep()
  {
    commonSleep();
    switch(ps = getPowerState()) {
   11208:	4b25      	ldr	r3, [pc, #148]	; (112a0 <main+0x340>)
   1120a:	2202      	movs	r2, #2
   1120c:	601a      	str	r2, [r3, #0]
// Enables all exceptions except hard fault and NMI
inline void __nesc_enable_interrupt() __attribute__((always_inline))
{
	__nesc_atomic_t newState = 0;

	asm volatile(
   1120e:	2300      	movs	r3, #0
   11210:	f383 8810 	msr	PRIMASK, r3
     * We need to disable sleep while debugging. Else, the GDB connection gets
     * disconnected.
     */
    // Enter appropriate idle mode
    if(ps != S_AWAKE)
      __asm volatile ("wfe");
   11214:	bf20      	wfe
// Disables all exceptions except hard fault and NMI
inline void __nesc_disable_interrupt() __attribute__((always_inline))
{
	__nesc_atomic_t newState = 1;

	asm volatile(
   11216:	2301      	movs	r3, #1
   11218:	f383 8810 	msr	PRIMASK, r3
   1121c:	e7f1      	b.n	11202 <main+0x2a2>
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   1121e:	f385 8810 	msr	PRIMASK, r5
	{
	  call McuSleep.sleep();
	}
      }
      signal TaskBasic.runTask[nextTask]();
   11222:	4b11      	ldr	r3, [pc, #68]	; (11268 <main+0x308>)
   11224:	4798      	blx	r3
   11226:	e7e7      	b.n	111f8 <main+0x298>
   11228:	00011a39 	.word	0x00011a39
   1122c:	20000048 	.word	0x20000048
   11230:	400e1224 	.word	0x400e1224
   11234:	400e1228 	.word	0x400e1228
   11238:	20000210 	.word	0x20000210
   1123c:	400e1234 	.word	0x400e1234
   11240:	2000021c 	.word	0x2000021c
   11244:	400e1238 	.word	0x400e1238
   11248:	00010801 	.word	0x00010801
   1124c:	40030000 	.word	0x40030000
   11250:	aa000028 	.word	0xaa000028
   11254:	400e0028 	.word	0x400e0028
   11258:	400e0000 	.word	0x400e0000
   1125c:	40008000 	.word	0x40008000
   11260:	400e1400 	.word	0x400e1400
   11264:	000107bd 	.word	0x000107bd
   11268:	00010c11 	.word	0x00010c11
   1126c:	20000041 	.word	0x20000041
   11270:	e000e010 	.word	0xe000e010
   11274:	2000005a 	.word	0x2000005a
   11278:	20000218 	.word	0x20000218
   1127c:	400e1434 	.word	0x400e1434
   11280:	400e1438 	.word	0x400e1438
   11284:	400e1428 	.word	0x400e1428
   11288:	400e1024 	.word	0x400e1024
   1128c:	4002c000 	.word	0x4002c000
   11290:	400e1000 	.word	0x400e1000
   11294:	e000e100 	.word	0xe000e100
   11298:	200000b8 	.word	0x200000b8
   1129c:	20000034 	.word	0x20000034
   112a0:	20000214 	.word	0x20000214
   112a4:	400e1208 	.word	0x400e1208
   112a8:	400e1214 	.word	0x400e1214
   112ac:	400e1218 	.word	0x400e1218
   112b0:	400e1408 	.word	0x400e1408
   112b4:	400e1414 	.word	0x400e1414
   112b8:	400e1418 	.word	0x400e1418
   112bc:	400e1424 	.word	0x400e1424

000112c0 <USART0_Handler>:
   112c0:	4b44      	ldr	r3, [pc, #272]	; (113d4 <USART0_Handler+0x114>)
    }
}
implementation
{
    void USART0_Handler() @C() @spontaneous()
    {
   112c2:	b570      	push	{r4, r5, r6, lr}
   112c4:	4798      	blx	r3
	{
	    return USART->csr.bits.txrdy == 1;
	}
	async command bool usart.isRXRdy()
	{
	    return USART->csr.bits.rxrdy == 1;
   112c6:	4b44      	ldr	r3, [pc, #272]	; (113d8 <USART0_Handler+0x118>)
   112c8:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart0.isRXRdy() && call usart0irq.isRXRdyIRQEnabled())
   112ca:	07d1      	lsls	r1, r2, #31
   112cc:	d52c      	bpl.n	11328 <USART0_Handler+0x68>
	{
	    USART0->idr.bits.rxrdy = 1;
	}
	async command bool usart0irq.isRXRdyIRQEnabled()
	{
	    return USART0->imr.bits.rxrdy == 1;
   112ce:	691a      	ldr	r2, [r3, #16]
implementation
{
    void USART0_Handler() @C() @spontaneous()
    {
        call IRQWrapper.preamble();
        if (call usart0.isRXRdy() && call usart0irq.isRXRdyIRQEnabled())
   112d0:	07d2      	lsls	r2, r2, #31
   112d2:	d529      	bpl.n	11328 <USART0_Handler+0x68>
		USART->mr.bits.clko = 1;
		USART->ttgr = 4;
	}
	async command uint8_t usart.readData()
	{
		return USART->rhr.bits.rxchr;
   112d4:	6998      	ldr	r0, [r3, #24]
    }

    async event void usart_irq.RXRdyFired()
    {
        uint8_t data = call usart.readData();
        if (!irqmode_spi)
   112d6:	4b41      	ldr	r3, [pc, #260]	; (113dc <USART0_Handler+0x11c>)
   112d8:	7819      	ldrb	r1, [r3, #0]
   112da:	4b41      	ldr	r3, [pc, #260]	; (113e0 <USART0_Handler+0x120>)
   112dc:	b2c0      	uxtb	r0, r0
   112de:	b969      	cbnz	r1, 112fc <USART0_Handler+0x3c>
        {
            if (forwardRXIRQ)
            {
                signal UartStream.receivedByte(data);
            }
            if (rx_buf != NULL)
   112e0:	681d      	ldr	r5, [r3, #0]
   112e2:	b30d      	cbz	r5, 11328 <USART0_Handler+0x68>
            {
                rx_buf[rx_ptr++] = data;
   112e4:	4a3f      	ldr	r2, [pc, #252]	; (113e4 <USART0_Handler+0x124>)
   112e6:	8814      	ldrh	r4, [r2, #0]
   112e8:	1c66      	adds	r6, r4, #1
   112ea:	8016      	strh	r6, [r2, #0]
   112ec:	5528      	strb	r0, [r5, r4]
                if (rx_ptr == rx_len)
   112ee:	8810      	ldrh	r0, [r2, #0]
   112f0:	4a3d      	ldr	r2, [pc, #244]	; (113e8 <USART0_Handler+0x128>)
   112f2:	8812      	ldrh	r2, [r2, #0]
   112f4:	4290      	cmp	r0, r2
   112f6:	d117      	bne.n	11328 <USART0_Handler+0x68>
                {
                    uint8_t *bufcpy = rx_buf;
                    rx_buf = NULL;
   112f8:	6019      	str	r1, [r3, #0]
   112fa:	e015      	b.n	11328 <USART0_Handler+0x68>
                }
            }
        }
        else
        {
            if (rx_buf != NULL) rx_buf[rx_ptr] = data;
   112fc:	6819      	ldr	r1, [r3, #0]
   112fe:	4a39      	ldr	r2, [pc, #228]	; (113e4 <USART0_Handler+0x124>)
   11300:	b109      	cbz	r1, 11306 <USART0_Handler+0x46>
   11302:	8814      	ldrh	r4, [r2, #0]
   11304:	5508      	strb	r0, [r1, r4]
            rx_ptr++;
   11306:	8811      	ldrh	r1, [r2, #0]
   11308:	3101      	adds	r1, #1
   1130a:	b289      	uxth	r1, r1
   1130c:	8011      	strh	r1, [r2, #0]
            if (rx_ptr == tx_len)
   1130e:	4a37      	ldr	r2, [pc, #220]	; (113ec <USART0_Handler+0x12c>)
   11310:	8812      	ldrh	r2, [r2, #0]
   11312:	428a      	cmp	r2, r1
   11314:	d108      	bne.n	11328 <USART0_Handler+0x68>
            {
                uint8_t *txbufcpy = tx_buf;
                uint8_t *rxbufcpy = rx_buf;
                rx_buf = NULL;
   11316:	2200      	movs	r2, #0
   11318:	601a      	str	r2, [r3, #0]
                tx_buf = NULL;
   1131a:	4b35      	ldr	r3, [pc, #212]	; (113f0 <USART0_Handler+0x130>)
   1131c:	601a      	str	r2, [r3, #0]
        enableUSART0IRQ();
	    USART0->ier.bits.rxrdy = 1;
	}
	async command void usart0irq.disableRXRdyIRQ()
	{
	    USART0->idr.bits.rxrdy = 1;
   1131e:	4a2e      	ldr	r2, [pc, #184]	; (113d8 <USART0_Handler+0x118>)
   11320:	68d3      	ldr	r3, [r2, #12]
   11322:	f043 0301 	orr.w	r3, r3, #1
   11326:	60d3      	str	r3, [r2, #12]
	{
		USART->thr.bits.txchr = d;
	}
	async command bool usart.isTXRdy()
	{
	    return USART->csr.bits.txrdy == 1;
   11328:	4b2b      	ldr	r3, [pc, #172]	; (113d8 <USART0_Handler+0x118>)
   1132a:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart0.isRXRdy() && call usart0irq.isRXRdyIRQEnabled())
        {
            signal usart0irq.RXRdyFired();
        }
        if (call usart0.isTXRdy() && call usart0irq.isTXRdyIRQEnabled())
   1132c:	0796      	lsls	r6, r2, #30
   1132e:	d54f      	bpl.n	113d0 <USART0_Handler+0x110>
	{
	    return USART0->imr.bits.rxrdy == 1;
	}
	async command bool usart0irq.isTXRdyIRQEnabled()
	{
	    return USART0->imr.bits.txrdy == 1;
   11330:	691a      	ldr	r2, [r3, #16]
        call IRQWrapper.preamble();
        if (call usart0.isRXRdy() && call usart0irq.isRXRdyIRQEnabled())
        {
            signal usart0irq.RXRdyFired();
        }
        if (call usart0.isTXRdy() && call usart0irq.isTXRdyIRQEnabled())
   11332:	0795      	lsls	r5, r2, #30
   11334:	d54c      	bpl.n	113d0 <USART0_Handler+0x110>
    default async event void UartStream.receiveDone( uint8_t* buf, uint16_t len, error_t error ){}
    default async event void UartStream.receivedByte( uint8_t byte ){}

    async event void usart_irq.TXRdyFired()
    {
        if (!irqmode_spi)
   11336:	4a29      	ldr	r2, [pc, #164]	; (113dc <USART0_Handler+0x11c>)
   11338:	7811      	ldrb	r1, [r2, #0]
   1133a:	4a2d      	ldr	r2, [pc, #180]	; (113f0 <USART0_Handler+0x130>)
   1133c:	bb19      	cbnz	r1, 11386 <USART0_Handler+0xc6>
        {
            if (tx_buf == NULL)
   1133e:	6811      	ldr	r1, [r2, #0]
   11340:	b921      	cbnz	r1, 1134c <USART0_Handler+0x8c>
        enableUSART0IRQ();
        USART0->ier.bits.txrdy = 1;
    }
	async command void usart0irq.disableTXRdyIRQ()
	{
	    USART0->idr.bits.txrdy = 1;
   11342:	68da      	ldr	r2, [r3, #12]
   11344:	f042 0202 	orr.w	r2, r2, #2
   11348:	60da      	str	r2, [r3, #12]
   1134a:	bd70      	pop	{r4, r5, r6, pc}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   1134c:	2301      	movs	r3, #1
   1134e:	f3ef 8010 	mrs	r0, PRIMASK
   11352:	f383 8810 	msr	PRIMASK, r3
                return;
            }
            atomic
            {

                call usart.sendData(tx_buf[tx_ptr++]);
   11356:	4927      	ldr	r1, [pc, #156]	; (113f4 <USART0_Handler+0x134>)
   11358:	6814      	ldr	r4, [r2, #0]
   1135a:	880b      	ldrh	r3, [r1, #0]
   1135c:	1c5a      	adds	r2, r3, #1
   1135e:	b292      	uxth	r2, r2
   11360:	800a      	strh	r2, [r1, #0]
	{
		return USART->rhr.bits.rxchr;
	}
	async command void usart.sendData(uint8_t d)
	{
		USART->thr.bits.txchr = d;
   11362:	5ce4      	ldrb	r4, [r4, r3]
   11364:	4b1c      	ldr	r3, [pc, #112]	; (113d8 <USART0_Handler+0x118>)
   11366:	69d9      	ldr	r1, [r3, #28]
   11368:	f364 0108 	bfi	r1, r4, #0, #9
   1136c:	61d9      	str	r1, [r3, #28]
                if (tx_ptr == tx_len)
   1136e:	491f      	ldr	r1, [pc, #124]	; (113ec <USART0_Handler+0x12c>)
   11370:	8809      	ldrh	r1, [r1, #0]
   11372:	4291      	cmp	r1, r2
   11374:	d12a      	bne.n	113cc <USART0_Handler+0x10c>
                {
                    uint8_t * bufcpy;
                    bufcpy = tx_buf;
                    tx_buf = NULL;
   11376:	4a1e      	ldr	r2, [pc, #120]	; (113f0 <USART0_Handler+0x130>)
   11378:	2100      	movs	r1, #0
   1137a:	6011      	str	r1, [r2, #0]
   1137c:	68da      	ldr	r2, [r3, #12]
   1137e:	f042 0202 	orr.w	r2, r2, #2
   11382:	60da      	str	r2, [r3, #12]
   11384:	e022      	b.n	113cc <USART0_Handler+0x10c>
   11386:	2301      	movs	r3, #1
   11388:	f3ef 8010 	mrs	r0, PRIMASK
   1138c:	f383 8810 	msr	PRIMASK, r3
        }
        else
        {
            atomic
            {
                if (tx_buf == NULL)
   11390:	6811      	ldr	r1, [r2, #0]
   11392:	4b18      	ldr	r3, [pc, #96]	; (113f4 <USART0_Handler+0x134>)
   11394:	4a10      	ldr	r2, [pc, #64]	; (113d8 <USART0_Handler+0x118>)
   11396:	b939      	cbnz	r1, 113a8 <USART0_Handler+0xe8>
   11398:	69d4      	ldr	r4, [r2, #28]
   1139a:	f361 0408 	bfi	r4, r1, #0, #9
   1139e:	61d4      	str	r4, [r2, #28]
                {
                    call usart.sendData(0);
                    tx_ptr++;
   113a0:	881a      	ldrh	r2, [r3, #0]
   113a2:	3201      	adds	r2, #1
   113a4:	801a      	strh	r2, [r3, #0]
   113a6:	e007      	b.n	113b8 <USART0_Handler+0xf8>
                }
                else
                {
                    call usart.sendData(tx_buf[tx_ptr]);
   113a8:	881c      	ldrh	r4, [r3, #0]
   113aa:	5d0d      	ldrb	r5, [r1, r4]
   113ac:	69d1      	ldr	r1, [r2, #28]
                    tx_ptr++;
   113ae:	3401      	adds	r4, #1
   113b0:	f365 0108 	bfi	r1, r5, #0, #9
   113b4:	61d1      	str	r1, [r2, #28]
   113b6:	801c      	strh	r4, [r3, #0]
                }
                if (tx_ptr == tx_len)
   113b8:	881a      	ldrh	r2, [r3, #0]
   113ba:	4b0c      	ldr	r3, [pc, #48]	; (113ec <USART0_Handler+0x12c>)
   113bc:	881b      	ldrh	r3, [r3, #0]
   113be:	429a      	cmp	r2, r3
   113c0:	d104      	bne.n	113cc <USART0_Handler+0x10c>
   113c2:	4a05      	ldr	r2, [pc, #20]	; (113d8 <USART0_Handler+0x118>)
   113c4:	68d3      	ldr	r3, [r2, #12]
   113c6:	f043 0302 	orr.w	r3, r3, #2
   113ca:	60d3      	str	r3, [r2, #12]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   113cc:	f380 8810 	msr	PRIMASK, r0
   113d0:	bd70      	pop	{r4, r5, r6, pc}
   113d2:	bf00      	nop
   113d4:	000107e5 	.word	0x000107e5
   113d8:	40024000 	.word	0x40024000
   113dc:	20000009 	.word	0x20000009
   113e0:	20000028 	.word	0x20000028
   113e4:	2000021a 	.word	0x2000021a
   113e8:	2000005c 	.word	0x2000005c
   113ec:	200000b6 	.word	0x200000b6
   113f0:	20000020 	.word	0x20000020
   113f4:	20000044 	.word	0x20000044

000113f8 <USART1_Handler>:
        }
        call IRQWrapper.postamble();
    }

    void USART1_Handler() @C() @spontaneous()
    {
   113f8:	b570      	push	{r4, r5, r6, lr}
   113fa:	4b44      	ldr	r3, [pc, #272]	; (1150c <USART1_Handler+0x114>)
   113fc:	4798      	blx	r3
	{
	    return USART->csr.bits.txrdy == 1;
	}
	async command bool usart.isRXRdy()
	{
	    return USART->csr.bits.rxrdy == 1;
   113fe:	4b44      	ldr	r3, [pc, #272]	; (11510 <USART1_Handler+0x118>)
   11400:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart1.isRXRdy() && call usart1irq.isRXRdyIRQEnabled())
   11402:	07d6      	lsls	r6, r2, #31
   11404:	d52c      	bpl.n	11460 <USART1_Handler+0x68>
	{
	    USART1->idr.bits.rxrdy = 1;
	}
	async command bool usart1irq.isRXRdyIRQEnabled()
	{
	    return USART1->imr.bits.rxrdy == 1;
   11406:	691a      	ldr	r2, [r3, #16]
    }

    void USART1_Handler() @C() @spontaneous()
    {
        call IRQWrapper.preamble();
        if (call usart1.isRXRdy() && call usart1irq.isRXRdyIRQEnabled())
   11408:	07d5      	lsls	r5, r2, #31
   1140a:	d529      	bpl.n	11460 <USART1_Handler+0x68>
		USART->mr.bits.clko = 1;
		USART->ttgr = 4;
	}
	async command uint8_t usart.readData()
	{
		return USART->rhr.bits.rxchr;
   1140c:	6998      	ldr	r0, [r3, #24]
    }

    async event void usart_irq.RXRdyFired()
    {
        uint8_t data = call usart.readData();
        if (!irqmode_spi)
   1140e:	4b41      	ldr	r3, [pc, #260]	; (11514 <USART1_Handler+0x11c>)
   11410:	7819      	ldrb	r1, [r3, #0]
   11412:	4b41      	ldr	r3, [pc, #260]	; (11518 <USART1_Handler+0x120>)
   11414:	b2c0      	uxtb	r0, r0
   11416:	b969      	cbnz	r1, 11434 <USART1_Handler+0x3c>
        {
            if (forwardRXIRQ)
            {
                signal UartStream.receivedByte(data);
            }
            if (rx_buf != NULL)
   11418:	681d      	ldr	r5, [r3, #0]
   1141a:	b30d      	cbz	r5, 11460 <USART1_Handler+0x68>
            {
                rx_buf[rx_ptr++] = data;
   1141c:	4a3f      	ldr	r2, [pc, #252]	; (1151c <USART1_Handler+0x124>)
   1141e:	8814      	ldrh	r4, [r2, #0]
   11420:	1c66      	adds	r6, r4, #1
   11422:	8016      	strh	r6, [r2, #0]
   11424:	5528      	strb	r0, [r5, r4]
                if (rx_ptr == rx_len)
   11426:	8810      	ldrh	r0, [r2, #0]
   11428:	4a3d      	ldr	r2, [pc, #244]	; (11520 <USART1_Handler+0x128>)
   1142a:	8812      	ldrh	r2, [r2, #0]
   1142c:	4290      	cmp	r0, r2
   1142e:	d117      	bne.n	11460 <USART1_Handler+0x68>
                {
                    uint8_t *bufcpy = rx_buf;
                    rx_buf = NULL;
   11430:	6019      	str	r1, [r3, #0]
   11432:	e015      	b.n	11460 <USART1_Handler+0x68>
                }
            }
        }
        else
        {
            if (rx_buf != NULL) rx_buf[rx_ptr] = data;
   11434:	6819      	ldr	r1, [r3, #0]
   11436:	4a39      	ldr	r2, [pc, #228]	; (1151c <USART1_Handler+0x124>)
   11438:	b109      	cbz	r1, 1143e <USART1_Handler+0x46>
   1143a:	8814      	ldrh	r4, [r2, #0]
   1143c:	5508      	strb	r0, [r1, r4]
            rx_ptr++;
   1143e:	8811      	ldrh	r1, [r2, #0]
   11440:	3101      	adds	r1, #1
   11442:	b289      	uxth	r1, r1
   11444:	8011      	strh	r1, [r2, #0]
            if (rx_ptr == tx_len)
   11446:	4a37      	ldr	r2, [pc, #220]	; (11524 <USART1_Handler+0x12c>)
   11448:	8812      	ldrh	r2, [r2, #0]
   1144a:	428a      	cmp	r2, r1
   1144c:	d108      	bne.n	11460 <USART1_Handler+0x68>
            {
                uint8_t *txbufcpy = tx_buf;
                uint8_t *rxbufcpy = rx_buf;
                rx_buf = NULL;
   1144e:	2200      	movs	r2, #0
   11450:	601a      	str	r2, [r3, #0]
                tx_buf = NULL;
   11452:	4b35      	ldr	r3, [pc, #212]	; (11528 <USART1_Handler+0x130>)
   11454:	601a      	str	r2, [r3, #0]
        enableUSART1IRQ();
	    USART1->ier.bits.rxrdy = 1;
	}
	async command void usart1irq.disableRXRdyIRQ()
	{
	    USART1->idr.bits.rxrdy = 1;
   11456:	4a2e      	ldr	r2, [pc, #184]	; (11510 <USART1_Handler+0x118>)
   11458:	68d3      	ldr	r3, [r2, #12]
   1145a:	f043 0301 	orr.w	r3, r3, #1
   1145e:	60d3      	str	r3, [r2, #12]
	{
		USART->thr.bits.txchr = d;
	}
	async command bool usart.isTXRdy()
	{
	    return USART->csr.bits.txrdy == 1;
   11460:	4b2b      	ldr	r3, [pc, #172]	; (11510 <USART1_Handler+0x118>)
   11462:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart1.isRXRdy() && call usart1irq.isRXRdyIRQEnabled())
        {
            signal usart1irq.RXRdyFired();
        }
        if (call usart1.isTXRdy() && call usart1irq.isTXRdyIRQEnabled())
   11464:	0794      	lsls	r4, r2, #30
   11466:	d54f      	bpl.n	11508 <USART1_Handler+0x110>
	{
	    return USART1->imr.bits.rxrdy == 1;
	}
	async command bool usart1irq.isTXRdyIRQEnabled()
	{
	    return USART1->imr.bits.txrdy == 1;
   11468:	691a      	ldr	r2, [r3, #16]
        call IRQWrapper.preamble();
        if (call usart1.isRXRdy() && call usart1irq.isRXRdyIRQEnabled())
        {
            signal usart1irq.RXRdyFired();
        }
        if (call usart1.isTXRdy() && call usart1irq.isTXRdyIRQEnabled())
   1146a:	0790      	lsls	r0, r2, #30
   1146c:	d54c      	bpl.n	11508 <USART1_Handler+0x110>
    default async event void UartStream.receiveDone( uint8_t* buf, uint16_t len, error_t error ){}
    default async event void UartStream.receivedByte( uint8_t byte ){}

    async event void usart_irq.TXRdyFired()
    {
        if (!irqmode_spi)
   1146e:	4a29      	ldr	r2, [pc, #164]	; (11514 <USART1_Handler+0x11c>)
   11470:	7811      	ldrb	r1, [r2, #0]
   11472:	4a2d      	ldr	r2, [pc, #180]	; (11528 <USART1_Handler+0x130>)
   11474:	bb19      	cbnz	r1, 114be <USART1_Handler+0xc6>
        {
            if (tx_buf == NULL)
   11476:	6811      	ldr	r1, [r2, #0]
   11478:	b921      	cbnz	r1, 11484 <USART1_Handler+0x8c>
        enableUSART1IRQ();
        USART1->ier.bits.txrdy = 1;
    }
	async command void usart1irq.disableTXRdyIRQ()
	{
	    USART1->idr.bits.txrdy = 1;
   1147a:	68da      	ldr	r2, [r3, #12]
   1147c:	f042 0202 	orr.w	r2, r2, #2
   11480:	60da      	str	r2, [r3, #12]
   11482:	bd70      	pop	{r4, r5, r6, pc}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   11484:	2301      	movs	r3, #1
   11486:	f3ef 8010 	mrs	r0, PRIMASK
   1148a:	f383 8810 	msr	PRIMASK, r3
                return;
            }
            atomic
            {

                call usart.sendData(tx_buf[tx_ptr++]);
   1148e:	4927      	ldr	r1, [pc, #156]	; (1152c <USART1_Handler+0x134>)
   11490:	6814      	ldr	r4, [r2, #0]
   11492:	880b      	ldrh	r3, [r1, #0]
   11494:	1c5a      	adds	r2, r3, #1
   11496:	b292      	uxth	r2, r2
   11498:	800a      	strh	r2, [r1, #0]
	{
		return USART->rhr.bits.rxchr;
	}
	async command void usart.sendData(uint8_t d)
	{
		USART->thr.bits.txchr = d;
   1149a:	5ce4      	ldrb	r4, [r4, r3]
   1149c:	4b1c      	ldr	r3, [pc, #112]	; (11510 <USART1_Handler+0x118>)
   1149e:	69d9      	ldr	r1, [r3, #28]
   114a0:	f364 0108 	bfi	r1, r4, #0, #9
   114a4:	61d9      	str	r1, [r3, #28]
                if (tx_ptr == tx_len)
   114a6:	491f      	ldr	r1, [pc, #124]	; (11524 <USART1_Handler+0x12c>)
   114a8:	8809      	ldrh	r1, [r1, #0]
   114aa:	4291      	cmp	r1, r2
   114ac:	d12a      	bne.n	11504 <USART1_Handler+0x10c>
                {
                    uint8_t * bufcpy;
                    bufcpy = tx_buf;
                    tx_buf = NULL;
   114ae:	4a1e      	ldr	r2, [pc, #120]	; (11528 <USART1_Handler+0x130>)
   114b0:	2100      	movs	r1, #0
   114b2:	6011      	str	r1, [r2, #0]
   114b4:	68da      	ldr	r2, [r3, #12]
   114b6:	f042 0202 	orr.w	r2, r2, #2
   114ba:	60da      	str	r2, [r3, #12]
   114bc:	e022      	b.n	11504 <USART1_Handler+0x10c>
   114be:	2301      	movs	r3, #1
   114c0:	f3ef 8010 	mrs	r0, PRIMASK
   114c4:	f383 8810 	msr	PRIMASK, r3
        }
        else
        {
            atomic
            {
                if (tx_buf == NULL)
   114c8:	6811      	ldr	r1, [r2, #0]
   114ca:	4b18      	ldr	r3, [pc, #96]	; (1152c <USART1_Handler+0x134>)
   114cc:	4a10      	ldr	r2, [pc, #64]	; (11510 <USART1_Handler+0x118>)
   114ce:	b939      	cbnz	r1, 114e0 <USART1_Handler+0xe8>
   114d0:	69d4      	ldr	r4, [r2, #28]
   114d2:	f361 0408 	bfi	r4, r1, #0, #9
   114d6:	61d4      	str	r4, [r2, #28]
                {
                    call usart.sendData(0);
                    tx_ptr++;
   114d8:	881a      	ldrh	r2, [r3, #0]
   114da:	3201      	adds	r2, #1
   114dc:	801a      	strh	r2, [r3, #0]
   114de:	e007      	b.n	114f0 <USART1_Handler+0xf8>
                }
                else
                {
                    call usart.sendData(tx_buf[tx_ptr]);
   114e0:	881c      	ldrh	r4, [r3, #0]
   114e2:	5d0d      	ldrb	r5, [r1, r4]
   114e4:	69d1      	ldr	r1, [r2, #28]
                    tx_ptr++;
   114e6:	3401      	adds	r4, #1
   114e8:	f365 0108 	bfi	r1, r5, #0, #9
   114ec:	61d1      	str	r1, [r2, #28]
   114ee:	801c      	strh	r4, [r3, #0]
                }
                if (tx_ptr == tx_len)
   114f0:	881a      	ldrh	r2, [r3, #0]
   114f2:	4b0c      	ldr	r3, [pc, #48]	; (11524 <USART1_Handler+0x12c>)
   114f4:	881b      	ldrh	r3, [r3, #0]
   114f6:	429a      	cmp	r2, r3
   114f8:	d104      	bne.n	11504 <USART1_Handler+0x10c>
   114fa:	4a05      	ldr	r2, [pc, #20]	; (11510 <USART1_Handler+0x118>)
   114fc:	68d3      	ldr	r3, [r2, #12]
   114fe:	f043 0302 	orr.w	r3, r3, #2
   11502:	60d3      	str	r3, [r2, #12]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   11504:	f380 8810 	msr	PRIMASK, r0
   11508:	bd70      	pop	{r4, r5, r6, pc}
   1150a:	bf00      	nop
   1150c:	000107e5 	.word	0x000107e5
   11510:	40028000 	.word	0x40028000
   11514:	2000000c 	.word	0x2000000c
   11518:	20000004 	.word	0x20000004
   1151c:	20000046 	.word	0x20000046
   11520:	20000056 	.word	0x20000056
   11524:	20000060 	.word	0x20000060
   11528:	2000003c 	.word	0x2000003c
   1152c:	20000054 	.word	0x20000054

00011530 <USART2_Handler>:
        }
        call IRQWrapper.postamble();
    }

    void USART2_Handler() @C() @spontaneous()
    {
   11530:	b570      	push	{r4, r5, r6, lr}
   11532:	4b4b      	ldr	r3, [pc, #300]	; (11660 <USART2_Handler+0x130>)
   11534:	4798      	blx	r3
	{
	    return USART->csr.bits.txrdy == 1;
	}
	async command bool usart.isRXRdy()
	{
	    return USART->csr.bits.rxrdy == 1;
   11536:	4b4b      	ldr	r3, [pc, #300]	; (11664 <USART2_Handler+0x134>)
   11538:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart2.isRXRdy() && call usart2irq.isRXRdyIRQEnabled())
   1153a:	07d6      	lsls	r6, r2, #31
   1153c:	d53b      	bpl.n	115b6 <USART2_Handler+0x86>
	{
	    USART2->idr.bits.rxrdy = 1;
	}
	async command bool usart2irq.isRXRdyIRQEnabled()
	{
	    return USART2->imr.bits.rxrdy == 1;
   1153e:	691a      	ldr	r2, [r3, #16]
    }

    void USART2_Handler() @C() @spontaneous()
    {
        call IRQWrapper.preamble();
        if (call usart2.isRXRdy() && call usart2irq.isRXRdyIRQEnabled())
   11540:	07d5      	lsls	r5, r2, #31
   11542:	d538      	bpl.n	115b6 <USART2_Handler+0x86>
		USART->mr.bits.clko = 1;
		USART->ttgr = 4;
	}
	async command uint8_t usart.readData()
	{
		return USART->rhr.bits.rxchr;
   11544:	6998      	ldr	r0, [r3, #24]
    }

    async event void usart_irq.RXRdyFired()
    {
        uint8_t data = call usart.readData();
        if (!irqmode_spi)
   11546:	4b48      	ldr	r3, [pc, #288]	; (11668 <USART2_Handler+0x138>)
   11548:	7819      	ldrb	r1, [r3, #0]
   1154a:	4b48      	ldr	r3, [pc, #288]	; (1166c <USART2_Handler+0x13c>)
   1154c:	b2c0      	uxtb	r0, r0
   1154e:	b971      	cbnz	r1, 1156e <USART2_Handler+0x3e>
        {
            if (forwardRXIRQ)
            {
                signal UartStream.receivedByte(data);
            }
            if (rx_buf != NULL)
   11550:	681d      	ldr	r5, [r3, #0]
   11552:	2d00      	cmp	r5, #0
   11554:	d02f      	beq.n	115b6 <USART2_Handler+0x86>
            {
                rx_buf[rx_ptr++] = data;
   11556:	4a46      	ldr	r2, [pc, #280]	; (11670 <USART2_Handler+0x140>)
   11558:	8814      	ldrh	r4, [r2, #0]
   1155a:	1c66      	adds	r6, r4, #1
   1155c:	8016      	strh	r6, [r2, #0]
   1155e:	5528      	strb	r0, [r5, r4]
                if (rx_ptr == rx_len)
   11560:	8810      	ldrh	r0, [r2, #0]
   11562:	4a44      	ldr	r2, [pc, #272]	; (11674 <USART2_Handler+0x144>)
   11564:	8812      	ldrh	r2, [r2, #0]
   11566:	4290      	cmp	r0, r2
   11568:	d125      	bne.n	115b6 <USART2_Handler+0x86>
                {
                    uint8_t *bufcpy = rx_buf;
                    rx_buf = NULL;
   1156a:	6019      	str	r1, [r3, #0]
   1156c:	e023      	b.n	115b6 <USART2_Handler+0x86>
                }
            }
        }
        else
        {
            if (rx_buf != NULL) rx_buf[rx_ptr] = data;
   1156e:	6819      	ldr	r1, [r3, #0]
   11570:	4a3f      	ldr	r2, [pc, #252]	; (11670 <USART2_Handler+0x140>)
   11572:	b109      	cbz	r1, 11578 <USART2_Handler+0x48>
   11574:	8814      	ldrh	r4, [r2, #0]
   11576:	5508      	strb	r0, [r1, r4]
            rx_ptr++;
   11578:	8811      	ldrh	r1, [r2, #0]
   1157a:	3101      	adds	r1, #1
   1157c:	b289      	uxth	r1, r1
   1157e:	8011      	strh	r1, [r2, #0]
            if (rx_ptr == tx_len)
   11580:	4a3d      	ldr	r2, [pc, #244]	; (11678 <USART2_Handler+0x148>)
   11582:	8812      	ldrh	r2, [r2, #0]
   11584:	428a      	cmp	r2, r1
   11586:	d116      	bne.n	115b6 <USART2_Handler+0x86>
            {
                uint8_t *txbufcpy = tx_buf;
                uint8_t *rxbufcpy = rx_buf;
                rx_buf = NULL;
   11588:	2000      	movs	r0, #0
            if (rx_buf != NULL) rx_buf[rx_ptr] = data;
            rx_ptr++;
            if (rx_ptr == tx_len)
            {
                uint8_t *txbufcpy = tx_buf;
                uint8_t *rxbufcpy = rx_buf;
   1158a:	6819      	ldr	r1, [r3, #0]
                rx_buf = NULL;
   1158c:	6018      	str	r0, [r3, #0]
                tx_buf = NULL;
   1158e:	4b3b      	ldr	r3, [pc, #236]	; (1167c <USART2_Handler+0x14c>)
        enableUSART2IRQ();
	    USART2->ier.bits.rxrdy = 1;
	}
	async command void usart2irq.disableRXRdyIRQ()
	{
	    USART2->idr.bits.rxrdy = 1;
   11590:	4a34      	ldr	r2, [pc, #208]	; (11664 <USART2_Handler+0x134>)
   11592:	6018      	str	r0, [r3, #0]
   11594:	68d3      	ldr	r3, [r2, #12]
   11596:	f043 0301 	orr.w	r3, r3, #1
   1159a:	60d3      	str	r3, [r2, #12]
        return (PORT->pvr & MASK) != 0;
	}

	async command void IO.set()
	{
        PORT->ovrs = MASK;
   1159c:	4b38      	ldr	r3, [pc, #224]	; (11680 <USART2_Handler+0x150>)
   1159e:	2280      	movs	r2, #128	; 0x80
   115a0:	655a      	str	r2, [r3, #84]	; 0x54

  async event void SpiPacket.sendDone(uint8_t* txBuf, uint8_t* rxBuf,
                                      uint16_t len, error_t error) {
    call CS.set();
    if (error == SUCCESS) {
      if (rxBuf[0] & 0x1) { // Odd opcode for notifications
   115a2:	780b      	ldrb	r3, [r1, #0]
   115a4:	07dc      	lsls	r4, r3, #31
   115a6:	d506      	bpl.n	115b6 <USART2_Handler+0x86>
        switch (rxBuf[0]) {
   115a8:	2b01      	cmp	r3, #1
   115aa:	d002      	beq.n	115b2 <USART2_Handler+0x82>
   115ac:	2b03      	cmp	r3, #3
   115ae:	d102      	bne.n	115b6 <USART2_Handler+0x86>
   * @return SUCCESS if task was successfuly
   * posted; the semantics of a non-SUCCESS return value depend on the
   * implementation of this interface (the class of task).
   */
  
  async command error_t postTask();
   115b0:	2001      	movs	r0, #1
   115b2:	4b34      	ldr	r3, [pc, #208]	; (11684 <USART2_Handler+0x154>)
   115b4:	4798      	blx	r3
	{
		USART->thr.bits.txchr = d;
	}
	async command bool usart.isTXRdy()
	{
	    return USART->csr.bits.txrdy == 1;
   115b6:	4b2b      	ldr	r3, [pc, #172]	; (11664 <USART2_Handler+0x134>)
   115b8:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart2.isRXRdy() && call usart2irq.isRXRdyIRQEnabled())
        {
            signal usart2irq.RXRdyFired();
        }
        if (call usart2.isTXRdy() && call usart2irq.isTXRdyIRQEnabled())
   115ba:	0791      	lsls	r1, r2, #30
   115bc:	d54f      	bpl.n	1165e <USART2_Handler+0x12e>
	{
	    return USART2->imr.bits.rxrdy == 1;
	}
	async command bool usart2irq.isTXRdyIRQEnabled()
	{
	    return USART2->imr.bits.txrdy == 1;
   115be:	691a      	ldr	r2, [r3, #16]
        call IRQWrapper.preamble();
        if (call usart2.isRXRdy() && call usart2irq.isRXRdyIRQEnabled())
        {
            signal usart2irq.RXRdyFired();
        }
        if (call usart2.isTXRdy() && call usart2irq.isTXRdyIRQEnabled())
   115c0:	0792      	lsls	r2, r2, #30
   115c2:	d54c      	bpl.n	1165e <USART2_Handler+0x12e>
    default async event void UartStream.receiveDone( uint8_t* buf, uint16_t len, error_t error ){}
    default async event void UartStream.receivedByte( uint8_t byte ){}

    async event void usart_irq.TXRdyFired()
    {
        if (!irqmode_spi)
   115c4:	4a28      	ldr	r2, [pc, #160]	; (11668 <USART2_Handler+0x138>)
   115c6:	7811      	ldrb	r1, [r2, #0]
   115c8:	4a2c      	ldr	r2, [pc, #176]	; (1167c <USART2_Handler+0x14c>)
   115ca:	bb19      	cbnz	r1, 11614 <USART2_Handler+0xe4>
        {
            if (tx_buf == NULL)
   115cc:	6811      	ldr	r1, [r2, #0]
   115ce:	b921      	cbnz	r1, 115da <USART2_Handler+0xaa>
        enableUSART2IRQ();
        USART2->ier.bits.txrdy = 1;
    }
	async command void usart2irq.disableTXRdyIRQ()
	{
	    USART2->idr.bits.txrdy = 1;
   115d0:	68da      	ldr	r2, [r3, #12]
   115d2:	f042 0202 	orr.w	r2, r2, #2
   115d6:	60da      	str	r2, [r3, #12]
   115d8:	bd70      	pop	{r4, r5, r6, pc}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   115da:	2301      	movs	r3, #1
   115dc:	f3ef 8010 	mrs	r0, PRIMASK
   115e0:	f383 8810 	msr	PRIMASK, r3
                return;
            }
            atomic
            {

                call usart.sendData(tx_buf[tx_ptr++]);
   115e4:	4928      	ldr	r1, [pc, #160]	; (11688 <USART2_Handler+0x158>)
   115e6:	6814      	ldr	r4, [r2, #0]
   115e8:	880b      	ldrh	r3, [r1, #0]
   115ea:	1c5a      	adds	r2, r3, #1
   115ec:	b292      	uxth	r2, r2
   115ee:	800a      	strh	r2, [r1, #0]
	{
		return USART->rhr.bits.rxchr;
	}
	async command void usart.sendData(uint8_t d)
	{
		USART->thr.bits.txchr = d;
   115f0:	5ce4      	ldrb	r4, [r4, r3]
   115f2:	4b1c      	ldr	r3, [pc, #112]	; (11664 <USART2_Handler+0x134>)
   115f4:	69d9      	ldr	r1, [r3, #28]
   115f6:	f364 0108 	bfi	r1, r4, #0, #9
   115fa:	61d9      	str	r1, [r3, #28]
                if (tx_ptr == tx_len)
   115fc:	491e      	ldr	r1, [pc, #120]	; (11678 <USART2_Handler+0x148>)
   115fe:	8809      	ldrh	r1, [r1, #0]
   11600:	4291      	cmp	r1, r2
   11602:	d12a      	bne.n	1165a <USART2_Handler+0x12a>
                {
                    uint8_t * bufcpy;
                    bufcpy = tx_buf;
                    tx_buf = NULL;
   11604:	4a1d      	ldr	r2, [pc, #116]	; (1167c <USART2_Handler+0x14c>)
   11606:	2100      	movs	r1, #0
   11608:	6011      	str	r1, [r2, #0]
   1160a:	68da      	ldr	r2, [r3, #12]
   1160c:	f042 0202 	orr.w	r2, r2, #2
   11610:	60da      	str	r2, [r3, #12]
   11612:	e022      	b.n	1165a <USART2_Handler+0x12a>
   11614:	2301      	movs	r3, #1
   11616:	f3ef 8010 	mrs	r0, PRIMASK
   1161a:	f383 8810 	msr	PRIMASK, r3
        }
        else
        {
            atomic
            {
                if (tx_buf == NULL)
   1161e:	6811      	ldr	r1, [r2, #0]
   11620:	4b19      	ldr	r3, [pc, #100]	; (11688 <USART2_Handler+0x158>)
   11622:	4a10      	ldr	r2, [pc, #64]	; (11664 <USART2_Handler+0x134>)
   11624:	b939      	cbnz	r1, 11636 <USART2_Handler+0x106>
   11626:	69d4      	ldr	r4, [r2, #28]
   11628:	f361 0408 	bfi	r4, r1, #0, #9
   1162c:	61d4      	str	r4, [r2, #28]
                {
                    call usart.sendData(0);
                    tx_ptr++;
   1162e:	881a      	ldrh	r2, [r3, #0]
   11630:	3201      	adds	r2, #1
   11632:	801a      	strh	r2, [r3, #0]
   11634:	e007      	b.n	11646 <USART2_Handler+0x116>
                }
                else
                {
                    call usart.sendData(tx_buf[tx_ptr]);
   11636:	881c      	ldrh	r4, [r3, #0]
   11638:	5d0d      	ldrb	r5, [r1, r4]
   1163a:	69d1      	ldr	r1, [r2, #28]
                    tx_ptr++;
   1163c:	3401      	adds	r4, #1
   1163e:	f365 0108 	bfi	r1, r5, #0, #9
   11642:	61d1      	str	r1, [r2, #28]
   11644:	801c      	strh	r4, [r3, #0]
                }
                if (tx_ptr == tx_len)
   11646:	881a      	ldrh	r2, [r3, #0]
   11648:	4b0b      	ldr	r3, [pc, #44]	; (11678 <USART2_Handler+0x148>)
   1164a:	881b      	ldrh	r3, [r3, #0]
   1164c:	429a      	cmp	r2, r3
   1164e:	d104      	bne.n	1165a <USART2_Handler+0x12a>
   11650:	4a04      	ldr	r2, [pc, #16]	; (11664 <USART2_Handler+0x134>)
   11652:	68d3      	ldr	r3, [r2, #12]
   11654:	f043 0302 	orr.w	r3, r3, #2
   11658:	60d3      	str	r3, [r2, #12]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   1165a:	f380 8810 	msr	PRIMASK, r0
   1165e:	bd70      	pop	{r4, r5, r6, pc}
   11660:	000107e5 	.word	0x000107e5
   11664:	4002c000 	.word	0x4002c000
   11668:	2000001c 	.word	0x2000001c
   1166c:	20000018 	.word	0x20000018
   11670:	20000052 	.word	0x20000052
   11674:	20000062 	.word	0x20000062
   11678:	20000050 	.word	0x20000050
   1167c:	20000010 	.word	0x20000010
   11680:	400e1400 	.word	0x400e1400
   11684:	00010851 	.word	0x00010851
   11688:	2000020e 	.word	0x2000020e

0001168c <USART3_Handler>:
        }
        call IRQWrapper.postamble();
    }

    void USART3_Handler() @C() @spontaneous()
    {
   1168c:	b570      	push	{r4, r5, r6, lr}
   1168e:	4b44      	ldr	r3, [pc, #272]	; (117a0 <USART3_Handler+0x114>)
   11690:	4798      	blx	r3
	{
	    return USART->csr.bits.txrdy == 1;
	}
	async command bool usart.isRXRdy()
	{
	    return USART->csr.bits.rxrdy == 1;
   11692:	4b44      	ldr	r3, [pc, #272]	; (117a4 <USART3_Handler+0x118>)
   11694:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart3.isRXRdy() && call usart3irq.isRXRdyIRQEnabled())
   11696:	07d4      	lsls	r4, r2, #31
   11698:	d52c      	bpl.n	116f4 <USART3_Handler+0x68>
	{
	    USART3->idr.bits.rxrdy = 1;
	}
	async command bool usart3irq.isRXRdyIRQEnabled()
	{
	    return USART3->imr.bits.rxrdy == 1;
   1169a:	691a      	ldr	r2, [r3, #16]
    }

    void USART3_Handler() @C() @spontaneous()
    {
        call IRQWrapper.preamble();
        if (call usart3.isRXRdy() && call usart3irq.isRXRdyIRQEnabled())
   1169c:	07d0      	lsls	r0, r2, #31
   1169e:	d529      	bpl.n	116f4 <USART3_Handler+0x68>
		USART->mr.bits.clko = 1;
		USART->ttgr = 4;
	}
	async command uint8_t usart.readData()
	{
		return USART->rhr.bits.rxchr;
   116a0:	6998      	ldr	r0, [r3, #24]
    }

    async event void usart_irq.RXRdyFired()
    {
        uint8_t data = call usart.readData();
        if (!irqmode_spi)
   116a2:	4b41      	ldr	r3, [pc, #260]	; (117a8 <USART3_Handler+0x11c>)
   116a4:	7819      	ldrb	r1, [r3, #0]
   116a6:	4b41      	ldr	r3, [pc, #260]	; (117ac <USART3_Handler+0x120>)
   116a8:	b2c0      	uxtb	r0, r0
   116aa:	b969      	cbnz	r1, 116c8 <USART3_Handler+0x3c>
        {
            if (forwardRXIRQ)
            {
                signal UartStream.receivedByte(data);
            }
            if (rx_buf != NULL)
   116ac:	681d      	ldr	r5, [r3, #0]
   116ae:	b30d      	cbz	r5, 116f4 <USART3_Handler+0x68>
            {
                rx_buf[rx_ptr++] = data;
   116b0:	4a3f      	ldr	r2, [pc, #252]	; (117b0 <USART3_Handler+0x124>)
   116b2:	8814      	ldrh	r4, [r2, #0]
   116b4:	1c66      	adds	r6, r4, #1
   116b6:	8016      	strh	r6, [r2, #0]
   116b8:	5528      	strb	r0, [r5, r4]
                if (rx_ptr == rx_len)
   116ba:	8810      	ldrh	r0, [r2, #0]
   116bc:	4a3d      	ldr	r2, [pc, #244]	; (117b4 <USART3_Handler+0x128>)
   116be:	8812      	ldrh	r2, [r2, #0]
   116c0:	4290      	cmp	r0, r2
   116c2:	d117      	bne.n	116f4 <USART3_Handler+0x68>
                {
                    uint8_t *bufcpy = rx_buf;
                    rx_buf = NULL;
   116c4:	6019      	str	r1, [r3, #0]
   116c6:	e015      	b.n	116f4 <USART3_Handler+0x68>
                }
            }
        }
        else
        {
            if (rx_buf != NULL) rx_buf[rx_ptr] = data;
   116c8:	6819      	ldr	r1, [r3, #0]
   116ca:	4a39      	ldr	r2, [pc, #228]	; (117b0 <USART3_Handler+0x124>)
   116cc:	b109      	cbz	r1, 116d2 <USART3_Handler+0x46>
   116ce:	8814      	ldrh	r4, [r2, #0]
   116d0:	5508      	strb	r0, [r1, r4]
            rx_ptr++;
   116d2:	8811      	ldrh	r1, [r2, #0]
   116d4:	3101      	adds	r1, #1
   116d6:	b289      	uxth	r1, r1
   116d8:	8011      	strh	r1, [r2, #0]
            if (rx_ptr == tx_len)
   116da:	4a37      	ldr	r2, [pc, #220]	; (117b8 <USART3_Handler+0x12c>)
   116dc:	8812      	ldrh	r2, [r2, #0]
   116de:	428a      	cmp	r2, r1
   116e0:	d108      	bne.n	116f4 <USART3_Handler+0x68>
            {
                uint8_t *txbufcpy = tx_buf;
                uint8_t *rxbufcpy = rx_buf;
                rx_buf = NULL;
   116e2:	2200      	movs	r2, #0
   116e4:	601a      	str	r2, [r3, #0]
                tx_buf = NULL;
   116e6:	4b35      	ldr	r3, [pc, #212]	; (117bc <USART3_Handler+0x130>)
   116e8:	601a      	str	r2, [r3, #0]
        enableUSART3IRQ();
	    USART3->ier.bits.rxrdy = 1;
	}
	async command void usart3irq.disableRXRdyIRQ()
	{
	    USART3->idr.bits.rxrdy = 1;
   116ea:	4a2e      	ldr	r2, [pc, #184]	; (117a4 <USART3_Handler+0x118>)
   116ec:	68d3      	ldr	r3, [r2, #12]
   116ee:	f043 0301 	orr.w	r3, r3, #1
   116f2:	60d3      	str	r3, [r2, #12]
	{
		USART->thr.bits.txchr = d;
	}
	async command bool usart.isTXRdy()
	{
	    return USART->csr.bits.txrdy == 1;
   116f4:	4b2b      	ldr	r3, [pc, #172]	; (117a4 <USART3_Handler+0x118>)
   116f6:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart3.isRXRdy() && call usart3irq.isRXRdyIRQEnabled())
        {
            signal usart3irq.RXRdyFired();
        }
        if (call usart3.isTXRdy() && call usart3irq.isTXRdyIRQEnabled())
   116f8:	0791      	lsls	r1, r2, #30
   116fa:	d54f      	bpl.n	1179c <USART3_Handler+0x110>
	{
	    return USART3->imr.bits.rxrdy == 1;
	}
	async command bool usart3irq.isTXRdyIRQEnabled()
	{
	    return USART3->imr.bits.txrdy == 1;
   116fc:	691a      	ldr	r2, [r3, #16]
        call IRQWrapper.preamble();
        if (call usart3.isRXRdy() && call usart3irq.isRXRdyIRQEnabled())
        {
            signal usart3irq.RXRdyFired();
        }
        if (call usart3.isTXRdy() && call usart3irq.isTXRdyIRQEnabled())
   116fe:	0792      	lsls	r2, r2, #30
   11700:	d54c      	bpl.n	1179c <USART3_Handler+0x110>
    default async event void UartStream.receiveDone( uint8_t* buf, uint16_t len, error_t error ){}
    default async event void UartStream.receivedByte( uint8_t byte ){}

    async event void usart_irq.TXRdyFired()
    {
        if (!irqmode_spi)
   11702:	4a29      	ldr	r2, [pc, #164]	; (117a8 <USART3_Handler+0x11c>)
   11704:	7811      	ldrb	r1, [r2, #0]
   11706:	4a2d      	ldr	r2, [pc, #180]	; (117bc <USART3_Handler+0x130>)
   11708:	bb19      	cbnz	r1, 11752 <USART3_Handler+0xc6>
        {
            if (tx_buf == NULL)
   1170a:	6811      	ldr	r1, [r2, #0]
   1170c:	b921      	cbnz	r1, 11718 <USART3_Handler+0x8c>
        enableUSART3IRQ();
        USART3->ier.bits.txrdy = 1;
    }
	async command void usart3irq.disableTXRdyIRQ()
	{
	    USART3->idr.bits.txrdy = 1;
   1170e:	68da      	ldr	r2, [r3, #12]
   11710:	f042 0202 	orr.w	r2, r2, #2
   11714:	60da      	str	r2, [r3, #12]
   11716:	bd70      	pop	{r4, r5, r6, pc}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   11718:	2301      	movs	r3, #1
   1171a:	f3ef 8010 	mrs	r0, PRIMASK
   1171e:	f383 8810 	msr	PRIMASK, r3
                return;
            }
            atomic
            {

                call usart.sendData(tx_buf[tx_ptr++]);
   11722:	4927      	ldr	r1, [pc, #156]	; (117c0 <USART3_Handler+0x134>)
   11724:	6814      	ldr	r4, [r2, #0]
   11726:	880b      	ldrh	r3, [r1, #0]
   11728:	1c5a      	adds	r2, r3, #1
   1172a:	b292      	uxth	r2, r2
   1172c:	800a      	strh	r2, [r1, #0]
	{
		return USART->rhr.bits.rxchr;
	}
	async command void usart.sendData(uint8_t d)
	{
		USART->thr.bits.txchr = d;
   1172e:	5ce4      	ldrb	r4, [r4, r3]
   11730:	4b1c      	ldr	r3, [pc, #112]	; (117a4 <USART3_Handler+0x118>)
   11732:	69d9      	ldr	r1, [r3, #28]
   11734:	f364 0108 	bfi	r1, r4, #0, #9
   11738:	61d9      	str	r1, [r3, #28]
                if (tx_ptr == tx_len)
   1173a:	491f      	ldr	r1, [pc, #124]	; (117b8 <USART3_Handler+0x12c>)
   1173c:	8809      	ldrh	r1, [r1, #0]
   1173e:	4291      	cmp	r1, r2
   11740:	d12a      	bne.n	11798 <USART3_Handler+0x10c>
                {
                    uint8_t * bufcpy;
                    bufcpy = tx_buf;
                    tx_buf = NULL;
   11742:	4a1e      	ldr	r2, [pc, #120]	; (117bc <USART3_Handler+0x130>)
   11744:	2100      	movs	r1, #0
   11746:	6011      	str	r1, [r2, #0]
   11748:	68da      	ldr	r2, [r3, #12]
   1174a:	f042 0202 	orr.w	r2, r2, #2
   1174e:	60da      	str	r2, [r3, #12]
   11750:	e022      	b.n	11798 <USART3_Handler+0x10c>
   11752:	2301      	movs	r3, #1
   11754:	f3ef 8010 	mrs	r0, PRIMASK
   11758:	f383 8810 	msr	PRIMASK, r3
        }
        else
        {
            atomic
            {
                if (tx_buf == NULL)
   1175c:	6811      	ldr	r1, [r2, #0]
   1175e:	4b18      	ldr	r3, [pc, #96]	; (117c0 <USART3_Handler+0x134>)
   11760:	4a10      	ldr	r2, [pc, #64]	; (117a4 <USART3_Handler+0x118>)
   11762:	b939      	cbnz	r1, 11774 <USART3_Handler+0xe8>
   11764:	69d4      	ldr	r4, [r2, #28]
   11766:	f361 0408 	bfi	r4, r1, #0, #9
   1176a:	61d4      	str	r4, [r2, #28]
                {
                    call usart.sendData(0);
                    tx_ptr++;
   1176c:	881a      	ldrh	r2, [r3, #0]
   1176e:	3201      	adds	r2, #1
   11770:	801a      	strh	r2, [r3, #0]
   11772:	e007      	b.n	11784 <USART3_Handler+0xf8>
                }
                else
                {
                    call usart.sendData(tx_buf[tx_ptr]);
   11774:	881c      	ldrh	r4, [r3, #0]
   11776:	5d0d      	ldrb	r5, [r1, r4]
   11778:	69d1      	ldr	r1, [r2, #28]
                    tx_ptr++;
   1177a:	3401      	adds	r4, #1
   1177c:	f365 0108 	bfi	r1, r5, #0, #9
   11780:	61d1      	str	r1, [r2, #28]
   11782:	801c      	strh	r4, [r3, #0]
                }
                if (tx_ptr == tx_len)
   11784:	881a      	ldrh	r2, [r3, #0]
   11786:	4b0c      	ldr	r3, [pc, #48]	; (117b8 <USART3_Handler+0x12c>)
   11788:	881b      	ldrh	r3, [r3, #0]
   1178a:	429a      	cmp	r2, r3
   1178c:	d104      	bne.n	11798 <USART3_Handler+0x10c>
   1178e:	4a05      	ldr	r2, [pc, #20]	; (117a4 <USART3_Handler+0x118>)
   11790:	68d3      	ldr	r3, [r2, #12]
   11792:	f043 0302 	orr.w	r3, r3, #2
   11796:	60d3      	str	r3, [r2, #12]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   11798:	f380 8810 	msr	PRIMASK, r0
   1179c:	bd70      	pop	{r4, r5, r6, pc}
   1179e:	bf00      	nop
   117a0:	000107e5 	.word	0x000107e5
   117a4:	40030000 	.word	0x40030000
   117a8:	2000001d 	.word	0x2000001d
   117ac:	20000030 	.word	0x20000030
   117b0:	20000108 	.word	0x20000108
   117b4:	20000042 	.word	0x20000042
   117b8:	20000058 	.word	0x20000058
   117bc:	2000002c 	.word	0x2000002c
   117c0:	2000010c 	.word	0x2000010c

000117c4 <storm_vsnprintf>:
        *(pbuffer) = '\0';
        return 1;
    }

    int storm_vsnprintf(char *buffer, unsigned int buffer_len, const char *fmt, va_list va) @C() @spontaneous()
    {
   117c4:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   117c8:	4607      	mov	r7, r0
   117ca:	b088      	sub	sp, #32
   117cc:	4688      	mov	r8, r1
   117ce:	4616      	mov	r6, r2
        char *pbuffer = buffer;
   117d0:	4604      	mov	r4, r0
        char bf[24];
        char ch;

        while ((ch=*(fmt++))) {
   117d2:	7832      	ldrb	r2, [r6, #0]
   117d4:	1be0      	subs	r0, r4, r7
   117d6:	2a00      	cmp	r2, #0
   117d8:	f000 809c 	beq.w	11914 <storm_vsnprintf+0x150>
            if ((unsigned int)((pbuffer - buffer) + 1) >= buffer_len)
   117dc:	1c41      	adds	r1, r0, #1
   117de:	4541      	cmp	r1, r8
   117e0:	f080 8098 	bcs.w	11914 <storm_vsnprintf+0x150>
                break;
            if (ch!='%')
   117e4:	2a25      	cmp	r2, #37	; 0x25
   117e6:	d004      	beq.n	117f2 <storm_vsnprintf+0x2e>
            {
                if (!((unsigned int)((pbuffer - buffer) + 1) >= buffer_len))
                {
                    *(pbuffer++) = ch;
   117e8:	7022      	strb	r2, [r4, #0]
                    *(pbuffer) = '\0';
   117ea:	2200      	movs	r2, #0
    {
        char *pbuffer = buffer;
        char bf[24];
        char ch;

        while ((ch=*(fmt++))) {
   117ec:	3601      	adds	r6, #1
            if (ch!='%')
            {
                if (!((unsigned int)((pbuffer - buffer) + 1) >= buffer_len))
                {
                    *(pbuffer++) = ch;
                    *(pbuffer) = '\0';
   117ee:	7062      	strb	r2, [r4, #1]
   117f0:	e08e      	b.n	11910 <storm_vsnprintf+0x14c>
            else {
                char zero_pad = 0;
                char *ptr;
                unsigned int len;

                ch=*(fmt++);
   117f2:	7875      	ldrb	r5, [r6, #1]

                /* Zero padding requested */
                if (ch=='0') {
   117f4:	2d30      	cmp	r5, #48	; 0x30
   117f6:	d002      	beq.n	117fe <storm_vsnprintf+0x3a>
            else {
                char zero_pad = 0;
                char *ptr;
                unsigned int len;

                ch=*(fmt++);
   117f8:	3602      	adds	r6, #2
                    *(pbuffer++) = ch;
                    *(pbuffer) = '\0';
                }
            }
            else {
                char zero_pad = 0;
   117fa:	2200      	movs	r2, #0
   117fc:	e00a      	b.n	11814 <storm_vsnprintf+0x50>

                ch=*(fmt++);

                /* Zero padding requested */
                if (ch=='0') {
                    ch=*(fmt++);
   117fe:	78b2      	ldrb	r2, [r6, #2]
                    if (ch == '\0')
   11800:	2a00      	cmp	r2, #0
   11802:	f000 8087 	beq.w	11914 <storm_vsnprintf+0x150>
                        goto end;
                    if (ch >= '0' && ch <= '9')
   11806:	3a30      	subs	r2, #48	; 0x30
   11808:	b2d2      	uxtb	r2, r2
                        zero_pad = ch - '0';
                    ch=*(fmt++);
   1180a:	78f5      	ldrb	r5, [r6, #3]
                    *(pbuffer++) = ch;
                    *(pbuffer) = '\0';
                }
            }
            else {
                char zero_pad = 0;
   1180c:	2a09      	cmp	r2, #9
   1180e:	bf88      	it	hi
   11810:	2200      	movhi	r2, #0
                    ch=*(fmt++);
                    if (ch == '\0')
                        goto end;
                    if (ch >= '0' && ch <= '9')
                        zero_pad = ch - '0';
                    ch=*(fmt++);
   11812:	3604      	adds	r6, #4
                }

                switch (ch) {
   11814:	2d64      	cmp	r5, #100	; 0x64
   11816:	d015      	beq.n	11844 <storm_vsnprintf+0x80>
   11818:	d807      	bhi.n	1182a <storm_vsnprintf+0x66>
   1181a:	2d50      	cmp	r5, #80	; 0x50
   1181c:	d030      	beq.n	11880 <storm_vsnprintf+0xbc>
   1181e:	d802      	bhi.n	11826 <storm_vsnprintf+0x62>
   11820:	2d00      	cmp	r5, #0
   11822:	d077      	beq.n	11914 <storm_vsnprintf+0x150>
   11824:	e06f      	b.n	11906 <storm_vsnprintf+0x142>
   11826:	2d58      	cmp	r5, #88	; 0x58
   11828:	e00a      	b.n	11840 <storm_vsnprintf+0x7c>
   1182a:	2d73      	cmp	r5, #115	; 0x73
   1182c:	d051      	beq.n	118d2 <storm_vsnprintf+0x10e>
   1182e:	d804      	bhi.n	1183a <storm_vsnprintf+0x76>
   11830:	2d69      	cmp	r5, #105	; 0x69
   11832:	d007      	beq.n	11844 <storm_vsnprintf+0x80>
   11834:	2d70      	cmp	r5, #112	; 0x70
   11836:	d023      	beq.n	11880 <storm_vsnprintf+0xbc>
   11838:	e065      	b.n	11906 <storm_vsnprintf+0x142>
   1183a:	2d75      	cmp	r5, #117	; 0x75
   1183c:	d002      	beq.n	11844 <storm_vsnprintf+0x80>
   1183e:	2d78      	cmp	r5, #120	; 0x78
   11840:	d161      	bne.n	11906 <storm_vsnprintf+0x142>
   11842:	e025      	b.n	11890 <storm_vsnprintf+0xcc>
                        goto end;

                    case 'u':
                    case 'd':
                    case 'i':
                         len = mini_itoa(va_arg(va, unsigned int), 10, 0, bf, zero_pad);
   11844:	9200      	str	r2, [sp, #0]
   11846:	ad02      	add	r5, sp, #8
   11848:	6818      	ldr	r0, [r3, #0]
   1184a:	f8df c0d0 	ldr.w	ip, [pc, #208]	; 1191c <storm_vsnprintf+0x158>
   1184e:	2200      	movs	r2, #0
   11850:	f103 0904 	add.w	r9, r3, #4
   11854:	210a      	movs	r1, #10
   11856:	462b      	mov	r3, r5
   11858:	47e0      	blx	ip
                         {
                            unsigned int i;

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
   1185a:	1b3a      	subs	r2, r7, r4
   1185c:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   11860:	4413      	add	r3, r2
   11862:	4298      	cmp	r0, r3
   11864:	bf28      	it	cs
   11866:	4618      	movcs	r0, r3
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   11868:	2200      	movs	r2, #0
   1186a:	4282      	cmp	r2, r0
   1186c:	d003      	beq.n	11876 <storm_vsnprintf+0xb2>
                                *(pbuffer++) = bf[i];
   1186e:	5ca9      	ldrb	r1, [r5, r2]
   11870:	54a1      	strb	r1, [r4, r2]

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   11872:	3201      	adds	r2, #1
   11874:	e7f9      	b.n	1186a <storm_vsnprintf+0xa6>
   11876:	4414      	add	r4, r2
                                *(pbuffer++) = bf[i];
                            *(pbuffer) = '\0';
   11878:	2300      	movs	r3, #0
   1187a:	7023      	strb	r3, [r4, #0]
                        goto end;

                    case 'u':
                    case 'd':
                    case 'i':
                         len = mini_itoa(va_arg(va, unsigned int), 10, 0, bf, zero_pad);
   1187c:	464b      	mov	r3, r9
                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
                                *(pbuffer++) = bf[i];
                            *(pbuffer) = '\0';
                        }
                        break;
   1187e:	e7a8      	b.n	117d2 <storm_vsnprintf+0xe>
                    case 'p':
                    case 'P':
                        *(pbuffer++) = '0';
   11880:	4622      	mov	r2, r4
   11882:	2130      	movs	r1, #48	; 0x30
   11884:	f802 1b02 	strb.w	r1, [r2], #2
                        *(pbuffer++) = 'x';
   11888:	2178      	movs	r1, #120	; 0x78
   1188a:	7061      	strb	r1, [r4, #1]
   1188c:	4614      	mov	r4, r2
                        zero_pad = 8;
   1188e:	2208      	movs	r2, #8
   11890:	3d58      	subs	r5, #88	; 0x58
                    case 'x':
                    case 'X':
                        len = mini_itoa(va_arg(va, unsigned int), 16, (ch=='X'), bf, zero_pad);
   11892:	9200      	str	r2, [sp, #0]
   11894:	f10d 0908 	add.w	r9, sp, #8
   11898:	426a      	negs	r2, r5
   1189a:	416a      	adcs	r2, r5
   1189c:	6818      	ldr	r0, [r3, #0]
   1189e:	4d1f      	ldr	r5, [pc, #124]	; (1191c <storm_vsnprintf+0x158>)
   118a0:	f103 0a04 	add.w	sl, r3, #4
   118a4:	2110      	movs	r1, #16
   118a6:	464b      	mov	r3, r9
   118a8:	47a8      	blx	r5
                        {
                            unsigned int i;

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
   118aa:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   118ae:	1b3a      	subs	r2, r7, r4
   118b0:	4413      	add	r3, r2
   118b2:	4283      	cmp	r3, r0
   118b4:	bf38      	it	cc
   118b6:	4618      	movcc	r0, r3
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   118b8:	2300      	movs	r3, #0
   118ba:	4283      	cmp	r3, r0
   118bc:	d004      	beq.n	118c8 <storm_vsnprintf+0x104>
                                *(pbuffer++) = bf[i];
   118be:	f819 2003 	ldrb.w	r2, [r9, r3]
   118c2:	54e2      	strb	r2, [r4, r3]

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   118c4:	3301      	adds	r3, #1
   118c6:	e7f8      	b.n	118ba <storm_vsnprintf+0xf6>
   118c8:	441c      	add	r4, r3
                                *(pbuffer++) = bf[i];
                            *(pbuffer) = '\0';
   118ca:	2300      	movs	r3, #0
   118cc:	7023      	strb	r3, [r4, #0]
                        *(pbuffer++) = '0';
                        *(pbuffer++) = 'x';
                        zero_pad = 8;
                    case 'x':
                    case 'X':
                        len = mini_itoa(va_arg(va, unsigned int), 16, (ch=='X'), bf, zero_pad);
   118ce:	4653      	mov	r3, sl
                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
                                *(pbuffer++) = bf[i];
                            *(pbuffer) = '\0';
                        }
                        break;
   118d0:	e77f      	b.n	117d2 <storm_vsnprintf+0xe>
                            }
                        }
                        break;

                    case 's' :
                        ptr = va_arg(va, char*);
   118d2:	6819      	ldr	r1, [r3, #0]
   118d4:	1d18      	adds	r0, r3, #4
    #include <string.h>
    #include <stdarg.h>

    unsigned int mini_strlen(const char *s)
    {
        unsigned int len = 0;
   118d6:	2200      	movs	r2, #0
        while (s[len] != '\0') len++;
   118d8:	5c8b      	ldrb	r3, [r1, r2]
   118da:	b10b      	cbz	r3, 118e0 <storm_vsnprintf+0x11c>
   118dc:	3201      	adds	r2, #1
   118de:	e7fb      	b.n	118d8 <storm_vsnprintf+0x114>
                        ptr = va_arg(va, char*);
                        {
                            unsigned int i, len;
                            len = mini_strlen(ptr);

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
   118e0:	f108 35ff 	add.w	r5, r8, #4294967295	; 0xffffffff
   118e4:	ebc4 0c07 	rsb	ip, r4, r7
   118e8:	4465      	add	r5, ip
   118ea:	42aa      	cmp	r2, r5
   118ec:	bf28      	it	cs
   118ee:	462a      	movcs	r2, r5
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   118f0:	4293      	cmp	r3, r2
   118f2:	d003      	beq.n	118fc <storm_vsnprintf+0x138>
                                *(pbuffer++) = ptr[i];
   118f4:	5ccd      	ldrb	r5, [r1, r3]
   118f6:	54e5      	strb	r5, [r4, r3]

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   118f8:	3301      	adds	r3, #1
   118fa:	e7f9      	b.n	118f0 <storm_vsnprintf+0x12c>
   118fc:	441c      	add	r4, r3
                                *(pbuffer++) = ptr[i];
                            *(pbuffer) = '\0';
   118fe:	2300      	movs	r3, #0
   11900:	7023      	strb	r3, [r4, #0]
                            }
                        }
                        break;

                    case 's' :
                        ptr = va_arg(va, char*);
   11902:	4603      	mov	r3, r0
                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
                                *(pbuffer++) = ptr[i];
                            *(pbuffer) = '\0';
                        }
                        break;
   11904:	e765      	b.n	117d2 <storm_vsnprintf+0xe>

                    default:
                        {
                            if (!((unsigned int)((pbuffer - buffer) + 1) >= buffer_len))
                            {
                                *(pbuffer++) = (char)(va_arg(va, int));
   11906:	681a      	ldr	r2, [r3, #0]
   11908:	7022      	strb	r2, [r4, #0]
                                *(pbuffer) = '\0';
   1190a:	2200      	movs	r2, #0
   1190c:	7062      	strb	r2, [r4, #1]

                    default:
                        {
                            if (!((unsigned int)((pbuffer - buffer) + 1) >= buffer_len))
                            {
                                *(pbuffer++) = (char)(va_arg(va, int));
   1190e:	3304      	adds	r3, #4
   11910:	3401      	adds	r4, #1
   11912:	e75e      	b.n	117d2 <storm_vsnprintf+0xe>
                }
            }
        }
    end:
        return pbuffer - buffer;
    }
   11914:	b008      	add	sp, #32
   11916:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   1191a:	bf00      	nop
   1191c:	00010ad1 	.word	0x00010ad1

00011920 <storm_snprintf>:


    int storm_snprintf(char* buffer, unsigned int buffer_len, const char *fmt, ...) @C() @spontaneous()
    {
   11920:	b40c      	push	{r2, r3}
   11922:	b513      	push	{r0, r1, r4, lr}
   11924:	ab04      	add	r3, sp, #16
        int ret;
        va_list va;
        va_start(va, fmt);
        ret = storm_vsnprintf(buffer, buffer_len, fmt, va);
   11926:	4c05      	ldr	r4, [pc, #20]	; (1193c <storm_snprintf+0x1c>)
        return pbuffer - buffer;
    }


    int storm_snprintf(char* buffer, unsigned int buffer_len, const char *fmt, ...) @C() @spontaneous()
    {
   11928:	f853 2b04 	ldr.w	r2, [r3], #4
        int ret;
        va_list va;
        va_start(va, fmt);
   1192c:	9301      	str	r3, [sp, #4]
        ret = storm_vsnprintf(buffer, buffer_len, fmt, va);
   1192e:	47a0      	blx	r4
        va_end(va);

        return ret;
    }
   11930:	b002      	add	sp, #8
   11932:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   11936:	b002      	add	sp, #8
   11938:	4770      	bx	lr
   1193a:	bf00      	nop
   1193c:	000117c5 	.word	0x000117c5

00011940 <storm_printf>:

    uint8_t storm_printf_buffer [256];

    int storm_printf(const char* fmt, ...) @C() @spontaneous()
    {
   11940:	b40f      	push	{r0, r1, r2, r3}
   11942:	b513      	push	{r0, r1, r4, lr}
   11944:	ab04      	add	r3, sp, #16
        int ret;
        uint32_t i;
        va_list va;
        va_start(va, fmt);
        ret = storm_vsnprintf(storm_printf_buffer, 256, fmt, va);
   11946:	480e      	ldr	r0, [pc, #56]	; (11980 <storm_printf+0x40>)
    }

    uint8_t storm_printf_buffer [256];

    int storm_printf(const char* fmt, ...) @C() @spontaneous()
    {
   11948:	f853 2b04 	ldr.w	r2, [r3], #4
        int ret;
        uint32_t i;
        va_list va;
        va_start(va, fmt);
        ret = storm_vsnprintf(storm_printf_buffer, 256, fmt, va);
   1194c:	4c0d      	ldr	r4, [pc, #52]	; (11984 <storm_printf+0x44>)
    int storm_printf(const char* fmt, ...) @C() @spontaneous()
    {
        int ret;
        uint32_t i;
        va_list va;
        va_start(va, fmt);
   1194e:	9301      	str	r3, [sp, #4]
        ret = storm_vsnprintf(storm_printf_buffer, 256, fmt, va);
   11950:	f44f 7180 	mov.w	r1, #256	; 0x100
   11954:	47a0      	blx	r4
        va_end(va);

        for (i=0;i<ret;i++)
   11956:	2300      	movs	r3, #0
   11958:	4283      	cmp	r3, r0
   1195a:	d00b      	beq.n	11974 <storm_printf+0x34>
        {
            call UartByte.send(storm_printf_buffer[i]);
   1195c:	4a08      	ldr	r2, [pc, #32]	; (11980 <storm_printf+0x40>)
   1195e:	5c9c      	ldrb	r4, [r3, r2]
	}
	async command bool usart.isTXRdy()
	{
	    return USART->csr.bits.txrdy == 1;
   11960:	4a09      	ldr	r2, [pc, #36]	; (11988 <storm_printf+0x48>)
   11962:	6951      	ldr	r1, [r2, #20]
    * @param byte The byte to send.
    * @return SUCCESS if byte was sent, FAIL otherwise.
    */
    async command error_t UartByte.send( uint8_t byte )
    {
        while (! call usart.isTXRdy());
   11964:	0789      	lsls	r1, r1, #30
   11966:	d5fb      	bpl.n	11960 <storm_printf+0x20>
	{
		return USART->rhr.bits.rxchr;
	}
	async command void usart.sendData(uint8_t d)
	{
		USART->thr.bits.txchr = d;
   11968:	69d1      	ldr	r1, [r2, #28]
   1196a:	f364 0108 	bfi	r1, r4, #0, #9
   1196e:	61d1      	str	r1, [r2, #28]
        va_list va;
        va_start(va, fmt);
        ret = storm_vsnprintf(storm_printf_buffer, 256, fmt, va);
        va_end(va);

        for (i=0;i<ret;i++)
   11970:	3301      	adds	r3, #1
   11972:	e7f1      	b.n	11958 <storm_printf+0x18>
        {
            call UartByte.send(storm_printf_buffer[i]);
        }

        return ret;
    }
   11974:	4618      	mov	r0, r3
   11976:	b002      	add	sp, #8
   11978:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1197c:	b004      	add	sp, #16
   1197e:	4770      	bx	lr
   11980:	2000010e 	.word	0x2000010e
   11984:	000117c5 	.word	0x000117c5
   11988:	40030000 	.word	0x40030000

0001198c <storm_trace>:
    static uint8_t volatile * const stim1_8 = ((volatile uint8_t*)     0xE0000004);

    //These functions write to the ITM, so are much faster than printf, for
    //hotpath debugging
    void storm_trace(const char* s) @C() @spontaneous()
    {
   1198c:	3801      	subs	r0, #1
        while(*s != 0)
   1198e:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   11992:	b133      	cbz	r3, 119a2 <storm_trace+0x16>
        {
            while( *stim0_32 == 0 );
   11994:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   11998:	6811      	ldr	r1, [r2, #0]
   1199a:	2900      	cmp	r1, #0
   1199c:	d0fa      	beq.n	11994 <storm_trace+0x8>
            *stim0_8 = *s;
   1199e:	7013      	strb	r3, [r2, #0]
   119a0:	e7f5      	b.n	1198e <storm_trace+0x2>
            s++;
        }
    }
   119a2:	4770      	bx	lr

000119a4 <storm_trace8>:
    void storm_trace8(uint8_t v) @C() @spontaneous()
    {
        while( *stim1_32 == 0 );
   119a4:	4b02      	ldr	r3, [pc, #8]	; (119b0 <storm_trace8+0xc>)
   119a6:	681a      	ldr	r2, [r3, #0]
   119a8:	2a00      	cmp	r2, #0
   119aa:	d0fb      	beq.n	119a4 <storm_trace8>
        *stim1_8 = v;
   119ac:	7018      	strb	r0, [r3, #0]
   119ae:	4770      	bx	lr
   119b0:	e0000004 	.word	0xe0000004

000119b4 <storm_trace16>:
    }
    void storm_trace16(uint16_t v) @C() @spontaneous()
    {
        while( *stim1_32 == 0 );
   119b4:	4b02      	ldr	r3, [pc, #8]	; (119c0 <storm_trace16+0xc>)
   119b6:	681a      	ldr	r2, [r3, #0]
   119b8:	2a00      	cmp	r2, #0
   119ba:	d0fb      	beq.n	119b4 <storm_trace16>
        *stim1_16 = v;
   119bc:	8018      	strh	r0, [r3, #0]
   119be:	4770      	bx	lr
   119c0:	e0000004 	.word	0xe0000004

000119c4 <storm_trace32>:
    }
    void storm_trace32(uint32_t v) @C() @spontaneous()
    {
        while( *stim1_32 == 0 );
   119c4:	4b02      	ldr	r3, [pc, #8]	; (119d0 <storm_trace32+0xc>)
   119c6:	681a      	ldr	r2, [r3, #0]
   119c8:	2a00      	cmp	r2, #0
   119ca:	d0fb      	beq.n	119c4 <storm_trace32>
        *stim1_32 = v;
   119cc:	6018      	str	r0, [r3, #0]
   119ce:	4770      	bx	lr
   119d0:	e0000004 	.word	0xe0000004

000119d4 <Dummy_Handler>:
extern uint32_t _estack;

int main(void);

void Dummy_Handler(void)
{
   119d4:	e7fe      	b.n	119d4 <Dummy_Handler>
	...

000119d8 <Reset_Handler>:
	 * linker file puts it
	 */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
   119d8:	4b10      	ldr	r3, [pc, #64]	; (11a1c <Reset_Handler+0x44>)
   119da:	4a11      	ldr	r2, [pc, #68]	; (11a20 <Reset_Handler+0x48>)
   119dc:	4293      	cmp	r3, r2
	TWIM3_Handler,        // 78
	LCDCA_Handler         // 79
};

void Reset_Handler(void)
{
   119de:	b510      	push	{r4, lr}
   119e0:	461c      	mov	r4, r3
	 * linker file puts it
	 */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
   119e2:	d001      	beq.n	119e8 <Reset_Handler+0x10>
   119e4:	2300      	movs	r3, #0
   119e6:	e001      	b.n	119ec <Reset_Handler+0x14>
   119e8:	4b0e      	ldr	r3, [pc, #56]	; (11a24 <Reset_Handler+0x4c>)
   119ea:	e007      	b.n	119fc <Reset_Handler+0x24>
		for (; pDest < &_erelocate;) {
   119ec:	490e      	ldr	r1, [pc, #56]	; (11a28 <Reset_Handler+0x50>)
   119ee:	18d0      	adds	r0, r2, r3
   119f0:	4288      	cmp	r0, r1
   119f2:	d2f9      	bcs.n	119e8 <Reset_Handler+0x10>
			*pDest++ = *pSrc++;
   119f4:	58e1      	ldr	r1, [r4, r3]
   119f6:	50d1      	str	r1, [r2, r3]
   119f8:	3304      	adds	r3, #4
   119fa:	e7f7      	b.n	119ec <Reset_Handler+0x14>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   119fc:	4a0b      	ldr	r2, [pc, #44]	; (11a2c <Reset_Handler+0x54>)
   119fe:	4293      	cmp	r3, r2
   11a00:	d203      	bcs.n	11a0a <Reset_Handler+0x32>
		*pDest++ = 0;
   11a02:	2200      	movs	r2, #0
   11a04:	f843 2b04 	str.w	r2, [r3], #4
   11a08:	e7f8      	b.n	119fc <Reset_Handler+0x24>
	/* Initialize the C library */
	//XTA
//	__libc_init_array();

    //Workaround for SB.02 hardware bug
    *((uint32_t volatile * ) 0x400E1004) = 1 << 14; //GPER
   11a0a:	4a09      	ldr	r2, [pc, #36]	; (11a30 <Reset_Handler+0x58>)
   11a0c:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   11a10:	6013      	str	r3, [r2, #0]
    *((uint32_t volatile * ) 0x400E1054) = 1 << 14; //OVR
   11a12:	6513      	str	r3, [r2, #80]	; 0x50
    *((uint32_t volatile * ) 0x400E1044) = 1 << 14; //ODER
   11a14:	6413      	str	r3, [r2, #64]	; 0x40

	/* Branch to main function */
	main();
   11a16:	4b07      	ldr	r3, [pc, #28]	; (11a34 <Reset_Handler+0x5c>)
   11a18:	4798      	blx	r3
   11a1a:	bd10      	pop	{r4, pc}
   11a1c:	00011af0 	.word	0x00011af0
   11a20:	20000000 	.word	0x20000000
   11a24:	20000004 	.word	0x20000004
   11a28:	20000004 	.word	0x20000004
   11a2c:	20000220 	.word	0x20000220
   11a30:	400e1004 	.word	0x400e1004
   11a34:	00010f61 	.word	0x00010f61

00011a38 <memset>:
   11a38:	b4f0      	push	{r4, r5, r6, r7}
   11a3a:	0784      	lsls	r4, r0, #30
   11a3c:	d043      	beq.n	11ac6 <memset+0x8e>
   11a3e:	1e54      	subs	r4, r2, #1
   11a40:	2a00      	cmp	r2, #0
   11a42:	d03e      	beq.n	11ac2 <memset+0x8a>
   11a44:	b2cd      	uxtb	r5, r1
   11a46:	4603      	mov	r3, r0
   11a48:	e003      	b.n	11a52 <memset+0x1a>
   11a4a:	1e62      	subs	r2, r4, #1
   11a4c:	2c00      	cmp	r4, #0
   11a4e:	d038      	beq.n	11ac2 <memset+0x8a>
   11a50:	4614      	mov	r4, r2
   11a52:	f803 5b01 	strb.w	r5, [r3], #1
   11a56:	079a      	lsls	r2, r3, #30
   11a58:	d1f7      	bne.n	11a4a <memset+0x12>
   11a5a:	2c03      	cmp	r4, #3
   11a5c:	d92a      	bls.n	11ab4 <memset+0x7c>
   11a5e:	b2cd      	uxtb	r5, r1
   11a60:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   11a64:	2c0f      	cmp	r4, #15
   11a66:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   11a6a:	d915      	bls.n	11a98 <memset+0x60>
   11a6c:	f1a4 0710 	sub.w	r7, r4, #16
   11a70:	093f      	lsrs	r7, r7, #4
   11a72:	f103 0610 	add.w	r6, r3, #16
   11a76:	eb06 1607 	add.w	r6, r6, r7, lsl #4
   11a7a:	461a      	mov	r2, r3
   11a7c:	6015      	str	r5, [r2, #0]
   11a7e:	6055      	str	r5, [r2, #4]
   11a80:	6095      	str	r5, [r2, #8]
   11a82:	60d5      	str	r5, [r2, #12]
   11a84:	3210      	adds	r2, #16
   11a86:	42b2      	cmp	r2, r6
   11a88:	d1f8      	bne.n	11a7c <memset+0x44>
   11a8a:	f004 040f 	and.w	r4, r4, #15
   11a8e:	3701      	adds	r7, #1
   11a90:	2c03      	cmp	r4, #3
   11a92:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   11a96:	d90d      	bls.n	11ab4 <memset+0x7c>
   11a98:	461e      	mov	r6, r3
   11a9a:	4622      	mov	r2, r4
   11a9c:	3a04      	subs	r2, #4
   11a9e:	2a03      	cmp	r2, #3
   11aa0:	f846 5b04 	str.w	r5, [r6], #4
   11aa4:	d8fa      	bhi.n	11a9c <memset+0x64>
   11aa6:	1f22      	subs	r2, r4, #4
   11aa8:	f022 0203 	bic.w	r2, r2, #3
   11aac:	3204      	adds	r2, #4
   11aae:	4413      	add	r3, r2
   11ab0:	f004 0403 	and.w	r4, r4, #3
   11ab4:	b12c      	cbz	r4, 11ac2 <memset+0x8a>
   11ab6:	b2c9      	uxtb	r1, r1
   11ab8:	441c      	add	r4, r3
   11aba:	f803 1b01 	strb.w	r1, [r3], #1
   11abe:	42a3      	cmp	r3, r4
   11ac0:	d1fb      	bne.n	11aba <memset+0x82>
   11ac2:	bcf0      	pop	{r4, r5, r6, r7}
   11ac4:	4770      	bx	lr
   11ac6:	4614      	mov	r4, r2
   11ac8:	4603      	mov	r3, r0
   11aca:	e7c6      	b.n	11a5a <memset+0x22>

00011acc <NVIC>:
   11acc:	e100 e000                                   ....

00011ad0 <SPI>:
   11ad0:	8000 4000                                   ...@

00011ad4 <USART0>:
   11ad4:	4000 4002                                   .@.@

00011ad8 <USART1>:
   11ad8:	8000 4002                                   ...@

00011adc <USART2>:
   11adc:	c000 4002                                   ...@

00011ae0 <USART3>:
   11ae0:	0000 4003                                   ...@

00011ae4 <PM>:
   11ae4:	0000 400e                                   ...@

00011ae8 <SYSTICK>:
   11ae8:	e010 e000                                   ....

00011aec <GPIO_PORT_A>:
   11aec:	1000 400e                                   ...@
