
build//main.exe:     file format elf32-littlearm


Disassembly of section .text:

00010000 <_sfixed>:
   10000:	20001218 	.word	0x20001218
   10004:	00011921 	.word	0x00011921
   10008:	0001191d 	.word	0x0001191d
   1000c:	0001191d 	.word	0x0001191d
   10010:	0001191d 	.word	0x0001191d
   10014:	0001191d 	.word	0x0001191d
   10018:	0001191d 	.word	0x0001191d
	...
   1002c:	0001191d 	.word	0x0001191d
   10030:	0001191d 	.word	0x0001191d
   10034:	00000000 	.word	0x00000000
   10038:	0001191d 	.word	0x0001191d
   1003c:	0001191d 	.word	0x0001191d
   10040:	0001191d 	.word	0x0001191d
   10044:	0001191d 	.word	0x0001191d
   10048:	0001191d 	.word	0x0001191d
   1004c:	0001191d 	.word	0x0001191d
   10050:	0001191d 	.word	0x0001191d
   10054:	0001191d 	.word	0x0001191d
   10058:	0001191d 	.word	0x0001191d
   1005c:	0001191d 	.word	0x0001191d
   10060:	0001191d 	.word	0x0001191d
   10064:	0001191d 	.word	0x0001191d
   10068:	0001191d 	.word	0x0001191d
   1006c:	0001191d 	.word	0x0001191d
   10070:	0001191d 	.word	0x0001191d
   10074:	0001191d 	.word	0x0001191d
   10078:	0001191d 	.word	0x0001191d
   1007c:	0001191d 	.word	0x0001191d
   10080:	0001191d 	.word	0x0001191d
   10084:	0001191d 	.word	0x0001191d
   10088:	0001191d 	.word	0x0001191d
   1008c:	0001191d 	.word	0x0001191d
   10090:	0001191d 	.word	0x0001191d
   10094:	0001191d 	.word	0x0001191d
   10098:	0001191d 	.word	0x0001191d
   1009c:	0001191d 	.word	0x0001191d
   100a0:	0001191d 	.word	0x0001191d
   100a4:	00010cf9 	.word	0x00010cf9
   100a8:	00010d0d 	.word	0x00010d0d
   100ac:	00010d59 	.word	0x00010d59
   100b0:	00010da5 	.word	0x00010da5
   100b4:	00010dc9 	.word	0x00010dc9
   100b8:	00010ddd 	.word	0x00010ddd
   100bc:	00010e29 	.word	0x00010e29
   100c0:	00010e35 	.word	0x00010e35
   100c4:	00010e41 	.word	0x00010e41
   100c8:	00010e55 	.word	0x00010e55
   100cc:	00010ea1 	.word	0x00010ea1
   100d0:	00010eed 	.word	0x00010eed
   100d4:	0001191d 	.word	0x0001191d
   100d8:	0001191d 	.word	0x0001191d
   100dc:	0001191d 	.word	0x0001191d
   100e0:	0001191d 	.word	0x0001191d
   100e4:	0001191d 	.word	0x0001191d
   100e8:	0001191d 	.word	0x0001191d
   100ec:	0001191d 	.word	0x0001191d
   100f0:	0001191d 	.word	0x0001191d
   100f4:	0001191d 	.word	0x0001191d
   100f8:	0001191d 	.word	0x0001191d
   100fc:	0001191d 	.word	0x0001191d
   10100:	0001191d 	.word	0x0001191d
   10104:	0001191d 	.word	0x0001191d
   10108:	0001191d 	.word	0x0001191d
   1010c:	0001191d 	.word	0x0001191d
   10110:	0001191d 	.word	0x0001191d
   10114:	0001191d 	.word	0x0001191d
   10118:	0001191d 	.word	0x0001191d
   1011c:	0001191d 	.word	0x0001191d
   10120:	0001191d 	.word	0x0001191d
   10124:	0001191d 	.word	0x0001191d
   10128:	0001191d 	.word	0x0001191d
   1012c:	0001191d 	.word	0x0001191d
   10130:	0001191d 	.word	0x0001191d
   10134:	0001191d 	.word	0x0001191d
   10138:	0001191d 	.word	0x0001191d
   1013c:	0001191d 	.word	0x0001191d
   10140:	0001191d 	.word	0x0001191d
   10144:	00011209 	.word	0x00011209
   10148:	00011341 	.word	0x00011341
   1014c:	00011479 	.word	0x00011479
   10150:	000115d5 	.word	0x000115d5
   10154:	0001191d 	.word	0x0001191d
   10158:	0001191d 	.word	0x0001191d
   1015c:	0001191d 	.word	0x0001191d
   10160:	0001191d 	.word	0x0001191d
   10164:	0001191d 	.word	0x0001191d
   10168:	0001191d 	.word	0x0001191d
   1016c:	0001191d 	.word	0x0001191d
   10170:	0001191d 	.word	0x0001191d
   10174:	0001191d 	.word	0x0001191d
   10178:	0001191d 	.word	0x0001191d
   1017c:	0001191d 	.word	0x0001191d

00010180 <HplSam4lGeneralIOP__8__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10180:	4b06      	ldr	r3, [pc, #24]	; (1019c <HplSam4lGeneralIOP__8__ByteIRQ__fired+0x1c>)
   10182:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10186:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1018a:	400a      	ands	r2, r1
   1018c:	05d2      	lsls	r2, r2, #23
        {
            PORT->ifrc = MASK;
   1018e:	bf44      	itt	mi
   10190:	f44f 7280 	movmi.w	r2, #256	; 0x100
   10194:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10198:	4770      	bx	lr
   1019a:	bf00      	nop
   1019c:	400e1000 	.word	0x400e1000

000101a0 <HplSam4lGeneralIOP__9__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   101a0:	4b06      	ldr	r3, [pc, #24]	; (101bc <HplSam4lGeneralIOP__9__ByteIRQ__fired+0x1c>)
   101a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   101a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   101aa:	400a      	ands	r2, r1
   101ac:	0591      	lsls	r1, r2, #22
        {
            PORT->ifrc = MASK;
   101ae:	bf44      	itt	mi
   101b0:	f44f 7200 	movmi.w	r2, #512	; 0x200
   101b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   101b8:	4770      	bx	lr
   101ba:	bf00      	nop
   101bc:	400e1000 	.word	0x400e1000

000101c0 <HplSam4lGeneralIOP__10__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   101c0:	4b06      	ldr	r3, [pc, #24]	; (101dc <HplSam4lGeneralIOP__10__ByteIRQ__fired+0x1c>)
   101c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   101c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   101ca:	400a      	ands	r2, r1
   101cc:	0550      	lsls	r0, r2, #21
        {
            PORT->ifrc = MASK;
   101ce:	bf44      	itt	mi
   101d0:	f44f 6280 	movmi.w	r2, #1024	; 0x400
   101d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   101d8:	4770      	bx	lr
   101da:	bf00      	nop
   101dc:	400e1000 	.word	0x400e1000

000101e0 <HplSam4lGeneralIOP__11__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   101e0:	4b06      	ldr	r3, [pc, #24]	; (101fc <HplSam4lGeneralIOP__11__ByteIRQ__fired+0x1c>)
   101e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   101e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   101ea:	400a      	ands	r2, r1
   101ec:	0512      	lsls	r2, r2, #20
        {
            PORT->ifrc = MASK;
   101ee:	bf44      	itt	mi
   101f0:	f44f 6200 	movmi.w	r2, #2048	; 0x800
   101f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   101f8:	4770      	bx	lr
   101fa:	bf00      	nop
   101fc:	400e1000 	.word	0x400e1000

00010200 <HplSam4lGeneralIOP__12__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10200:	4b06      	ldr	r3, [pc, #24]	; (1021c <HplSam4lGeneralIOP__12__ByteIRQ__fired+0x1c>)
   10202:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10206:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1020a:	400a      	ands	r2, r1
   1020c:	04d1      	lsls	r1, r2, #19
        {
            PORT->ifrc = MASK;
   1020e:	bf44      	itt	mi
   10210:	f44f 5280 	movmi.w	r2, #4096	; 0x1000
   10214:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10218:	4770      	bx	lr
   1021a:	bf00      	nop
   1021c:	400e1000 	.word	0x400e1000

00010220 <HplSam4lGeneralIOP__13__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10220:	4b06      	ldr	r3, [pc, #24]	; (1023c <HplSam4lGeneralIOP__13__ByteIRQ__fired+0x1c>)
   10222:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10226:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1022a:	400a      	ands	r2, r1
   1022c:	0490      	lsls	r0, r2, #18
        {
            PORT->ifrc = MASK;
   1022e:	bf44      	itt	mi
   10230:	f44f 5200 	movmi.w	r2, #8192	; 0x2000
   10234:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10238:	4770      	bx	lr
   1023a:	bf00      	nop
   1023c:	400e1000 	.word	0x400e1000

00010240 <HplSam4lGeneralIOP__14__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10240:	4b06      	ldr	r3, [pc, #24]	; (1025c <HplSam4lGeneralIOP__14__ByteIRQ__fired+0x1c>)
   10242:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10246:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1024a:	400a      	ands	r2, r1
   1024c:	0452      	lsls	r2, r2, #17
        {
            PORT->ifrc = MASK;
   1024e:	bf44      	itt	mi
   10250:	f44f 4280 	movmi.w	r2, #16384	; 0x4000
   10254:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10258:	4770      	bx	lr
   1025a:	bf00      	nop
   1025c:	400e1000 	.word	0x400e1000

00010260 <HplSam4lGeneralIOP__15__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10260:	4b06      	ldr	r3, [pc, #24]	; (1027c <HplSam4lGeneralIOP__15__ByteIRQ__fired+0x1c>)
   10262:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10266:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1026a:	400a      	ands	r2, r1
   1026c:	0411      	lsls	r1, r2, #16
        {
            PORT->ifrc = MASK;
   1026e:	bf44      	itt	mi
   10270:	f44f 4200 	movmi.w	r2, #32768	; 0x8000
   10274:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10278:	4770      	bx	lr
   1027a:	bf00      	nop
   1027c:	400e1000 	.word	0x400e1000

00010280 <HplSam4lGeneralIOP__16__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10280:	4b06      	ldr	r3, [pc, #24]	; (1029c <HplSam4lGeneralIOP__16__ByteIRQ__fired+0x1c>)
   10282:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10286:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1028a:	400a      	ands	r2, r1
   1028c:	03d0      	lsls	r0, r2, #15
        {
            PORT->ifrc = MASK;
   1028e:	bf44      	itt	mi
   10290:	f44f 3280 	movmi.w	r2, #65536	; 0x10000
   10294:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10298:	4770      	bx	lr
   1029a:	bf00      	nop
   1029c:	400e1000 	.word	0x400e1000

000102a0 <HplSam4lGeneralIOP__18__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   102a0:	4b06      	ldr	r3, [pc, #24]	; (102bc <HplSam4lGeneralIOP__18__ByteIRQ__fired+0x1c>)
   102a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   102a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   102aa:	400a      	ands	r2, r1
   102ac:	0352      	lsls	r2, r2, #13
        {
            PORT->ifrc = MASK;
   102ae:	bf44      	itt	mi
   102b0:	f44f 2280 	movmi.w	r2, #262144	; 0x40000
   102b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   102b8:	4770      	bx	lr
   102ba:	bf00      	nop
   102bc:	400e1000 	.word	0x400e1000

000102c0 <HplSam4lGeneralIOP__19__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   102c0:	4b06      	ldr	r3, [pc, #24]	; (102dc <HplSam4lGeneralIOP__19__ByteIRQ__fired+0x1c>)
   102c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   102c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   102ca:	400a      	ands	r2, r1
   102cc:	0311      	lsls	r1, r2, #12
        {
            PORT->ifrc = MASK;
   102ce:	bf44      	itt	mi
   102d0:	f44f 2200 	movmi.w	r2, #524288	; 0x80000
   102d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   102d8:	4770      	bx	lr
   102da:	bf00      	nop
   102dc:	400e1000 	.word	0x400e1000

000102e0 <HplSam4lGeneralIOP__20__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   102e0:	4b06      	ldr	r3, [pc, #24]	; (102fc <HplSam4lGeneralIOP__20__ByteIRQ__fired+0x1c>)
   102e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   102e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   102ea:	400a      	ands	r2, r1
   102ec:	02d0      	lsls	r0, r2, #11
        {
            PORT->ifrc = MASK;
   102ee:	bf44      	itt	mi
   102f0:	f44f 1280 	movmi.w	r2, #1048576	; 0x100000
   102f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   102f8:	4770      	bx	lr
   102fa:	bf00      	nop
   102fc:	400e1000 	.word	0x400e1000

00010300 <HplSam4lGeneralIOP__21__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10300:	4b06      	ldr	r3, [pc, #24]	; (1031c <HplSam4lGeneralIOP__21__ByteIRQ__fired+0x1c>)
   10302:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10306:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1030a:	400a      	ands	r2, r1
   1030c:	0292      	lsls	r2, r2, #10
        {
            PORT->ifrc = MASK;
   1030e:	bf44      	itt	mi
   10310:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   10314:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10318:	4770      	bx	lr
   1031a:	bf00      	nop
   1031c:	400e1000 	.word	0x400e1000

00010320 <HplSam4lGeneralIOP__22__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10320:	4b06      	ldr	r3, [pc, #24]	; (1033c <HplSam4lGeneralIOP__22__ByteIRQ__fired+0x1c>)
   10322:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10326:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1032a:	400a      	ands	r2, r1
   1032c:	0251      	lsls	r1, r2, #9
        {
            PORT->ifrc = MASK;
   1032e:	bf44      	itt	mi
   10330:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   10334:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10338:	4770      	bx	lr
   1033a:	bf00      	nop
   1033c:	400e1000 	.word	0x400e1000

00010340 <HplSam4lGeneralIOP__23__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10340:	4b06      	ldr	r3, [pc, #24]	; (1035c <HplSam4lGeneralIOP__23__ByteIRQ__fired+0x1c>)
   10342:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10346:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1034a:	400a      	ands	r2, r1
   1034c:	0210      	lsls	r0, r2, #8
        {
            PORT->ifrc = MASK;
   1034e:	bf44      	itt	mi
   10350:	f44f 0200 	movmi.w	r2, #8388608	; 0x800000
   10354:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10358:	4770      	bx	lr
   1035a:	bf00      	nop
   1035c:	400e1000 	.word	0x400e1000

00010360 <HplSam4lGeneralIOP__24__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10360:	4b06      	ldr	r3, [pc, #24]	; (1037c <HplSam4lGeneralIOP__24__ByteIRQ__fired+0x1c>)
   10362:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10366:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1036a:	400a      	ands	r2, r1
   1036c:	01d2      	lsls	r2, r2, #7
        {
            PORT->ifrc = MASK;
   1036e:	bf44      	itt	mi
   10370:	f04f 7280 	movmi.w	r2, #16777216	; 0x1000000
   10374:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10378:	4770      	bx	lr
   1037a:	bf00      	nop
   1037c:	400e1000 	.word	0x400e1000

00010380 <HplSam4lGeneralIOP__25__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10380:	4b06      	ldr	r3, [pc, #24]	; (1039c <HplSam4lGeneralIOP__25__ByteIRQ__fired+0x1c>)
   10382:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10386:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1038a:	400a      	ands	r2, r1
   1038c:	0191      	lsls	r1, r2, #6
        {
            PORT->ifrc = MASK;
   1038e:	bf44      	itt	mi
   10390:	f04f 7200 	movmi.w	r2, #33554432	; 0x2000000
   10394:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10398:	4770      	bx	lr
   1039a:	bf00      	nop
   1039c:	400e1000 	.word	0x400e1000

000103a0 <HplSam4lGeneralIOP__26__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   103a0:	4b06      	ldr	r3, [pc, #24]	; (103bc <HplSam4lGeneralIOP__26__ByteIRQ__fired+0x1c>)
   103a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   103a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   103aa:	400a      	ands	r2, r1
   103ac:	0150      	lsls	r0, r2, #5
        {
            PORT->ifrc = MASK;
   103ae:	bf44      	itt	mi
   103b0:	f04f 6280 	movmi.w	r2, #67108864	; 0x4000000
   103b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   103b8:	4770      	bx	lr
   103ba:	bf00      	nop
   103bc:	400e1000 	.word	0x400e1000

000103c0 <HplSam4lGeneralIOP__35__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   103c0:	4b06      	ldr	r3, [pc, #24]	; (103dc <HplSam4lGeneralIOP__35__ByteIRQ__fired+0x1c>)
   103c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   103c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   103ca:	400a      	ands	r2, r1
   103cc:	05d2      	lsls	r2, r2, #23
        {
            PORT->ifrc = MASK;
   103ce:	bf44      	itt	mi
   103d0:	f44f 7280 	movmi.w	r2, #256	; 0x100
   103d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   103d8:	4770      	bx	lr
   103da:	bf00      	nop
   103dc:	400e1200 	.word	0x400e1200

000103e0 <HplSam4lGeneralIOP__36__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   103e0:	4b06      	ldr	r3, [pc, #24]	; (103fc <HplSam4lGeneralIOP__36__ByteIRQ__fired+0x1c>)
   103e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   103e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   103ea:	400a      	ands	r2, r1
   103ec:	0591      	lsls	r1, r2, #22
        {
            PORT->ifrc = MASK;
   103ee:	bf44      	itt	mi
   103f0:	f44f 7200 	movmi.w	r2, #512	; 0x200
   103f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   103f8:	4770      	bx	lr
   103fa:	bf00      	nop
   103fc:	400e1200 	.word	0x400e1200

00010400 <HplSam4lGeneralIOP__37__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10400:	4b06      	ldr	r3, [pc, #24]	; (1041c <HplSam4lGeneralIOP__37__ByteIRQ__fired+0x1c>)
   10402:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10406:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1040a:	400a      	ands	r2, r1
   1040c:	0550      	lsls	r0, r2, #21
        {
            PORT->ifrc = MASK;
   1040e:	bf44      	itt	mi
   10410:	f44f 6280 	movmi.w	r2, #1024	; 0x400
   10414:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10418:	4770      	bx	lr
   1041a:	bf00      	nop
   1041c:	400e1200 	.word	0x400e1200

00010420 <HplSam4lGeneralIOP__38__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10420:	4b06      	ldr	r3, [pc, #24]	; (1043c <HplSam4lGeneralIOP__38__ByteIRQ__fired+0x1c>)
   10422:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10426:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1042a:	400a      	ands	r2, r1
   1042c:	0512      	lsls	r2, r2, #20
        {
            PORT->ifrc = MASK;
   1042e:	bf44      	itt	mi
   10430:	f44f 6200 	movmi.w	r2, #2048	; 0x800
   10434:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10438:	4770      	bx	lr
   1043a:	bf00      	nop
   1043c:	400e1200 	.word	0x400e1200

00010440 <HplSam4lGeneralIOP__39__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10440:	4b06      	ldr	r3, [pc, #24]	; (1045c <HplSam4lGeneralIOP__39__ByteIRQ__fired+0x1c>)
   10442:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10446:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1044a:	400a      	ands	r2, r1
   1044c:	04d1      	lsls	r1, r2, #19
        {
            PORT->ifrc = MASK;
   1044e:	bf44      	itt	mi
   10450:	f44f 5280 	movmi.w	r2, #4096	; 0x1000
   10454:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10458:	4770      	bx	lr
   1045a:	bf00      	nop
   1045c:	400e1200 	.word	0x400e1200

00010460 <HplSam4lGeneralIOP__40__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10460:	4b06      	ldr	r3, [pc, #24]	; (1047c <HplSam4lGeneralIOP__40__ByteIRQ__fired+0x1c>)
   10462:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10466:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1046a:	400a      	ands	r2, r1
   1046c:	0490      	lsls	r0, r2, #18
        {
            PORT->ifrc = MASK;
   1046e:	bf44      	itt	mi
   10470:	f44f 5200 	movmi.w	r2, #8192	; 0x2000
   10474:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10478:	4770      	bx	lr
   1047a:	bf00      	nop
   1047c:	400e1200 	.word	0x400e1200

00010480 <HplSam4lGeneralIOP__41__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10480:	4b06      	ldr	r3, [pc, #24]	; (1049c <HplSam4lGeneralIOP__41__ByteIRQ__fired+0x1c>)
   10482:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10486:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1048a:	400a      	ands	r2, r1
   1048c:	0452      	lsls	r2, r2, #17
        {
            PORT->ifrc = MASK;
   1048e:	bf44      	itt	mi
   10490:	f44f 4280 	movmi.w	r2, #16384	; 0x4000
   10494:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10498:	4770      	bx	lr
   1049a:	bf00      	nop
   1049c:	400e1200 	.word	0x400e1200

000104a0 <HplSam4lGeneralIOP__42__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   104a0:	4b06      	ldr	r3, [pc, #24]	; (104bc <HplSam4lGeneralIOP__42__ByteIRQ__fired+0x1c>)
   104a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   104a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   104aa:	400a      	ands	r2, r1
   104ac:	0411      	lsls	r1, r2, #16
        {
            PORT->ifrc = MASK;
   104ae:	bf44      	itt	mi
   104b0:	f44f 4200 	movmi.w	r2, #32768	; 0x8000
   104b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   104b8:	4770      	bx	lr
   104ba:	bf00      	nop
   104bc:	400e1200 	.word	0x400e1200

000104c0 <HplSam4lGeneralIOP__51__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   104c0:	4b06      	ldr	r3, [pc, #24]	; (104dc <HplSam4lGeneralIOP__51__ByteIRQ__fired+0x1c>)
   104c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   104c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   104ca:	400a      	ands	r2, r1
   104cc:	05d0      	lsls	r0, r2, #23
        {
            PORT->ifrc = MASK;
   104ce:	bf44      	itt	mi
   104d0:	f44f 7280 	movmi.w	r2, #256	; 0x100
   104d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   104d8:	4770      	bx	lr
   104da:	bf00      	nop
   104dc:	400e1400 	.word	0x400e1400

000104e0 <HplSam4lGeneralIOP__52__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   104e0:	4b06      	ldr	r3, [pc, #24]	; (104fc <HplSam4lGeneralIOP__52__ByteIRQ__fired+0x1c>)
   104e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   104e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   104ea:	400a      	ands	r2, r1
   104ec:	0592      	lsls	r2, r2, #22
        {
            PORT->ifrc = MASK;
   104ee:	bf44      	itt	mi
   104f0:	f44f 7200 	movmi.w	r2, #512	; 0x200
   104f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   104f8:	4770      	bx	lr
   104fa:	bf00      	nop
   104fc:	400e1400 	.word	0x400e1400

00010500 <HplSam4lGeneralIOP__53__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10500:	4b06      	ldr	r3, [pc, #24]	; (1051c <HplSam4lGeneralIOP__53__ByteIRQ__fired+0x1c>)
   10502:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10506:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1050a:	400a      	ands	r2, r1
   1050c:	0551      	lsls	r1, r2, #21
        {
            PORT->ifrc = MASK;
   1050e:	bf44      	itt	mi
   10510:	f44f 6280 	movmi.w	r2, #1024	; 0x400
   10514:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10518:	4770      	bx	lr
   1051a:	bf00      	nop
   1051c:	400e1400 	.word	0x400e1400

00010520 <HplSam4lGeneralIOP__54__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10520:	4b06      	ldr	r3, [pc, #24]	; (1053c <HplSam4lGeneralIOP__54__ByteIRQ__fired+0x1c>)
   10522:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10526:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1052a:	400a      	ands	r2, r1
   1052c:	0510      	lsls	r0, r2, #20
        {
            PORT->ifrc = MASK;
   1052e:	bf44      	itt	mi
   10530:	f44f 6200 	movmi.w	r2, #2048	; 0x800
   10534:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10538:	4770      	bx	lr
   1053a:	bf00      	nop
   1053c:	400e1400 	.word	0x400e1400

00010540 <HplSam4lGeneralIOP__55__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10540:	4b06      	ldr	r3, [pc, #24]	; (1055c <HplSam4lGeneralIOP__55__ByteIRQ__fired+0x1c>)
   10542:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10546:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1054a:	400a      	ands	r2, r1
   1054c:	04d2      	lsls	r2, r2, #19
        {
            PORT->ifrc = MASK;
   1054e:	bf44      	itt	mi
   10550:	f44f 5280 	movmi.w	r2, #4096	; 0x1000
   10554:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10558:	4770      	bx	lr
   1055a:	bf00      	nop
   1055c:	400e1400 	.word	0x400e1400

00010560 <HplSam4lGeneralIOP__56__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10560:	4b06      	ldr	r3, [pc, #24]	; (1057c <HplSam4lGeneralIOP__56__ByteIRQ__fired+0x1c>)
   10562:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10566:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1056a:	400a      	ands	r2, r1
   1056c:	0491      	lsls	r1, r2, #18
        {
            PORT->ifrc = MASK;
   1056e:	bf44      	itt	mi
   10570:	f44f 5200 	movmi.w	r2, #8192	; 0x2000
   10574:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10578:	4770      	bx	lr
   1057a:	bf00      	nop
   1057c:	400e1400 	.word	0x400e1400

00010580 <HplSam4lGeneralIOP__57__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10580:	4b06      	ldr	r3, [pc, #24]	; (1059c <HplSam4lGeneralIOP__57__ByteIRQ__fired+0x1c>)
   10582:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10586:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1058a:	400a      	ands	r2, r1
   1058c:	0450      	lsls	r0, r2, #17
        {
            PORT->ifrc = MASK;
   1058e:	bf44      	itt	mi
   10590:	f44f 4280 	movmi.w	r2, #16384	; 0x4000
   10594:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10598:	4770      	bx	lr
   1059a:	bf00      	nop
   1059c:	400e1400 	.word	0x400e1400

000105a0 <HplSam4lGeneralIOP__58__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   105a0:	4b06      	ldr	r3, [pc, #24]	; (105bc <HplSam4lGeneralIOP__58__ByteIRQ__fired+0x1c>)
   105a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   105a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   105aa:	400a      	ands	r2, r1
   105ac:	0412      	lsls	r2, r2, #16
        {
            PORT->ifrc = MASK;
   105ae:	bf44      	itt	mi
   105b0:	f44f 4200 	movmi.w	r2, #32768	; 0x8000
   105b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   105b8:	4770      	bx	lr
   105ba:	bf00      	nop
   105bc:	400e1400 	.word	0x400e1400

000105c0 <HplSam4lGeneralIOP__59__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   105c0:	4b06      	ldr	r3, [pc, #24]	; (105dc <HplSam4lGeneralIOP__59__ByteIRQ__fired+0x1c>)
   105c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   105c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   105ca:	400a      	ands	r2, r1
   105cc:	03d1      	lsls	r1, r2, #15
        {
            PORT->ifrc = MASK;
   105ce:	bf44      	itt	mi
   105d0:	f44f 3280 	movmi.w	r2, #65536	; 0x10000
   105d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   105d8:	4770      	bx	lr
   105da:	bf00      	nop
   105dc:	400e1400 	.word	0x400e1400

000105e0 <HplSam4lGeneralIOP__60__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   105e0:	4b06      	ldr	r3, [pc, #24]	; (105fc <HplSam4lGeneralIOP__60__ByteIRQ__fired+0x1c>)
   105e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   105e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   105ea:	400a      	ands	r2, r1
   105ec:	0390      	lsls	r0, r2, #14
        {
            PORT->ifrc = MASK;
   105ee:	bf44      	itt	mi
   105f0:	f44f 3200 	movmi.w	r2, #131072	; 0x20000
   105f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   105f8:	4770      	bx	lr
   105fa:	bf00      	nop
   105fc:	400e1400 	.word	0x400e1400

00010600 <HplSam4lGeneralIOP__61__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10600:	4b06      	ldr	r3, [pc, #24]	; (1061c <HplSam4lGeneralIOP__61__ByteIRQ__fired+0x1c>)
   10602:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10606:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1060a:	400a      	ands	r2, r1
   1060c:	0352      	lsls	r2, r2, #13
        {
            PORT->ifrc = MASK;
   1060e:	bf44      	itt	mi
   10610:	f44f 2280 	movmi.w	r2, #262144	; 0x40000
   10614:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10618:	4770      	bx	lr
   1061a:	bf00      	nop
   1061c:	400e1400 	.word	0x400e1400

00010620 <HplSam4lGeneralIOP__62__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10620:	4b06      	ldr	r3, [pc, #24]	; (1063c <HplSam4lGeneralIOP__62__ByteIRQ__fired+0x1c>)
   10622:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10626:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1062a:	400a      	ands	r2, r1
   1062c:	0311      	lsls	r1, r2, #12
        {
            PORT->ifrc = MASK;
   1062e:	bf44      	itt	mi
   10630:	f44f 2200 	movmi.w	r2, #524288	; 0x80000
   10634:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10638:	4770      	bx	lr
   1063a:	bf00      	nop
   1063c:	400e1400 	.word	0x400e1400

00010640 <HplSam4lGeneralIOP__63__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10640:	4b06      	ldr	r3, [pc, #24]	; (1065c <HplSam4lGeneralIOP__63__ByteIRQ__fired+0x1c>)
   10642:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10646:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1064a:	400a      	ands	r2, r1
   1064c:	02d0      	lsls	r0, r2, #11
        {
            PORT->ifrc = MASK;
   1064e:	bf44      	itt	mi
   10650:	f44f 1280 	movmi.w	r2, #1048576	; 0x100000
   10654:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10658:	4770      	bx	lr
   1065a:	bf00      	nop
   1065c:	400e1400 	.word	0x400e1400

00010660 <HplSam4lGeneralIOP__64__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10660:	4b06      	ldr	r3, [pc, #24]	; (1067c <HplSam4lGeneralIOP__64__ByteIRQ__fired+0x1c>)
   10662:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10666:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1066a:	400a      	ands	r2, r1
   1066c:	0292      	lsls	r2, r2, #10
        {
            PORT->ifrc = MASK;
   1066e:	bf44      	itt	mi
   10670:	f44f 1200 	movmi.w	r2, #2097152	; 0x200000
   10674:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10678:	4770      	bx	lr
   1067a:	bf00      	nop
   1067c:	400e1400 	.word	0x400e1400

00010680 <HplSam4lGeneralIOP__65__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10680:	4b06      	ldr	r3, [pc, #24]	; (1069c <HplSam4lGeneralIOP__65__ByteIRQ__fired+0x1c>)
   10682:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10686:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1068a:	400a      	ands	r2, r1
   1068c:	0251      	lsls	r1, r2, #9
        {
            PORT->ifrc = MASK;
   1068e:	bf44      	itt	mi
   10690:	f44f 0280 	movmi.w	r2, #4194304	; 0x400000
   10694:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10698:	4770      	bx	lr
   1069a:	bf00      	nop
   1069c:	400e1400 	.word	0x400e1400

000106a0 <HplSam4lGeneralIOP__66__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   106a0:	4b06      	ldr	r3, [pc, #24]	; (106bc <HplSam4lGeneralIOP__66__ByteIRQ__fired+0x1c>)
   106a2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   106a6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   106aa:	400a      	ands	r2, r1
   106ac:	0210      	lsls	r0, r2, #8
        {
            PORT->ifrc = MASK;
   106ae:	bf44      	itt	mi
   106b0:	f44f 0200 	movmi.w	r2, #8388608	; 0x800000
   106b4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   106b8:	4770      	bx	lr
   106ba:	bf00      	nop
   106bc:	400e1400 	.word	0x400e1400

000106c0 <HplSam4lGeneralIOP__67__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   106c0:	4b06      	ldr	r3, [pc, #24]	; (106dc <HplSam4lGeneralIOP__67__ByteIRQ__fired+0x1c>)
   106c2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   106c6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   106ca:	400a      	ands	r2, r1
   106cc:	01d2      	lsls	r2, r2, #7
        {
            PORT->ifrc = MASK;
   106ce:	bf44      	itt	mi
   106d0:	f04f 7280 	movmi.w	r2, #16777216	; 0x1000000
   106d4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   106d8:	4770      	bx	lr
   106da:	bf00      	nop
   106dc:	400e1400 	.word	0x400e1400

000106e0 <HplSam4lGeneralIOP__68__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   106e0:	4b06      	ldr	r3, [pc, #24]	; (106fc <HplSam4lGeneralIOP__68__ByteIRQ__fired+0x1c>)
   106e2:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   106e6:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   106ea:	400a      	ands	r2, r1
   106ec:	0191      	lsls	r1, r2, #6
        {
            PORT->ifrc = MASK;
   106ee:	bf44      	itt	mi
   106f0:	f04f 7200 	movmi.w	r2, #33554432	; 0x2000000
   106f4:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   106f8:	4770      	bx	lr
   106fa:	bf00      	nop
   106fc:	400e1400 	.word	0x400e1400

00010700 <HplSam4lGeneralIOP__69__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10700:	4b06      	ldr	r3, [pc, #24]	; (1071c <HplSam4lGeneralIOP__69__ByteIRQ__fired+0x1c>)
   10702:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10706:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1070a:	400a      	ands	r2, r1
   1070c:	0150      	lsls	r0, r2, #5
        {
            PORT->ifrc = MASK;
   1070e:	bf44      	itt	mi
   10710:	f04f 6280 	movmi.w	r2, #67108864	; 0x4000000
   10714:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10718:	4770      	bx	lr
   1071a:	bf00      	nop
   1071c:	400e1400 	.word	0x400e1400

00010720 <HplSam4lGeneralIOP__70__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10720:	4b06      	ldr	r3, [pc, #24]	; (1073c <HplSam4lGeneralIOP__70__ByteIRQ__fired+0x1c>)
   10722:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10726:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1072a:	400a      	ands	r2, r1
   1072c:	0112      	lsls	r2, r2, #4
        {
            PORT->ifrc = MASK;
   1072e:	bf44      	itt	mi
   10730:	f04f 6200 	movmi.w	r2, #134217728	; 0x8000000
   10734:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10738:	4770      	bx	lr
   1073a:	bf00      	nop
   1073c:	400e1400 	.word	0x400e1400

00010740 <HplSam4lGeneralIOP__71__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10740:	4b06      	ldr	r3, [pc, #24]	; (1075c <HplSam4lGeneralIOP__71__ByteIRQ__fired+0x1c>)
   10742:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10746:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1074a:	400a      	ands	r2, r1
   1074c:	00d1      	lsls	r1, r2, #3
        {
            PORT->ifrc = MASK;
   1074e:	bf44      	itt	mi
   10750:	f04f 5280 	movmi.w	r2, #268435456	; 0x10000000
   10754:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10758:	4770      	bx	lr
   1075a:	bf00      	nop
   1075c:	400e1400 	.word	0x400e1400

00010760 <HplSam4lGeneralIOP__72__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10760:	4b06      	ldr	r3, [pc, #24]	; (1077c <HplSam4lGeneralIOP__72__ByteIRQ__fired+0x1c>)
   10762:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10766:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1076a:	400a      	ands	r2, r1
   1076c:	0090      	lsls	r0, r2, #2
        {
            PORT->ifrc = MASK;
   1076e:	bf44      	itt	mi
   10770:	f04f 5200 	movmi.w	r2, #536870912	; 0x20000000
   10774:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10778:	4770      	bx	lr
   1077a:	bf00      	nop
   1077c:	400e1400 	.word	0x400e1400

00010780 <HplSam4lGeneralIOP__73__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10780:	4b06      	ldr	r3, [pc, #24]	; (1079c <HplSam4lGeneralIOP__73__ByteIRQ__fired+0x1c>)
   10782:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10786:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1078a:	400a      	ands	r2, r1
   1078c:	0052      	lsls	r2, r2, #1
        {
            PORT->ifrc = MASK;
   1078e:	bf44      	itt	mi
   10790:	f04f 4280 	movmi.w	r2, #1073741824	; 0x40000000
   10794:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   10798:	4770      	bx	lr
   1079a:	bf00      	nop
   1079c:	400e1400 	.word	0x400e1400

000107a0 <HplSam4lGeneralIOP__74__ByteIRQ__fired>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   107a0:	4b05      	ldr	r3, [pc, #20]	; (107b8 <HplSam4lGeneralIOP__74__ByteIRQ__fired+0x18>)
   107a2:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   107a6:	f8d3 1090 	ldr.w	r1, [r3, #144]	; 0x90
   107aa:	4211      	tst	r1, r2
        {
            PORT->ifrc = MASK;
   107ac:	bf44      	itt	mi
   107ae:	f04f 4200 	movmi.w	r2, #2147483648	; 0x80000000
   107b2:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8
   107b6:	4770      	bx	lr
   107b8:	400e1400 	.word	0x400e1400

000107bc <SchedulerBasicP__popTask>:
  // move the head forward
  // if the head is at the end, mark the tail at the end, too
  // mark the task as not in the queue
  inline uint8_t popTask()
  {
    if( m_head != NO_TASK )
   107bc:	4906      	ldr	r1, [pc, #24]	; (107d8 <SchedulerBasicP__popTask+0x1c>)
   107be:	7808      	ldrb	r0, [r1, #0]
   107c0:	28ff      	cmp	r0, #255	; 0xff
   107c2:	d008      	beq.n	107d6 <SchedulerBasicP__popTask+0x1a>
    {
      uint8_t id = m_head;
      m_head = m_next[m_head];
   107c4:	4a05      	ldr	r2, [pc, #20]	; (107dc <SchedulerBasicP__popTask+0x20>)
   107c6:	5c13      	ldrb	r3, [r2, r0]
      if( m_head == NO_TASK )
   107c8:	2bff      	cmp	r3, #255	; 0xff
  inline uint8_t popTask()
  {
    if( m_head != NO_TASK )
    {
      uint8_t id = m_head;
      m_head = m_next[m_head];
   107ca:	700b      	strb	r3, [r1, #0]
      if( m_head == NO_TASK )
      {
	m_tail = NO_TASK;
   107cc:	bf04      	itt	eq
   107ce:	4904      	ldreq	r1, [pc, #16]	; (107e0 <SchedulerBasicP__popTask+0x24>)
   107d0:	700b      	strbeq	r3, [r1, #0]
      }
      m_next[id] = NO_TASK;
   107d2:	23ff      	movs	r3, #255	; 0xff
   107d4:	5413      	strb	r3, [r2, r0]
    }
    else
    {
      return NO_TASK;
    }
  }
   107d6:	4770      	bx	lr
   107d8:	2000020a 	.word	0x2000020a
   107dc:	20000042 	.word	0x20000042
   107e0:	20000214 	.word	0x20000214

000107e4 <McuSleepC__InterruptWrapper__preamble>:

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   107e4:	2201      	movs	r2, #1
   107e6:	f3ef 8310 	mrs	r3, PRIMASK
   107ea:	f382 8810 	msr	PRIMASK, r2
          // Default resume
          resumeFromSleepMode();
      }
      if(ps != S_AWAKE)
        commonResume();
      ps = S_AWAKE;
   107ee:	4a03      	ldr	r2, [pc, #12]	; (107fc <McuSleepC__InterruptWrapper__preamble+0x18>)
   107f0:	2100      	movs	r1, #0
   107f2:	6011      	str	r1, [r2, #0]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   107f4:	f383 8810 	msr	PRIMASK, r3
   107f8:	4770      	bx	lr
   107fa:	bf00      	nop
   107fc:	2000020c 	.word	0x2000020c

00010800 <HplSam4lUSARTP__3__usart__initUART>:

implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
   10800:	4b0f      	ldr	r3, [pc, #60]	; (10840 <HplSam4lUSARTP__3__usart__initUART+0x40>)
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   10802:	4910      	ldr	r1, [pc, #64]	; (10844 <HplSam4lUSARTP__3__usart__initUART+0x44>)

implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
   10804:	681a      	ldr	r2, [r3, #0]
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   10806:	4810      	ldr	r0, [pc, #64]	; (10848 <HplSam4lUSARTP__3__usart__initUART+0x48>)
implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
        shadow |= 1<<bit;
   10808:	f442 6200 	orr.w	r2, r2, #2048	; 0x800
        PM->unlock = PM_UNLOCK_KEY | offset;
   1080c:	65c8      	str	r0, [r1, #92]	; 0x5c
        *((uint32_t volatile *)((void volatile *)PM + offset)) = shadow;
   1080e:	601a      	str	r2, [r3, #0]
		USART->mr.bits.par = 4;
	}
	async command void usart.initUART()
	{
	    call ClockCtl.enable();
		USART->mr.bits.chrl = 3; //8 bits
   10810:	4b0e      	ldr	r3, [pc, #56]	; (1084c <HplSam4lUSARTP__3__usart__initUART+0x4c>)
   10812:	685a      	ldr	r2, [r3, #4]
   10814:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
   10818:	605a      	str	r2, [r3, #4]
		USART->mr.bits.usclks = 0; //use clk_usart.
   1081a:	685a      	ldr	r2, [r3, #4]
   1081c:	f36f 1205 	bfc	r2, #4, #2
   10820:	605a      	str	r2, [r3, #4]
		USART->mr.bits.mode = 0; //UART
   10822:	685a      	ldr	r2, [r3, #4]
   10824:	f36f 0203 	bfc	r2, #0, #4
   10828:	605a      	str	r2, [r3, #4]
		USART->mr.bits.nbstop = 0; //1 stop
   1082a:	685a      	ldr	r2, [r3, #4]
   1082c:	f36f 320d 	bfc	r2, #12, #2
   10830:	605a      	str	r2, [r3, #4]
		USART->mr.bits.par = 4; //No parity
   10832:	6859      	ldr	r1, [r3, #4]
   10834:	2204      	movs	r2, #4
   10836:	f362 214b 	bfi	r1, r2, #9, #3
   1083a:	6059      	str	r1, [r3, #4]
		USART->ttgr = 4; //Space between bytes: 4 bits
   1083c:	629a      	str	r2, [r3, #40]	; 0x28
   1083e:	4770      	bx	lr
   10840:	400e0028 	.word	0x400e0028
   10844:	400e0000 	.word	0x400e0000
   10848:	aa000028 	.word	0xaa000028
   1084c:	40030000 	.word	0x40030000

00010850 <SchedulerBasicP__TaskBasic__postTask>:
  /**
   * Return SUCCESS if the post succeeded, EBUSY if it was already posted.
   */
  
  async command error_t TaskBasic.postTask[uint8_t id]()
  {
   10850:	b510      	push	{r4, lr}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   10852:	2301      	movs	r3, #1
   10854:	f3ef 8110 	mrs	r1, PRIMASK
   10858:	f383 8810 	msr	PRIMASK, r3
    }
  }
  
  bool isWaiting( uint8_t id )
  {
    return (m_next[id] != NO_TASK) || (m_tail == id);
   1085c:	4b0f      	ldr	r3, [pc, #60]	; (1089c <SchedulerBasicP__TaskBasic__postTask+0x4c>)
   1085e:	5c1a      	ldrb	r2, [r3, r0]
   10860:	2aff      	cmp	r2, #255	; 0xff
   10862:	461c      	mov	r4, r3
   10864:	d108      	bne.n	10878 <SchedulerBasicP__TaskBasic__postTask+0x28>
   10866:	4b0e      	ldr	r3, [pc, #56]	; (108a0 <SchedulerBasicP__TaskBasic__postTask+0x50>)
   10868:	781b      	ldrb	r3, [r3, #0]
   1086a:	ebb3 0c00 	subs.w	ip, r3, r0
   1086e:	f1dc 0300 	rsbs	r3, ip, #0
   10872:	eb53 030c 	adcs.w	r3, r3, ip
   10876:	e000      	b.n	1087a <SchedulerBasicP__TaskBasic__postTask+0x2a>
   10878:	2301      	movs	r3, #1
  }

  bool pushTask( uint8_t id )
  {
    if( !isWaiting(id) )
   1087a:	b95b      	cbnz	r3, 10894 <SchedulerBasicP__TaskBasic__postTask+0x44>
    {
      if( m_head == NO_TASK )
   1087c:	4a09      	ldr	r2, [pc, #36]	; (108a4 <SchedulerBasicP__TaskBasic__postTask+0x54>)
   1087e:	7813      	ldrb	r3, [r2, #0]
   10880:	2bff      	cmp	r3, #255	; 0xff
   10882:	4b07      	ldr	r3, [pc, #28]	; (108a0 <SchedulerBasicP__TaskBasic__postTask+0x50>)
      {
	m_head = id;
   10884:	bf0c      	ite	eq
   10886:	7010      	strbeq	r0, [r2, #0]
	m_tail = id;
      }
      else
      {
	m_next[m_tail] = id;
   10888:	781a      	ldrbne	r2, [r3, #0]
	m_tail = id;
   1088a:	7018      	strb	r0, [r3, #0]
	m_head = id;
	m_tail = id;
      }
      else
      {
	m_next[m_tail] = id;
   1088c:	bf18      	it	ne
   1088e:	54a0      	strbne	r0, [r4, r2]
   */
  
  async command error_t TaskBasic.postTask[uint8_t id]()
  {
    atomic { return pushTask(id) ? SUCCESS : EBUSY; }
  }
   10890:	2000      	movs	r0, #0
   10892:	e000      	b.n	10896 <SchedulerBasicP__TaskBasic__postTask+0x46>
   10894:	2005      	movs	r0, #5
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   10896:	f381 8810 	msr	PRIMASK, r1
   1089a:	bd10      	pop	{r4, pc}
   1089c:	20000042 	.word	0x20000042
   108a0:	20000214 	.word	0x20000214
   108a4:	2000020a 	.word	0x2000020a

000108a8 <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   108a8:	4b2c      	ldr	r3, [pc, #176]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0xb4>)
   108aa:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   108ae:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   108b2:	400a      	ands	r2, r1
   108b4:	07d0      	lsls	r0, r2, #31
        {
            PORT->ifrc = MASK;
   108b6:	bf44      	itt	mi
   108b8:	2201      	movmi	r2, #1
   108ba:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   108be:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   108c2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   108c6:	4013      	ands	r3, r2
   108c8:	0799      	lsls	r1, r3, #30
   108ca:	d503      	bpl.n	108d4 <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0x2c>
        {
            PORT->ifrc = MASK;
   108cc:	4b23      	ldr	r3, [pc, #140]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0xb4>)
   108ce:	2202      	movs	r2, #2
   108d0:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   108d4:	4b21      	ldr	r3, [pc, #132]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0xb4>)
   108d6:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   108da:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   108de:	400a      	ands	r2, r1
   108e0:	0752      	lsls	r2, r2, #29
        {
            PORT->ifrc = MASK;
   108e2:	bf44      	itt	mi
   108e4:	2204      	movmi	r2, #4
   108e6:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   108ea:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   108ee:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   108f2:	4013      	ands	r3, r2
   108f4:	071b      	lsls	r3, r3, #28
   108f6:	d503      	bpl.n	10900 <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0x58>
        {
            PORT->ifrc = MASK;
   108f8:	4b18      	ldr	r3, [pc, #96]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0xb4>)
   108fa:	2208      	movs	r2, #8
   108fc:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10900:	4b16      	ldr	r3, [pc, #88]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0xb4>)
   10902:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10906:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1090a:	400a      	ands	r2, r1
   1090c:	06d0      	lsls	r0, r2, #27
        {
            PORT->ifrc = MASK;
   1090e:	bf44      	itt	mi
   10910:	2210      	movmi	r2, #16
   10912:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10916:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   1091a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   1091e:	4013      	ands	r3, r2
   10920:	0699      	lsls	r1, r3, #26
   10922:	d503      	bpl.n	1092c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0x84>
        {
            PORT->ifrc = MASK;
   10924:	4b0d      	ldr	r3, [pc, #52]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0xb4>)
   10926:	2220      	movs	r2, #32
   10928:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   1092c:	4b0b      	ldr	r3, [pc, #44]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0xb4>)
   1092e:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10932:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10936:	400a      	ands	r2, r1
   10938:	0652      	lsls	r2, r2, #25
        {
            PORT->ifrc = MASK;
   1093a:	bf44      	itt	mi
   1093c:	2240      	movmi	r2, #64	; 0x40
   1093e:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10942:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   10946:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   1094a:	4013      	ands	r3, r2
   1094c:	061b      	lsls	r3, r3, #24
   1094e:	d503      	bpl.n	10958 <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0xb0>
        {
            PORT->ifrc = MASK;
   10950:	4b02      	ldr	r3, [pc, #8]	; (1095c <HplSam4lGeneralIOPortP__PortA_IRQ__fired.part.47+0xb4>)
   10952:	2280      	movs	r2, #128	; 0x80
   10954:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
   10958:	4770      	bx	lr
   1095a:	bf00      	nop
   1095c:	400e1000 	.word	0x400e1000

00010960 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10960:	4b2c      	ldr	r3, [pc, #176]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0xb4>)
   10962:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10966:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   1096a:	400a      	ands	r2, r1
   1096c:	07d0      	lsls	r0, r2, #31
        {
            PORT->ifrc = MASK;
   1096e:	bf44      	itt	mi
   10970:	2201      	movmi	r2, #1
   10972:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10976:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   1097a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   1097e:	4013      	ands	r3, r2
   10980:	0799      	lsls	r1, r3, #30
   10982:	d503      	bpl.n	1098c <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0x2c>
        {
            PORT->ifrc = MASK;
   10984:	4b23      	ldr	r3, [pc, #140]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0xb4>)
   10986:	2202      	movs	r2, #2
   10988:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   1098c:	4b21      	ldr	r3, [pc, #132]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0xb4>)
   1098e:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10992:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10996:	400a      	ands	r2, r1
   10998:	0752      	lsls	r2, r2, #29
        {
            PORT->ifrc = MASK;
   1099a:	bf44      	itt	mi
   1099c:	2204      	movmi	r2, #4
   1099e:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   109a2:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   109a6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   109aa:	4013      	ands	r3, r2
   109ac:	071b      	lsls	r3, r3, #28
   109ae:	d503      	bpl.n	109b8 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0x58>
        {
            PORT->ifrc = MASK;
   109b0:	4b18      	ldr	r3, [pc, #96]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0xb4>)
   109b2:	2208      	movs	r2, #8
   109b4:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   109b8:	4b16      	ldr	r3, [pc, #88]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0xb4>)
   109ba:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   109be:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   109c2:	400a      	ands	r2, r1
   109c4:	06d0      	lsls	r0, r2, #27
        {
            PORT->ifrc = MASK;
   109c6:	bf44      	itt	mi
   109c8:	2210      	movmi	r2, #16
   109ca:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   109ce:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   109d2:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   109d6:	4013      	ands	r3, r2
   109d8:	0699      	lsls	r1, r3, #26
   109da:	d503      	bpl.n	109e4 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0x84>
        {
            PORT->ifrc = MASK;
   109dc:	4b0d      	ldr	r3, [pc, #52]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0xb4>)
   109de:	2220      	movs	r2, #32
   109e0:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   109e4:	4b0b      	ldr	r3, [pc, #44]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0xb4>)
   109e6:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   109ea:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   109ee:	400a      	ands	r2, r1
   109f0:	0652      	lsls	r2, r2, #25
        {
            PORT->ifrc = MASK;
   109f2:	bf44      	itt	mi
   109f4:	2240      	movmi	r2, #64	; 0x40
   109f6:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   109fa:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   109fe:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   10a02:	4013      	ands	r3, r2
   10a04:	061b      	lsls	r3, r3, #24
   10a06:	d503      	bpl.n	10a10 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0xb0>
        {
            PORT->ifrc = MASK;
   10a08:	4b02      	ldr	r3, [pc, #8]	; (10a14 <HplSam4lGeneralIOPortP__PortB_IRQ__fired.part.49+0xb4>)
   10a0a:	2280      	movs	r2, #128	; 0x80
   10a0c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
   10a10:	4770      	bx	lr
   10a12:	bf00      	nop
   10a14:	400e1200 	.word	0x400e1200

00010a18 <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51>:

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a18:	4b2c      	ldr	r3, [pc, #176]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0xb4>)
   10a1a:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10a1e:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10a22:	400a      	ands	r2, r1
   10a24:	07d0      	lsls	r0, r2, #31
        {
            PORT->ifrc = MASK;
   10a26:	bf44      	itt	mi
   10a28:	2201      	movmi	r2, #1
   10a2a:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a2e:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   10a32:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   10a36:	4013      	ands	r3, r2
   10a38:	0799      	lsls	r1, r3, #30
   10a3a:	d503      	bpl.n	10a44 <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0x2c>
        {
            PORT->ifrc = MASK;
   10a3c:	4b23      	ldr	r3, [pc, #140]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0xb4>)
   10a3e:	2202      	movs	r2, #2
   10a40:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a44:	4b21      	ldr	r3, [pc, #132]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0xb4>)
   10a46:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10a4a:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10a4e:	400a      	ands	r2, r1
   10a50:	0752      	lsls	r2, r2, #29
        {
            PORT->ifrc = MASK;
   10a52:	bf44      	itt	mi
   10a54:	2204      	movmi	r2, #4
   10a56:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a5a:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   10a5e:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   10a62:	4013      	ands	r3, r2
   10a64:	071b      	lsls	r3, r3, #28
   10a66:	d503      	bpl.n	10a70 <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0x58>
        {
            PORT->ifrc = MASK;
   10a68:	4b18      	ldr	r3, [pc, #96]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0xb4>)
   10a6a:	2208      	movs	r2, #8
   10a6c:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a70:	4b16      	ldr	r3, [pc, #88]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0xb4>)
   10a72:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10a76:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10a7a:	400a      	ands	r2, r1
   10a7c:	06d0      	lsls	r0, r2, #27
        {
            PORT->ifrc = MASK;
   10a7e:	bf44      	itt	mi
   10a80:	2210      	movmi	r2, #16
   10a82:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a86:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   10a8a:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   10a8e:	4013      	ands	r3, r2
   10a90:	0699      	lsls	r1, r3, #26
   10a92:	d503      	bpl.n	10a9c <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0x84>
        {
            PORT->ifrc = MASK;
   10a94:	4b0d      	ldr	r3, [pc, #52]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0xb4>)
   10a96:	2220      	movs	r2, #32
   10a98:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10a9c:	4b0b      	ldr	r3, [pc, #44]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0xb4>)
   10a9e:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10aa2:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10aa6:	400a      	ands	r2, r1
   10aa8:	0652      	lsls	r2, r2, #25
        {
            PORT->ifrc = MASK;
   10aaa:	bf44      	itt	mi
   10aac:	2240      	movmi	r2, #64	; 0x40
   10aae:	f8c3 20d8 	strmi.w	r2, [r3, #216]	; 0xd8

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
        if (PORT->ifr & PORT->ier & MASK)
   10ab2:	f8d3 20d0 	ldr.w	r2, [r3, #208]	; 0xd0
   10ab6:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
   10aba:	4013      	ands	r3, r2
   10abc:	061b      	lsls	r3, r3, #24
   10abe:	d503      	bpl.n	10ac8 <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0xb0>
        {
            PORT->ifrc = MASK;
   10ac0:	4b02      	ldr	r3, [pc, #8]	; (10acc <HplSam4lGeneralIOPortP__PortC_IRQ__fired.part.51+0xb4>)
   10ac2:	2280      	movs	r2, #128	; 0x80
   10ac4:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
   10ac8:	4770      	bx	lr
   10aca:	bf00      	nop
   10acc:	400e1400 	.word	0x400e1400

00010ad0 <SerialPrintfP__mini_itoa.part.55>:
        unsigned int len = 0;
        while (s[len] != '\0') len++;
        return len;
    }

    unsigned int  mini_itoa(int value, unsigned int radix, unsigned int uppercase,
   10ad0:	b5f0      	push	{r4, r5, r6, r7, lr}

        /* No support for unusual radixes. */
        if (radix > 16)
            return 0;

        if (value < 0) {
   10ad2:	2800      	cmp	r0, #0
        unsigned int len = 0;
        while (s[len] != '\0') len++;
        return len;
    }

    unsigned int  mini_itoa(int value, unsigned int radix, unsigned int uppercase,
   10ad4:	9e05      	ldr	r6, [sp, #20]
        if (radix > 16)
            return 0;

        if (value < 0) {
            negative = 1;
            value = -value;
   10ad6:	bfba      	itte	lt
   10ad8:	4240      	neglt	r0, r0
        /* No support for unusual radixes. */
        if (radix > 16)
            return 0;

        if (value < 0) {
            negative = 1;
   10ada:	2501      	movlt	r5, #1

    unsigned int  mini_itoa(int value, unsigned int radix, unsigned int uppercase,
         char *buffer, unsigned int zero_pad)
    {
        char	*pbuffer = buffer;
        int	negative = 0;
   10adc:	2500      	movge	r5, #0
        /* No support for unusual radixes. */
        if (radix > 16)
            return 0;

        if (value < 0) {
            negative = 1;
   10ade:	461c      	mov	r4, r3
            value = -value;
        }

        /* This builds the string back to front ... */
        do {
            int digit = value % radix;
   10ae0:	fbb0 f7f1 	udiv	r7, r0, r1
   10ae4:	fb01 0017 	mls	r0, r1, r7, r0
            *(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
   10ae8:	2809      	cmp	r0, #9
   10aea:	f104 0401 	add.w	r4, r4, #1
   10aee:	dc01      	bgt.n	10af4 <SerialPrintfP__mini_itoa.part.55+0x24>
   10af0:	3030      	adds	r0, #48	; 0x30
   10af2:	e007      	b.n	10b04 <SerialPrintfP__mini_itoa.part.55+0x34>
   10af4:	2a00      	cmp	r2, #0
   10af6:	bf0c      	ite	eq
   10af8:	f04f 0c61 	moveq.w	ip, #97	; 0x61
   10afc:	f04f 0c41 	movne.w	ip, #65	; 0x41
   10b00:	380a      	subs	r0, #10
   10b02:	4460      	add	r0, ip
   10b04:	b2c0      	uxtb	r0, r0
   10b06:	f804 0c01 	strb.w	r0, [r4, #-1]
            value /= radix;
   10b0a:	4638      	mov	r0, r7
        } while (value > 0);
   10b0c:	2f00      	cmp	r7, #0
   10b0e:	d1e7      	bne.n	10ae0 <SerialPrintfP__mini_itoa.part.55+0x10>
        }

        /* This builds the string back to front ... */
        do {
            int digit = value % radix;
            *(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
   10b10:	4621      	mov	r1, r4
            value /= radix;
        } while (value > 0);

        for (i = (pbuffer - buffer); i < zero_pad; i++)
   10b12:	1ae0      	subs	r0, r4, r3
   10b14:	1a42      	subs	r2, r0, r1
   10b16:	4422      	add	r2, r4
   10b18:	42b2      	cmp	r2, r6
   10b1a:	d203      	bcs.n	10b24 <SerialPrintfP__mini_itoa.part.55+0x54>
            *(pbuffer++) = '0';
   10b1c:	2230      	movs	r2, #48	; 0x30
   10b1e:	f804 2b01 	strb.w	r2, [r4], #1
   10b22:	e7f7      	b.n	10b14 <SerialPrintfP__mini_itoa.part.55+0x44>
            int digit = value % radix;
            *(pbuffer++) = (digit < 10 ? '0' + digit : (uppercase ? 'A' : 'a') + digit - 10);
            value /= radix;
        } while (value > 0);

        for (i = (pbuffer - buffer); i < zero_pad; i++)
   10b24:	4622      	mov	r2, r4
            *(pbuffer++) = '0';

        if (negative)
   10b26:	b115      	cbz	r5, 10b2e <SerialPrintfP__mini_itoa.part.55+0x5e>
            *(pbuffer++) = '-';
   10b28:	212d      	movs	r1, #45	; 0x2d
   10b2a:	3401      	adds	r4, #1
   10b2c:	7011      	strb	r1, [r2, #0]

        *(pbuffer) = '\0';

        /* ... now we reverse it (could do it recursively but will
         * conserve the stack space) */
        len = (pbuffer - buffer);
   10b2e:	1ae0      	subs	r0, r4, r3
            *(pbuffer++) = '0';

        if (negative)
            *(pbuffer++) = '-';

        *(pbuffer) = '\0';
   10b30:	2200      	movs	r2, #0
   10b32:	7022      	strb	r2, [r4, #0]
   10b34:	1819      	adds	r1, r3, r0

        /* ... now we reverse it (could do it recursively but will
         * conserve the stack space) */
        len = (pbuffer - buffer);
        for (i = 0; i < len / 2; i++) {
   10b36:	0844      	lsrs	r4, r0, #1
   10b38:	42a2      	cmp	r2, r4
   10b3a:	d007      	beq.n	10b4c <SerialPrintfP__mini_itoa.part.55+0x7c>
            char j = buffer[i];
   10b3c:	5c9d      	ldrb	r5, [r3, r2]
            buffer[i] = buffer[len-i-1];
   10b3e:	f811 6c01 	ldrb.w	r6, [r1, #-1]
   10b42:	549e      	strb	r6, [r3, r2]
            buffer[len-i-1] = j;
   10b44:	f801 5d01 	strb.w	r5, [r1, #-1]!
        *(pbuffer) = '\0';

        /* ... now we reverse it (could do it recursively but will
         * conserve the stack space) */
        len = (pbuffer - buffer);
        for (i = 0; i < len / 2; i++) {
   10b48:	3201      	adds	r2, #1
   10b4a:	e7f5      	b.n	10b38 <SerialPrintfP__mini_itoa.part.55+0x68>
            buffer[i] = buffer[len-i-1];
            buffer[len-i-1] = j;
        }

        return len;
    }
   10b4c:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

00010b50 <HalSam4lUSARTP__2__SpiPacket__send.constprop.63>:
    *
    * @return SUCCESS if the request was accepted for transfer
    */
    async command error_t SpiPacket.send( uint8_t* txBuf, uint8_t* rxBuf, uint16_t len )
    {
        if (tx_buf != NULL && rx_buf != NULL)
   10b50:	4b12      	ldr	r3, [pc, #72]	; (10b9c <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x4c>)
   10b52:	4a13      	ldr	r2, [pc, #76]	; (10ba0 <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x50>)
   10b54:	6819      	ldr	r1, [r3, #0]
   10b56:	4618      	mov	r0, r3
   10b58:	b119      	cbz	r1, 10b62 <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x12>
   10b5a:	6811      	ldr	r1, [r2, #0]
   10b5c:	b109      	cbz	r1, 10b62 <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x12>
        {
            return FAIL;
   10b5e:	2001      	movs	r0, #1
   10b60:	4770      	bx	lr
        }
        irqmode_spi = TRUE;
   10b62:	4910      	ldr	r1, [pc, #64]	; (10ba4 <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x54>)
   10b64:	2301      	movs	r3, #1
   10b66:	700b      	strb	r3, [r1, #0]
        tx_buf = txBuf;
   10b68:	490f      	ldr	r1, [pc, #60]	; (10ba8 <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x58>)
   10b6a:	6001      	str	r1, [r0, #0]
        rx_buf = rxBuf;
   10b6c:	490f      	ldr	r1, [pc, #60]	; (10bac <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x5c>)
   10b6e:	6011      	str	r1, [r2, #0]
        tx_len = len;
   10b70:	4a0f      	ldr	r2, [pc, #60]	; (10bb0 <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x60>)
	default async event void usart1irq.RXRdyFired(){}
	default async event void usart1irq.TXRdyFired(){}

	void enableUSART2IRQ()
    {
		NVIC->iser.flat[2] = 1 << (3);
   10b72:	4910      	ldr	r1, [pc, #64]	; (10bb4 <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x64>)
   10b74:	8013      	strh	r3, [r2, #0]
        tx_ptr = 0;
   10b76:	4a10      	ldr	r2, [pc, #64]	; (10bb8 <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x68>)
   10b78:	2300      	movs	r3, #0
   10b7a:	8013      	strh	r3, [r2, #0]
        rx_ptr = 0;
   10b7c:	4a0f      	ldr	r2, [pc, #60]	; (10bbc <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x6c>)
   10b7e:	2008      	movs	r0, #8
   10b80:	8013      	strh	r3, [r2, #0]
    }
    async command void usart2irq.enableTXRdyIRQ()
    {
        enableUSART2IRQ();
        USART2->ier.bits.txrdy = 1;
   10b82:	4b0f      	ldr	r3, [pc, #60]	; (10bc0 <HalSam4lUSARTP__2__SpiPacket__send.constprop.63+0x70>)
	default async event void usart1irq.RXRdyFired(){}
	default async event void usart1irq.TXRdyFired(){}

	void enableUSART2IRQ()
    {
		NVIC->iser.flat[2] = 1 << (3);
   10b84:	6088      	str	r0, [r1, #8]
    }
    async command void usart2irq.enableTXRdyIRQ()
    {
        enableUSART2IRQ();
        USART2->ier.bits.txrdy = 1;
   10b86:	689a      	ldr	r2, [r3, #8]
   10b88:	f042 0202 	orr.w	r2, r2, #2
   10b8c:	609a      	str	r2, [r3, #8]
	default async event void usart1irq.RXRdyFired(){}
	default async event void usart1irq.TXRdyFired(){}

	void enableUSART2IRQ()
    {
		NVIC->iser.flat[2] = 1 << (3);
   10b8e:	6088      	str	r0, [r1, #8]
	    USART2->idr.bits.txrdy = 1;
	}
	async command void usart2irq.enableRXRdyIRQ()
	{
        enableUSART2IRQ();
	    USART2->ier.bits.rxrdy = 1;
   10b90:	689a      	ldr	r2, [r3, #8]
   10b92:	f042 0201 	orr.w	r2, r2, #1
   10b96:	609a      	str	r2, [r3, #8]
        call usart_irq.enableTXRdyIRQ();
        call usart_irq.enableRXRdyIRQ();
    }
   10b98:	4770      	bx	lr
   10b9a:	bf00      	nop
   10b9c:	20000010 	.word	0x20000010
   10ba0:	20000018 	.word	0x20000018
   10ba4:	2000001c 	.word	0x2000001c
   10ba8:	200000b2 	.word	0x200000b2
   10bac:	2000005f 	.word	0x2000005f
   10bb0:	2000004a 	.word	0x2000004a
   10bb4:	e000e100 	.word	0xe000e100
   10bb8:	20000208 	.word	0x20000208
   10bbc:	2000004c 	.word	0x2000004c
   10bc0:	4002c000 	.word	0x4002c000

00010bc4 <HplSam4lGeneralIOP__17__ByteIRQ__fired>:
    }

    default async event void IRQ.fired(){}

    async event void ByteIRQ.fired()
    {
   10bc4:	b510      	push	{r4, lr}
        if (PORT->ifr & PORT->ier & MASK)
   10bc6:	4b0d      	ldr	r3, [pc, #52]	; (10bfc <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x38>)
   10bc8:	f8d3 10d0 	ldr.w	r1, [r3, #208]	; 0xd0
   10bcc:	f8d3 2090 	ldr.w	r2, [r3, #144]	; 0x90
   10bd0:	400a      	ands	r2, r1
   10bd2:	0394      	lsls	r4, r2, #14
   10bd4:	d510      	bpl.n	10bf8 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x34>
        {
            PORT->ifrc = MASK;
   10bd6:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   10bda:	f8c3 20d8 	str.w	r2, [r3, #216]	; 0xd8
    spiqueued = 1;
  }

  async event void Int.fired()
  {
    if (spiqueued) {
   10bde:	4b08      	ldr	r3, [pc, #32]	; (10c00 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x3c>)
   10be0:	4c08      	ldr	r4, [pc, #32]	; (10c04 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x40>)
   10be2:	781b      	ldrb	r3, [r3, #0]
   10be4:	b133      	cbz	r3, 10bf4 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x30>
        PORT->ovrs = MASK;
	}

	async command void IO.clr()
	{
        PORT->ovrc = MASK;
   10be6:	4b08      	ldr	r3, [pc, #32]	; (10c08 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x44>)
   10be8:	2280      	movs	r2, #128	; 0x80
   10bea:	659a      	str	r2, [r3, #88]	; 0x58
   *              parameters must be AT LEAST as large as len, or the SPI
   *              will overflow a buffer.
   *
   * @return SUCCESS if the request was accepted for transfer
   */
  async command error_t send( uint8_t* txBuf, uint8_t* rxBuf, uint16_t len );
   10bec:	4b07      	ldr	r3, [pc, #28]	; (10c0c <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x48>)
   10bee:	4798      	blx	r3
      call CS.clr();
      call SpiPacket.send(txbuf, rxbuf, 1);
      spiready = 0;
   10bf0:	2300      	movs	r3, #0
   10bf2:	e000      	b.n	10bf6 <HplSam4lGeneralIOP__17__ByteIRQ__fired+0x32>
    } else {
      spiready = 1;
   10bf4:	2301      	movs	r3, #1
   10bf6:	7023      	strb	r3, [r4, #0]
   10bf8:	bd10      	pop	{r4, pc}
   10bfa:	bf00      	nop
   10bfc:	400e1000 	.word	0x400e1000
   10c00:	20000034 	.word	0x20000034
   10c04:	20000015 	.word	0x20000015
   10c08:	400e1400 	.word	0x400e1400
   10c0c:	00010b51 	.word	0x00010b51

00010c10 <SchedulerBasicP__TaskBasic__runTask>:
   * Event from the scheduler to run this task. Following the TinyOS
   * concurrency model, the codes invoked from <tt>run()</tt> signals
   * execute atomically with respect to one another, but can be
   * preempted by async commands/events.
   */
  event void runTask();
   10c10:	b508      	push	{r3, lr}
   10c12:	2805      	cmp	r0, #5
   10c14:	d84b      	bhi.n	10cae <SchedulerBasicP__TaskBasic__runTask+0x9e>
   10c16:	e8df f000 	tbb	[pc, r0]
   10c1a:	1303      	.short	0x1303
   10c1c:	3c302418 	.word	0x3c302418
   10c20:	4b23      	ldr	r3, [pc, #140]	; (10cb0 <SchedulerBasicP__TaskBasic__runTask+0xa0>)
   10c22:	2280      	movs	r2, #128	; 0x80
   10c24:	659a      	str	r2, [r3, #88]	; 0x58
    return SUCCESS;
  }

  command error_t BlePeripheral.startAdvertising() {
    call CS.clr();
    txbuf[0] = 2;
   10c26:	4b23      	ldr	r3, [pc, #140]	; (10cb4 <SchedulerBasicP__TaskBasic__runTask+0xa4>)
   10c28:	2202      	movs	r2, #2
   10c2a:	701a      	strb	r2, [r3, #0]
    if (spiready) {
   10c2c:	4b22      	ldr	r3, [pc, #136]	; (10cb8 <SchedulerBasicP__TaskBasic__runTask+0xa8>)
   10c2e:	781b      	ldrb	r3, [r3, #0]
   10c30:	b113      	cbz	r3, 10c38 <SchedulerBasicP__TaskBasic__runTask+0x28>
   10c32:	4b22      	ldr	r3, [pc, #136]	; (10cbc <SchedulerBasicP__TaskBasic__runTask+0xac>)
   10c34:	4798      	blx	r3
   10c36:	bd08      	pop	{r3, pc}
      call SpiPacket.send(txbuf, rxbuf, 1);
    } else {
      spiqueued = 1;
   10c38:	4b21      	ldr	r3, [pc, #132]	; (10cc0 <SchedulerBasicP__TaskBasic__runTask+0xb0>)
   10c3a:	2201      	movs	r2, #1
   10c3c:	701a      	strb	r2, [r3, #0]
   10c3e:	bd08      	pop	{r3, pc}
        return (PORT->pvr & MASK) != 0;
	}

	async command void IO.set()
	{
        PORT->ovrs = MASK;
   10c40:	4b1b      	ldr	r3, [pc, #108]	; (10cb0 <SchedulerBasicP__TaskBasic__runTask+0xa0>)
   10c42:	f44f 6280 	mov.w	r2, #1024	; 0x400
   10c46:	655a      	str	r2, [r3, #84]	; 0x54
   10c48:	bd08      	pop	{r3, pc}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   10c4a:	2201      	movs	r2, #1
   10c4c:	f3ef 8310 	mrs	r3, PRIMASK
   10c50:	f382 8810 	msr	PRIMASK, r2
                && (state == RES_GRANTING || state == RES_IMM_GRANTING)));
  }
  
  task void grantedTask() {
    atomic {
      resId = reqResId;
   10c54:	4a1b      	ldr	r2, [pc, #108]	; (10cc4 <SchedulerBasicP__TaskBasic__runTask+0xb4>)
   10c56:	7811      	ldrb	r1, [r2, #0]
   10c58:	4a1b      	ldr	r2, [pc, #108]	; (10cc8 <SchedulerBasicP__TaskBasic__runTask+0xb8>)
   10c5a:	7011      	strb	r1, [r2, #0]
      state = RES_BUSY;
   10c5c:	2103      	movs	r1, #3
   10c5e:	4a1b      	ldr	r2, [pc, #108]	; (10ccc <SchedulerBasicP__TaskBasic__runTask+0xbc>)
   10c60:	e022      	b.n	10ca8 <SchedulerBasicP__TaskBasic__runTask+0x98>
   10c62:	2201      	movs	r2, #1
   10c64:	f3ef 8310 	mrs	r3, PRIMASK
   10c68:	f382 8810 	msr	PRIMASK, r2
                && (state == RES_GRANTING || state == RES_IMM_GRANTING)));
  }
  
  task void grantedTask() {
    atomic {
      resId = reqResId;
   10c6c:	4a18      	ldr	r2, [pc, #96]	; (10cd0 <SchedulerBasicP__TaskBasic__runTask+0xc0>)
   10c6e:	7811      	ldrb	r1, [r2, #0]
   10c70:	4a18      	ldr	r2, [pc, #96]	; (10cd4 <SchedulerBasicP__TaskBasic__runTask+0xc4>)
   10c72:	7011      	strb	r1, [r2, #0]
      state = RES_BUSY;
   10c74:	2103      	movs	r1, #3
   10c76:	4a18      	ldr	r2, [pc, #96]	; (10cd8 <SchedulerBasicP__TaskBasic__runTask+0xc8>)
   10c78:	e016      	b.n	10ca8 <SchedulerBasicP__TaskBasic__runTask+0x98>
   10c7a:	2201      	movs	r2, #1
   10c7c:	f3ef 8310 	mrs	r3, PRIMASK
   10c80:	f382 8810 	msr	PRIMASK, r2
                && (state == RES_GRANTING || state == RES_IMM_GRANTING)));
  }
  
  task void grantedTask() {
    atomic {
      resId = reqResId;
   10c84:	4a15      	ldr	r2, [pc, #84]	; (10cdc <SchedulerBasicP__TaskBasic__runTask+0xcc>)
   10c86:	7811      	ldrb	r1, [r2, #0]
   10c88:	4a15      	ldr	r2, [pc, #84]	; (10ce0 <SchedulerBasicP__TaskBasic__runTask+0xd0>)
   10c8a:	7011      	strb	r1, [r2, #0]
      state = RES_BUSY;
   10c8c:	2103      	movs	r1, #3
   10c8e:	4a15      	ldr	r2, [pc, #84]	; (10ce4 <SchedulerBasicP__TaskBasic__runTask+0xd4>)
   10c90:	e00a      	b.n	10ca8 <SchedulerBasicP__TaskBasic__runTask+0x98>
   10c92:	2201      	movs	r2, #1
   10c94:	f3ef 8310 	mrs	r3, PRIMASK
   10c98:	f382 8810 	msr	PRIMASK, r2
                && (state == RES_GRANTING || state == RES_IMM_GRANTING)));
  }
  
  task void grantedTask() {
    atomic {
      resId = reqResId;
   10c9c:	4a12      	ldr	r2, [pc, #72]	; (10ce8 <SchedulerBasicP__TaskBasic__runTask+0xd8>)
   10c9e:	7811      	ldrb	r1, [r2, #0]
   10ca0:	4a12      	ldr	r2, [pc, #72]	; (10cec <SchedulerBasicP__TaskBasic__runTask+0xdc>)
   10ca2:	7011      	strb	r1, [r2, #0]
      state = RES_BUSY;
   10ca4:	4a12      	ldr	r2, [pc, #72]	; (10cf0 <SchedulerBasicP__TaskBasic__runTask+0xe0>)
   10ca6:	2103      	movs	r1, #3
   10ca8:	7011      	strb	r1, [r2, #0]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   10caa:	f383 8810 	msr	PRIMASK, r3
   10cae:	bd08      	pop	{r3, pc}
   10cb0:	400e1400 	.word	0x400e1400
   10cb4:	200000b2 	.word	0x200000b2
   10cb8:	20000015 	.word	0x20000015
   10cbc:	00010b51 	.word	0x00010b51
   10cc0:	20000034 	.word	0x20000034
   10cc4:	20000104 	.word	0x20000104
   10cc8:	2000000b 	.word	0x2000000b
   10ccc:	2000000a 	.word	0x2000000a
   10cd0:	20000058 	.word	0x20000058
   10cd4:	20000037 	.word	0x20000037
   10cd8:	20000036 	.word	0x20000036
   10cdc:	20000048 	.word	0x20000048
   10ce0:	20000001 	.word	0x20000001
   10ce4:	2000001e 	.word	0x2000001e
   10ce8:	2000005e 	.word	0x2000005e
   10cec:	20000000 	.word	0x20000000
   10cf0:	20000008 	.word	0x20000008

00010cf4 <sam4LowPowerConfigure>:
  norace struct {
  } wait_restore;
  
  // This C function is defined so that we can call it
  // from platform_bootstrap(), as defined in platform.h
  void sam4LowPowerConfigure() @C() @spontaneous() {
   10cf4:	4770      	bx	lr
	...

00010cf8 <GPIO_0_Handler>:
    default async event void PortA_IRQ.fired[uint8_t i](){}
    default async event void PortB_IRQ.fired[uint8_t i](){}
    default async event void PortC_IRQ.fired[uint8_t i](){}

    void GPIO_0_Handler() @C() @spontaneous()
    {
   10cf8:	b508      	push	{r3, lr}
/**
 * @author Kevin Klues <Kevin.Klues@csiro.au>
 */

interface FunctionWrapper {
  async command void preamble();
   10cfa:	4b02      	ldr	r3, [pc, #8]	; (10d04 <GPIO_0_Handler+0xc>)
   10cfc:	4798      	blx	r3
   10cfe:	4b02      	ldr	r3, [pc, #8]	; (10d08 <GPIO_0_Handler+0x10>)
   10d00:	4798      	blx	r3
   10d02:	bd08      	pop	{r3, pc}
   10d04:	000107e5 	.word	0x000107e5
   10d08:	000108a9 	.word	0x000108a9

00010d0c <GPIO_1_Handler>:
        signal PortA_IRQ.fired[0]();
        call IRQWrapper.postamble();
    }

    void GPIO_1_Handler() @C() @spontaneous()
    {
   10d0c:	b508      	push	{r3, lr}
   10d0e:	4b09      	ldr	r3, [pc, #36]	; (10d34 <GPIO_1_Handler+0x28>)
   10d10:	4798      	blx	r3
interface ByteIRQ
{
    async event void fired();
   10d12:	4b09      	ldr	r3, [pc, #36]	; (10d38 <GPIO_1_Handler+0x2c>)
   10d14:	4798      	blx	r3
   10d16:	4b09      	ldr	r3, [pc, #36]	; (10d3c <GPIO_1_Handler+0x30>)
   10d18:	4798      	blx	r3
   10d1a:	4b09      	ldr	r3, [pc, #36]	; (10d40 <GPIO_1_Handler+0x34>)
   10d1c:	4798      	blx	r3
   10d1e:	4b09      	ldr	r3, [pc, #36]	; (10d44 <GPIO_1_Handler+0x38>)
   10d20:	4798      	blx	r3
   10d22:	4b09      	ldr	r3, [pc, #36]	; (10d48 <GPIO_1_Handler+0x3c>)
   10d24:	4798      	blx	r3
   10d26:	4b09      	ldr	r3, [pc, #36]	; (10d4c <GPIO_1_Handler+0x40>)
   10d28:	4798      	blx	r3
   10d2a:	4b09      	ldr	r3, [pc, #36]	; (10d50 <GPIO_1_Handler+0x44>)
   10d2c:	4798      	blx	r3
   10d2e:	4b09      	ldr	r3, [pc, #36]	; (10d54 <GPIO_1_Handler+0x48>)
   10d30:	4798      	blx	r3
   10d32:	bd08      	pop	{r3, pc}
   10d34:	000107e5 	.word	0x000107e5
   10d38:	00010181 	.word	0x00010181
   10d3c:	000101a1 	.word	0x000101a1
   10d40:	000101c1 	.word	0x000101c1
   10d44:	000101e1 	.word	0x000101e1
   10d48:	00010201 	.word	0x00010201
   10d4c:	00010221 	.word	0x00010221
   10d50:	00010241 	.word	0x00010241
   10d54:	00010261 	.word	0x00010261

00010d58 <GPIO_2_Handler>:
        signal PortA_IRQ.fired[1]();
        call IRQWrapper.postamble();
    }

    void GPIO_2_Handler() @C() @spontaneous()
    {
   10d58:	b508      	push	{r3, lr}
   10d5a:	4b09      	ldr	r3, [pc, #36]	; (10d80 <GPIO_2_Handler+0x28>)
   10d5c:	4798      	blx	r3
   10d5e:	4b09      	ldr	r3, [pc, #36]	; (10d84 <GPIO_2_Handler+0x2c>)
   10d60:	4798      	blx	r3
   10d62:	4b09      	ldr	r3, [pc, #36]	; (10d88 <GPIO_2_Handler+0x30>)
   10d64:	4798      	blx	r3
   10d66:	4b09      	ldr	r3, [pc, #36]	; (10d8c <GPIO_2_Handler+0x34>)
   10d68:	4798      	blx	r3
   10d6a:	4b09      	ldr	r3, [pc, #36]	; (10d90 <GPIO_2_Handler+0x38>)
   10d6c:	4798      	blx	r3
   10d6e:	4b09      	ldr	r3, [pc, #36]	; (10d94 <GPIO_2_Handler+0x3c>)
   10d70:	4798      	blx	r3
   10d72:	4b09      	ldr	r3, [pc, #36]	; (10d98 <GPIO_2_Handler+0x40>)
   10d74:	4798      	blx	r3
   10d76:	4b09      	ldr	r3, [pc, #36]	; (10d9c <GPIO_2_Handler+0x44>)
   10d78:	4798      	blx	r3
   10d7a:	4b09      	ldr	r3, [pc, #36]	; (10da0 <GPIO_2_Handler+0x48>)
   10d7c:	4798      	blx	r3
   10d7e:	bd08      	pop	{r3, pc}
   10d80:	000107e5 	.word	0x000107e5
   10d84:	00010281 	.word	0x00010281
   10d88:	00010bc5 	.word	0x00010bc5
   10d8c:	000102a1 	.word	0x000102a1
   10d90:	000102c1 	.word	0x000102c1
   10d94:	000102e1 	.word	0x000102e1
   10d98:	00010301 	.word	0x00010301
   10d9c:	00010321 	.word	0x00010321
   10da0:	00010341 	.word	0x00010341

00010da4 <GPIO_3_Handler>:
        signal PortA_IRQ.fired[2]();
        call IRQWrapper.postamble();
    }

    void GPIO_3_Handler() @C() @spontaneous()
    {
   10da4:	b508      	push	{r3, lr}
   10da6:	4b04      	ldr	r3, [pc, #16]	; (10db8 <GPIO_3_Handler+0x14>)
   10da8:	4798      	blx	r3
   10daa:	4b04      	ldr	r3, [pc, #16]	; (10dbc <GPIO_3_Handler+0x18>)
   10dac:	4798      	blx	r3
   10dae:	4b04      	ldr	r3, [pc, #16]	; (10dc0 <GPIO_3_Handler+0x1c>)
   10db0:	4798      	blx	r3
   10db2:	4b04      	ldr	r3, [pc, #16]	; (10dc4 <GPIO_3_Handler+0x20>)
   10db4:	4798      	blx	r3
   10db6:	bd08      	pop	{r3, pc}
   10db8:	000107e5 	.word	0x000107e5
   10dbc:	00010361 	.word	0x00010361
   10dc0:	00010381 	.word	0x00010381
   10dc4:	000103a1 	.word	0x000103a1

00010dc8 <GPIO_4_Handler>:
        signal PortA_IRQ.fired[3]();
        call IRQWrapper.postamble();
    }

    void GPIO_4_Handler() @C() @spontaneous()
    {
   10dc8:	b508      	push	{r3, lr}
   10dca:	4b02      	ldr	r3, [pc, #8]	; (10dd4 <GPIO_4_Handler+0xc>)
   10dcc:	4798      	blx	r3
   10dce:	4b02      	ldr	r3, [pc, #8]	; (10dd8 <GPIO_4_Handler+0x10>)
   10dd0:	4798      	blx	r3
   10dd2:	bd08      	pop	{r3, pc}
   10dd4:	000107e5 	.word	0x000107e5
   10dd8:	00010961 	.word	0x00010961

00010ddc <GPIO_5_Handler>:
        signal PortB_IRQ.fired[0]();
        call IRQWrapper.postamble();
    }

    void GPIO_5_Handler() @C() @spontaneous()
    {
   10ddc:	b508      	push	{r3, lr}
   10dde:	4b09      	ldr	r3, [pc, #36]	; (10e04 <GPIO_5_Handler+0x28>)
   10de0:	4798      	blx	r3
   10de2:	4b09      	ldr	r3, [pc, #36]	; (10e08 <GPIO_5_Handler+0x2c>)
   10de4:	4798      	blx	r3
   10de6:	4b09      	ldr	r3, [pc, #36]	; (10e0c <GPIO_5_Handler+0x30>)
   10de8:	4798      	blx	r3
   10dea:	4b09      	ldr	r3, [pc, #36]	; (10e10 <GPIO_5_Handler+0x34>)
   10dec:	4798      	blx	r3
   10dee:	4b09      	ldr	r3, [pc, #36]	; (10e14 <GPIO_5_Handler+0x38>)
   10df0:	4798      	blx	r3
   10df2:	4b09      	ldr	r3, [pc, #36]	; (10e18 <GPIO_5_Handler+0x3c>)
   10df4:	4798      	blx	r3
   10df6:	4b09      	ldr	r3, [pc, #36]	; (10e1c <GPIO_5_Handler+0x40>)
   10df8:	4798      	blx	r3
   10dfa:	4b09      	ldr	r3, [pc, #36]	; (10e20 <GPIO_5_Handler+0x44>)
   10dfc:	4798      	blx	r3
   10dfe:	4b09      	ldr	r3, [pc, #36]	; (10e24 <GPIO_5_Handler+0x48>)
   10e00:	4798      	blx	r3
   10e02:	bd08      	pop	{r3, pc}
   10e04:	000107e5 	.word	0x000107e5
   10e08:	000103c1 	.word	0x000103c1
   10e0c:	000103e1 	.word	0x000103e1
   10e10:	00010401 	.word	0x00010401
   10e14:	00010421 	.word	0x00010421
   10e18:	00010441 	.word	0x00010441
   10e1c:	00010461 	.word	0x00010461
   10e20:	00010481 	.word	0x00010481
   10e24:	000104a1 	.word	0x000104a1

00010e28 <GPIO_6_Handler>:
        signal PortB_IRQ.fired[1]();
        call IRQWrapper.postamble();
    }

    void GPIO_6_Handler() @C() @spontaneous()
    {
   10e28:	b508      	push	{r3, lr}
   10e2a:	4b01      	ldr	r3, [pc, #4]	; (10e30 <GPIO_6_Handler+0x8>)
   10e2c:	4798      	blx	r3
   10e2e:	bd08      	pop	{r3, pc}
   10e30:	000107e5 	.word	0x000107e5

00010e34 <GPIO_7_Handler>:
        signal PortB_IRQ.fired[2]();
        call IRQWrapper.postamble();
    }

    void GPIO_7_Handler() @C() @spontaneous()
    {
   10e34:	b508      	push	{r3, lr}
   10e36:	4b01      	ldr	r3, [pc, #4]	; (10e3c <GPIO_7_Handler+0x8>)
   10e38:	4798      	blx	r3
   10e3a:	bd08      	pop	{r3, pc}
   10e3c:	000107e5 	.word	0x000107e5

00010e40 <GPIO_8_Handler>:
        signal PortB_IRQ.fired[3]();
        call IRQWrapper.postamble();
    }

    void GPIO_8_Handler() @C() @spontaneous()
    {
   10e40:	b508      	push	{r3, lr}
   10e42:	4b02      	ldr	r3, [pc, #8]	; (10e4c <GPIO_8_Handler+0xc>)
   10e44:	4798      	blx	r3
   10e46:	4b02      	ldr	r3, [pc, #8]	; (10e50 <GPIO_8_Handler+0x10>)
   10e48:	4798      	blx	r3
   10e4a:	bd08      	pop	{r3, pc}
   10e4c:	000107e5 	.word	0x000107e5
   10e50:	00010a19 	.word	0x00010a19

00010e54 <GPIO_9_Handler>:
        signal PortC_IRQ.fired[0]();
        call IRQWrapper.postamble();
    }

    void GPIO_9_Handler() @C() @spontaneous()
    {
   10e54:	b508      	push	{r3, lr}
   10e56:	4b09      	ldr	r3, [pc, #36]	; (10e7c <GPIO_9_Handler+0x28>)
   10e58:	4798      	blx	r3
   10e5a:	4b09      	ldr	r3, [pc, #36]	; (10e80 <GPIO_9_Handler+0x2c>)
   10e5c:	4798      	blx	r3
   10e5e:	4b09      	ldr	r3, [pc, #36]	; (10e84 <GPIO_9_Handler+0x30>)
   10e60:	4798      	blx	r3
   10e62:	4b09      	ldr	r3, [pc, #36]	; (10e88 <GPIO_9_Handler+0x34>)
   10e64:	4798      	blx	r3
   10e66:	4b09      	ldr	r3, [pc, #36]	; (10e8c <GPIO_9_Handler+0x38>)
   10e68:	4798      	blx	r3
   10e6a:	4b09      	ldr	r3, [pc, #36]	; (10e90 <GPIO_9_Handler+0x3c>)
   10e6c:	4798      	blx	r3
   10e6e:	4b09      	ldr	r3, [pc, #36]	; (10e94 <GPIO_9_Handler+0x40>)
   10e70:	4798      	blx	r3
   10e72:	4b09      	ldr	r3, [pc, #36]	; (10e98 <GPIO_9_Handler+0x44>)
   10e74:	4798      	blx	r3
   10e76:	4b09      	ldr	r3, [pc, #36]	; (10e9c <GPIO_9_Handler+0x48>)
   10e78:	4798      	blx	r3
   10e7a:	bd08      	pop	{r3, pc}
   10e7c:	000107e5 	.word	0x000107e5
   10e80:	000104c1 	.word	0x000104c1
   10e84:	000104e1 	.word	0x000104e1
   10e88:	00010501 	.word	0x00010501
   10e8c:	00010521 	.word	0x00010521
   10e90:	00010541 	.word	0x00010541
   10e94:	00010561 	.word	0x00010561
   10e98:	00010581 	.word	0x00010581
   10e9c:	000105a1 	.word	0x000105a1

00010ea0 <GPIO_10_Handler>:
        signal PortC_IRQ.fired[1]();
        call IRQWrapper.postamble();
    }

    void GPIO_10_Handler() @C() @spontaneous()
    {
   10ea0:	b508      	push	{r3, lr}
   10ea2:	4b09      	ldr	r3, [pc, #36]	; (10ec8 <GPIO_10_Handler+0x28>)
   10ea4:	4798      	blx	r3
   10ea6:	4b09      	ldr	r3, [pc, #36]	; (10ecc <GPIO_10_Handler+0x2c>)
   10ea8:	4798      	blx	r3
   10eaa:	4b09      	ldr	r3, [pc, #36]	; (10ed0 <GPIO_10_Handler+0x30>)
   10eac:	4798      	blx	r3
   10eae:	4b09      	ldr	r3, [pc, #36]	; (10ed4 <GPIO_10_Handler+0x34>)
   10eb0:	4798      	blx	r3
   10eb2:	4b09      	ldr	r3, [pc, #36]	; (10ed8 <GPIO_10_Handler+0x38>)
   10eb4:	4798      	blx	r3
   10eb6:	4b09      	ldr	r3, [pc, #36]	; (10edc <GPIO_10_Handler+0x3c>)
   10eb8:	4798      	blx	r3
   10eba:	4b09      	ldr	r3, [pc, #36]	; (10ee0 <GPIO_10_Handler+0x40>)
   10ebc:	4798      	blx	r3
   10ebe:	4b09      	ldr	r3, [pc, #36]	; (10ee4 <GPIO_10_Handler+0x44>)
   10ec0:	4798      	blx	r3
   10ec2:	4b09      	ldr	r3, [pc, #36]	; (10ee8 <GPIO_10_Handler+0x48>)
   10ec4:	4798      	blx	r3
   10ec6:	bd08      	pop	{r3, pc}
   10ec8:	000107e5 	.word	0x000107e5
   10ecc:	000105c1 	.word	0x000105c1
   10ed0:	000105e1 	.word	0x000105e1
   10ed4:	00010601 	.word	0x00010601
   10ed8:	00010621 	.word	0x00010621
   10edc:	00010641 	.word	0x00010641
   10ee0:	00010661 	.word	0x00010661
   10ee4:	00010681 	.word	0x00010681
   10ee8:	000106a1 	.word	0x000106a1

00010eec <GPIO_11_Handler>:
        signal PortC_IRQ.fired[2]();
        call IRQWrapper.postamble();
    }

    void GPIO_11_Handler() @C() @spontaneous()
    {
   10eec:	b508      	push	{r3, lr}
   10eee:	4b09      	ldr	r3, [pc, #36]	; (10f14 <GPIO_11_Handler+0x28>)
   10ef0:	4798      	blx	r3
   10ef2:	4b09      	ldr	r3, [pc, #36]	; (10f18 <GPIO_11_Handler+0x2c>)
   10ef4:	4798      	blx	r3
   10ef6:	4b09      	ldr	r3, [pc, #36]	; (10f1c <GPIO_11_Handler+0x30>)
   10ef8:	4798      	blx	r3
   10efa:	4b09      	ldr	r3, [pc, #36]	; (10f20 <GPIO_11_Handler+0x34>)
   10efc:	4798      	blx	r3
   10efe:	4b09      	ldr	r3, [pc, #36]	; (10f24 <GPIO_11_Handler+0x38>)
   10f00:	4798      	blx	r3
   10f02:	4b09      	ldr	r3, [pc, #36]	; (10f28 <GPIO_11_Handler+0x3c>)
   10f04:	4798      	blx	r3
   10f06:	4b09      	ldr	r3, [pc, #36]	; (10f2c <GPIO_11_Handler+0x40>)
   10f08:	4798      	blx	r3
   10f0a:	4b09      	ldr	r3, [pc, #36]	; (10f30 <GPIO_11_Handler+0x44>)
   10f0c:	4798      	blx	r3
   10f0e:	4b09      	ldr	r3, [pc, #36]	; (10f34 <GPIO_11_Handler+0x48>)
   10f10:	4798      	blx	r3
   10f12:	bd08      	pop	{r3, pc}
   10f14:	000107e5 	.word	0x000107e5
   10f18:	000106c1 	.word	0x000106c1
   10f1c:	000106e1 	.word	0x000106e1
   10f20:	00010701 	.word	0x00010701
   10f24:	00010721 	.word	0x00010721
   10f28:	00010741 	.word	0x00010741
   10f2c:	00010761 	.word	0x00010761
   10f30:	00010781 	.word	0x00010781
   10f34:	000107a1 	.word	0x000107a1

00010f38 <main>:
  uses interface Scheduler;
  uses interface Init as PlatformInit;
  uses interface Init as SoftwareInit;
}
implementation {
  int main() @C() @spontaneous() {
   10f38:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   10f3c:	2301      	movs	r3, #1
   10f3e:	f3ef 8510 	mrs	r5, PRIMASK
   10f42:	f383 8810 	msr	PRIMASK, r3
  
  command void Scheduler.init()
  {
    atomic
    {
      memset( (void *)m_next, NO_TASK, sizeof(m_next) );
   10f46:	21ff      	movs	r1, #255	; 0xff
   10f48:	2206      	movs	r2, #6
   10f4a:	4b8b      	ldr	r3, [pc, #556]	; (11178 <main+0x240>)
   10f4c:	488b      	ldr	r0, [pc, #556]	; (1117c <main+0x244>)

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   10f4e:	f8df 929c 	ldr.w	r9, [pc, #668]	; 111ec <main+0x2b4>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   10f52:	f8df 829c 	ldr.w	r8, [pc, #668]	; 111f0 <main+0x2b8>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   10f56:	4f8a      	ldr	r7, [pc, #552]	; (11180 <main+0x248>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   10f58:	4e8a      	ldr	r6, [pc, #552]	; (11184 <main+0x24c>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   10f5a:	4c8b      	ldr	r4, [pc, #556]	; (11188 <main+0x250>)
   10f5c:	4798      	blx	r3
      m_head = NO_TASK;
   10f5e:	4a8b      	ldr	r2, [pc, #556]	; (1118c <main+0x254>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   10f60:	498b      	ldr	r1, [pc, #556]	; (11190 <main+0x258>)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   10f62:	f8df e290 	ldr.w	lr, [pc, #656]	; 111f4 <main+0x2bc>
   10f66:	23ff      	movs	r3, #255	; 0xff
   10f68:	7013      	strb	r3, [r2, #0]
      m_tail = NO_TASK;
   10f6a:	4a8a      	ldr	r2, [pc, #552]	; (11194 <main+0x25c>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   10f6c:	f44f 6000 	mov.w	r0, #2048	; 0x800
   10f70:	7013      	strb	r3, [r2, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   10f72:	f44f 5c80 	mov.w	ip, #4096	; 0x1000
    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   10f76:	2300      	movs	r3, #0

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   10f78:	f44f 6280 	mov.w	r2, #1024	; 0x400
   10f7c:	f8c9 2000 	str.w	r2, [r9]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   10f80:	f8c8 3000 	str.w	r3, [r8]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   10f84:	f8ce 2000 	str.w	r2, [lr]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   10f88:	603b      	str	r3, [r7, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   10f8a:	6030      	str	r0, [r6, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   10f8c:	6023      	str	r3, [r4, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   10f8e:	f8c1 c000 	str.w	ip, [r1]

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   10f92:	f44f 7c00 	mov.w	ip, #512	; 0x200
   10f96:	f8c9 c000 	str.w	ip, [r9]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   10f9a:	f8c8 3000 	str.w	r3, [r8]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   10f9e:	f8ce c000 	str.w	ip, [lr]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   10fa2:	603b      	str	r3, [r7, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   10fa4:	6032      	str	r2, [r6, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   10fa6:	6023      	str	r3, [r4, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   10fa8:	6008      	str	r0, [r1, #0]
#include <usarthardware.h>
interface HplSam4lUSART
{
    async command void initUART();
   10faa:	4b7b      	ldr	r3, [pc, #492]	; (11198 <main+0x260>)
   10fac:	4798      	blx	r3
    }
    async command void usart.enableTX()
	{
		USART->cr.bits.txen = 1;
   10fae:	4b7b      	ldr	r3, [pc, #492]	; (1119c <main+0x264>)
   10fb0:	681a      	ldr	r2, [r3, #0]
   10fb2:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   10fb6:	601a      	str	r2, [r3, #0]
	{
		USART->cr.bits.rsttx = 1;
	}
	async command void usart.enableRX()
	{
		USART->cr.bits.rxen = 1;
   10fb8:	681a      	ldr	r2, [r3, #0]
   10fba:	f042 0210 	orr.w	r2, r2, #16
   10fbe:	601a      	str	r2, [r3, #0]
		//cd = clk / 16*baud
		//   = gmclk*1000 / (16*b)
		//   = gmclk*625 / b*10
		uint32_t cd = (call MainClock.getMainClockSpeed())*625;
		cd /= (b*10);
		USART->brgr.bits.cd = cd;
   10fc0:	6a1a      	ldr	r2, [r3, #32]
   10fc2:	211a      	movs	r1, #26
   10fc4:	f361 020f 	bfi	r2, r1, #0, #16
   10fc8:	621a      	str	r2, [r3, #32]
  command bool Scheduler.runNextTask()
  {
    uint8_t nextTask;
    atomic
    {
      nextTask = popTask();
   10fca:	4c75      	ldr	r4, [pc, #468]	; (111a0 <main+0x268>)
   10fcc:	47a0      	blx	r4
      if( nextTask == NO_TASK )
   10fce:	28ff      	cmp	r0, #255	; 0xff
   10fd0:	d002      	beq.n	10fd8 <main+0xa0>
      {
	return FALSE;
      }
    }
    signal TaskBasic.runTask[nextTask]();
   10fd2:	4b74      	ldr	r3, [pc, #464]	; (111a4 <main+0x26c>)
   10fd4:	4798      	blx	r3
   10fd6:	e7f8      	b.n	10fca <main+0x92>
  uint8_t resQ[size];
  uint8_t qHead = NO_ENTRY;
  uint8_t qTail = NO_ENTRY;

  command error_t Init.init() {
    memset(resQ, NO_ENTRY, sizeof(resQ));
   10fd8:	4a73      	ldr	r2, [pc, #460]	; (111a8 <main+0x270>)
implementation
{

    command error_t Init.init()
    {
        SYSTICK->csr.bits.clksource = 1;
   10fda:	4b74      	ldr	r3, [pc, #464]	; (111ac <main+0x274>)
   10fdc:	7010      	strb	r0, [r2, #0]
   10fde:	4a74      	ldr	r2, [pc, #464]	; (111b0 <main+0x278>)
   10fe0:	7010      	strb	r0, [r2, #0]
   10fe2:	681a      	ldr	r2, [r3, #0]
   10fe4:	f042 0204 	orr.w	r2, r2, #4
   10fe8:	601a      	str	r2, [r3, #0]
        SYSTICK->csr.bits.tickint = 0;
   10fea:	681a      	ldr	r2, [r3, #0]
   10fec:	f36f 0241 	bfc	r2, #1, #1
   10ff0:	601a      	str	r2, [r3, #0]
        SYSTICK->rvr = 0xFFFFFF;
   10ff2:	f06f 427f 	mvn.w	r2, #4278190080	; 0xff000000
   10ff6:	605a      	str	r2, [r3, #4]
        SYSTICK->csr.bits.enable = 1;
   10ff8:	681a      	ldr	r2, [r3, #0]
   10ffa:	f042 0201 	orr.w	r2, r2, #1
   10ffe:	601a      	str	r2, [r3, #0]
  command bool Scheduler.runNextTask()
  {
    uint8_t nextTask;
    atomic
    {
      nextTask = popTask();
   11000:	47a0      	blx	r4
      if( nextTask == NO_TASK )
   11002:	28ff      	cmp	r0, #255	; 0xff
   11004:	d002      	beq.n	1100c <main+0xd4>
      {
	return FALSE;
      }
    }
    signal TaskBasic.runTask[nextTask]();
   11006:	4b67      	ldr	r3, [pc, #412]	; (111a4 <main+0x26c>)
   11008:	4798      	blx	r3
   1100a:	e7f9      	b.n	11000 <main+0xc8>
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   1100c:	f385 8810 	msr	PRIMASK, r5
// Enables all exceptions except hard fault and NMI
inline void __nesc_enable_interrupt() __attribute__((always_inline))
{
	__nesc_atomic_t newState = 0;

	asm volatile(
   11010:	2300      	movs	r3, #0
   11012:	f383 8810 	msr	PRIMASK, r3
        PORT->sters = MASK;
    }

	async command void IO.makeOutput()
	{
        PORT->gpers = MASK;
   11016:	4967      	ldr	r1, [pc, #412]	; (111b4 <main+0x27c>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   11018:	4e67      	ldr	r6, [pc, #412]	; (111b8 <main+0x280>)
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   1101a:	4868      	ldr	r0, [pc, #416]	; (111bc <main+0x284>)

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   1101c:	f8df a1d8 	ldr.w	sl, [pc, #472]	; 111f8 <main+0x2c0>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   11020:	f8df 81d8 	ldr.w	r8, [pc, #472]	; 111fc <main+0x2c4>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   11024:	f8df c1d8 	ldr.w	ip, [pc, #472]	; 11200 <main+0x2c8>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   11028:	f8df e1d8 	ldr.w	lr, [pc, #472]	; 11204 <main+0x2cc>
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   1102c:	4f64      	ldr	r7, [pc, #400]	; (111c0 <main+0x288>)
   1102e:	f44f 6380 	mov.w	r3, #1024	; 0x400
   11032:	604b      	str	r3, [r1, #4]
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   11034:	2200      	movs	r2, #0
        PORT->oders = MASK;
   11036:	644b      	str	r3, [r1, #68]	; 0x44
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   11038:	f44f 5500 	mov.w	r5, #8192	; 0x2000
        PORT->sterc = MASK;
   1103c:	f8c1 3168 	str.w	r3, [r1, #360]	; 0x168
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   11040:	f44f 4980 	mov.w	r9, #16384	; 0x4000
        PORT->ovrs = MASK;
	}

	async command void IO.clr()
	{
        PORT->ovrc = MASK;
   11044:	658b      	str	r3, [r1, #88]	; 0x58

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   11046:	f44f 5380 	mov.w	r3, #4096	; 0x1000
   1104a:	f8ca 3000 	str.w	r3, [sl]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   1104e:	f8c8 3000 	str.w	r3, [r8]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   11052:	f8cc 2000 	str.w	r2, [ip]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   11056:	f8ce 2000 	str.w	r2, [lr]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   1105a:	603d      	str	r5, [r7, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   1105c:	6032      	str	r2, [r6, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   1105e:	f8c0 9000 	str.w	r9, [r0]

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   11062:	f44f 6900 	mov.w	r9, #2048	; 0x800
   11066:	f8ca 9000 	str.w	r9, [sl]
   1106a:	f5a0 6086 	sub.w	r0, r0, #1072	; 0x430
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   1106e:	f8c8 9000 	str.w	r9, [r8]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   11072:	f8cc 2000 	str.w	r2, [ip]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   11076:	f8ce 2000 	str.w	r2, [lr]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   1107a:	603b      	str	r3, [r7, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   1107c:	6032      	str	r2, [r6, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   1107e:	f8c0 5430 	str.w	r5, [r0, #1072]	; 0x430

    async command void usart.enableUSARTPin(usart_pin_t pin)
    {
        //Vodoo incantation :-p
        //           GPIO BASE       PORT SIZE        REG      VALUE               PIN NUMBER
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
   11082:	f44f 2380 	mov.w	r3, #262144	; 0x40000
   11086:	6003      	str	r3, [r0, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
   11088:	60c2      	str	r2, [r0, #12]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
   1108a:	6103      	str	r3, [r0, #16]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
   1108c:	4b4d      	ldr	r3, [pc, #308]	; (111c4 <main+0x28c>)
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   1108e:	4d4e      	ldr	r5, [pc, #312]	; (111c8 <main+0x290>)
   11090:	601a      	str	r2, [r3, #0]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
   11092:	f44f 2000 	mov.w	r0, #524288	; 0x80000
   11096:	6058      	str	r0, [r3, #4]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   11098:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x008) = (1              << ((pin >> 8)&0xFF)); //GPERC
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x014) = ((pin & 1)      << ((pin >> 8)&0xFF)); //PMR0S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x018) = (((pin & 1)^1)  << ((pin >> 8)&0xFF)); //PMR0C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x024) = ((pin & 2)      << ((pin >> 8)&0xFF)); //PMR1S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x028) = (((pin & 2)^2)  << ((pin >> 8)&0xFF)); //PMR1C
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
   1109c:	611a      	str	r2, [r3, #16]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
   1109e:	6158      	str	r0, [r3, #20]

implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
   110a0:	4b4a      	ldr	r3, [pc, #296]	; (111cc <main+0x294>)
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   110a2:	4e4b      	ldr	r6, [pc, #300]	; (111d0 <main+0x298>)

implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
   110a4:	6818      	ldr	r0, [r3, #0]
        shadow |= 1<<bit;
        PM->unlock = PM_UNLOCK_KEY | offset;
   110a6:	65ee      	str	r6, [r5, #92]	; 0x5c
implementation
{
    async command void Cntl.enable()
    {
        uint32_t shadow = *((uint32_t volatile *)((void volatile *)PM + offset));
        shadow |= 1<<bit;
   110a8:	f440 6080 	orr.w	r0, r0, #1024	; 0x400
        PM->unlock = PM_UNLOCK_KEY | offset;
        *((uint32_t volatile *)((void volatile *)PM + offset)) = shadow;
   110ac:	6018      	str	r0, [r3, #0]
		USART->ttgr = 4; //Space between bytes: 4 bits
	}
	async command void usart.initSPIMaster()
	{
	    call ClockCtl.enable();
	    USART->mr.bits.chrl = 3; //8 bits
   110ae:	4b49      	ldr	r3, [pc, #292]	; (111d4 <main+0x29c>)
   110b0:	6858      	ldr	r0, [r3, #4]
   110b2:	f040 00c0 	orr.w	r0, r0, #192	; 0xc0
   110b6:	6058      	str	r0, [r3, #4]
	    USART->mr.bits.usclks = 0; //use clk_usart.
   110b8:	6858      	ldr	r0, [r3, #4]
   110ba:	f362 1005 	bfi	r0, r2, #4, #2
   110be:	6058      	str	r0, [r3, #4]
		USART->mr.bits.mode = 0b1110; //SPI Master
   110c0:	6858      	ldr	r0, [r3, #4]
   110c2:	250e      	movs	r5, #14
   110c4:	f365 0003 	bfi	r0, r5, #0, #4
   110c8:	6058      	str	r0, [r3, #4]
		USART->mr.bits.clko = 1;
   110ca:	6858      	ldr	r0, [r3, #4]
   110cc:	f440 2080 	orr.w	r0, r0, #262144	; 0x40000
   110d0:	6058      	str	r0, [r3, #4]
		USART->ttgr = 4;
   110d2:	2004      	movs	r0, #4
   110d4:	6298      	str	r0, [r3, #40]	; 0x28
    {
        USART->cr.bits.rtsdis_rcs = 1;
    }
    async command void usart.setSPIMode(uint8_t cpol, uint8_t cpha)
    {
        USART->mr.bits.msbf_cpol = (cpol != 0);
   110d6:	6858      	ldr	r0, [r3, #4]
   110d8:	f362 4010 	bfi	r0, r2, #16, #1
   110dc:	6058      	str	r0, [r3, #4]
        //ATMEL's definition of CPHA is different from everyone else, so we invert it.
        //Don't hate, appreciate.
        USART->mr.bits.sync_cpha = (cpha == 0);
   110de:	685a      	ldr	r2, [r3, #4]
   110e0:	f442 7280 	orr.w	r2, r2, #256	; 0x100
   110e4:	605a      	str	r2, [r3, #4]
	{
		//cd = clk / baud
		//   = gmclk*1000 / b
		uint32_t cd = (call MainClock.getMainClockSpeed())*1000;
		cd /= b;
		USART->brgr.bits.cd = cd;
   110e6:	6a1a      	ldr	r2, [r3, #32]
   110e8:	f44f 6016 	mov.w	r0, #2400	; 0x960
   110ec:	f360 020f 	bfi	r2, r0, #0, #16
   110f0:	621a      	str	r2, [r3, #32]
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x034) = ((pin & 4)      << ((pin >> 8)&0xFF)); //PMR2S
        *(uint32_t volatile*)(0x400E1000 + (pin >> 16)*0x200 + 0x038) = (((pin & 4)^4)  << ((pin >> 8)&0xFF)); //PMR2C
    }
    async command void usart.enableTX()
	{
		USART->cr.bits.txen = 1;
   110f2:	681a      	ldr	r2, [r3, #0]
   110f4:	f042 0240 	orr.w	r2, r2, #64	; 0x40
   110f8:	601a      	str	r2, [r3, #0]
	{
		USART->cr.bits.rsttx = 1;
	}
	async command void usart.enableRX()
	{
		USART->cr.bits.rxen = 1;
   110fa:	681a      	ldr	r2, [r3, #0]
   110fc:	f042 0210 	orr.w	r2, r2, #16
   11100:	601a      	str	r2, [r3, #0]
        PORT->sters = MASK;
    }

	async command void IO.makeOutput()
	{
        PORT->gpers = MASK;
   11102:	2380      	movs	r3, #128	; 0x80
   11104:	604b      	str	r3, [r1, #4]
        PORT->oders = MASK;
   11106:	644b      	str	r3, [r1, #68]	; 0x44
        PORT->sterc = MASK;
   11108:	f8c1 3168 	str.w	r3, [r1, #360]	; 0x168
        return (PORT->pvr & MASK) != 0;
	}

	async command void IO.set()
	{
        PORT->ovrs = MASK;
   1110c:	654b      	str	r3, [r1, #84]	; 0x54
        PORT->ovrt = MASK;
	}

	async command void IO.makeInput()
	{
        PORT->gpers = MASK;
   1110e:	4b32      	ldr	r3, [pc, #200]	; (111d8 <main+0x2a0>)
            call GPIOClock.disable();
        }
    }
    async command void PortA.enableIRQ(uint8_t bit)
    {
        NVIC->iser.flat[0] = 1 << (25 + (bit>>3));
   11110:	4932      	ldr	r1, [pc, #200]	; (111dc <main+0x2a4>)
   11112:	f44f 3200 	mov.w	r2, #131072	; 0x20000
   11116:	f04f 6000 	mov.w	r0, #134217728	; 0x8000000
   1111a:	605a      	str	r2, [r3, #4]
        PORT->oderc = MASK;
   1111c:	649a      	str	r2, [r3, #72]	; 0x48
        PORT->sters = MASK;
   1111e:	f8c3 2164 	str.w	r2, [r3, #356]	; 0x164
    {
        PORT->ifrc = MASK;
    }
    async command error_t IRQ.enableRisingEdge()
    {
        PORT->imr0s = MASK;
   11122:	f8c3 20a4 	str.w	r2, [r3, #164]	; 0xa4
        PORT->imr1c = MASK;
   11126:	f8c3 20b8 	str.w	r2, [r3, #184]	; 0xb8
   1112a:	6008      	str	r0, [r1, #0]
        GPIO_PORT_A->iers = 1 << bit;
   1112c:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
        call HplSam4lGeneralIOPort.enableIRQ(bit);
        return SUCCESS;
    }
    async command error_t IRQ.enableFallingEdge()
    {
        PORT->imr0c = MASK;
   11130:	f8c3 20a8 	str.w	r2, [r3, #168]	; 0xa8
        PORT->imr1s = MASK;
   11134:	f8c3 20b4 	str.w	r2, [r3, #180]	; 0xb4
            call GPIOClock.disable();
        }
    }
    async command void PortA.enableIRQ(uint8_t bit)
    {
        NVIC->iser.flat[0] = 1 << (25 + (bit>>3));
   11138:	6008      	str	r0, [r1, #0]
        GPIO_PORT_A->iers = 1 << bit;
   1113a:	f8c3 2094 	str.w	r2, [r3, #148]	; 0x94
    call CS.makeOutput();
    call CS.set();
    call IntPort.makeInput();
    call Int.enableRisingEdge();
    call Int.enableFallingEdge();
    txbuf[0] = 1;
   1113e:	4a28      	ldr	r2, [pc, #160]	; (111e0 <main+0x2a8>)
   11140:	2301      	movs	r3, #1
   11142:	7013      	strb	r3, [r2, #0]
    spiqueued = 1;
   11144:	4a27      	ldr	r2, [pc, #156]	; (111e4 <main+0x2ac>)
   11146:	7013      	strb	r3, [r2, #0]

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   11148:	2301      	movs	r3, #1
   1114a:	f3ef 8510 	mrs	r5, PRIMASK
   1114e:	f383 8810 	msr	PRIMASK, r3
    {
      uint8_t nextTask;

      atomic
      {
	while ((nextTask = popTask()) == NO_TASK)
   11152:	47a0      	blx	r4
   11154:	28ff      	cmp	r0, #255	; 0xff
   11156:	d10a      	bne.n	1116e <main+0x236>
  }

  async command void McuSleep.sleep()
  {
    commonSleep();
    switch(ps = getPowerState()) {
   11158:	4b23      	ldr	r3, [pc, #140]	; (111e8 <main+0x2b0>)
   1115a:	2202      	movs	r2, #2
   1115c:	601a      	str	r2, [r3, #0]
// Enables all exceptions except hard fault and NMI
inline void __nesc_enable_interrupt() __attribute__((always_inline))
{
	__nesc_atomic_t newState = 0;

	asm volatile(
   1115e:	2300      	movs	r3, #0
   11160:	f383 8810 	msr	PRIMASK, r3
     * We need to disable sleep while debugging. Else, the GDB connection gets
     * disconnected.
     */
    // Enter appropriate idle mode
    if(ps != S_AWAKE)
      __asm volatile ("wfe");
   11164:	bf20      	wfe
// Disables all exceptions except hard fault and NMI
inline void __nesc_disable_interrupt() __attribute__((always_inline))
{
	__nesc_atomic_t newState = 1;

	asm volatile(
   11166:	2301      	movs	r3, #1
   11168:	f383 8810 	msr	PRIMASK, r3
   1116c:	e7f1      	b.n	11152 <main+0x21a>
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   1116e:	f385 8810 	msr	PRIMASK, r5
	{
	  call McuSleep.sleep();
	}
      }
      signal TaskBasic.runTask[nextTask]();
   11172:	4b0c      	ldr	r3, [pc, #48]	; (111a4 <main+0x26c>)
   11174:	4798      	blx	r3
   11176:	e7e7      	b.n	11148 <main+0x210>
   11178:	00011981 	.word	0x00011981
   1117c:	20000042 	.word	0x20000042
   11180:	400e1224 	.word	0x400e1224
   11184:	400e1228 	.word	0x400e1228
   11188:	400e1234 	.word	0x400e1234
   1118c:	2000020a 	.word	0x2000020a
   11190:	400e1238 	.word	0x400e1238
   11194:	20000214 	.word	0x20000214
   11198:	00010801 	.word	0x00010801
   1119c:	40030000 	.word	0x40030000
   111a0:	000107bd 	.word	0x000107bd
   111a4:	00010c11 	.word	0x00010c11
   111a8:	20000054 	.word	0x20000054
   111ac:	e000e010 	.word	0xe000e010
   111b0:	20000210 	.word	0x20000210
   111b4:	400e1400 	.word	0x400e1400
   111b8:	400e1434 	.word	0x400e1434
   111bc:	400e1438 	.word	0x400e1438
   111c0:	400e1428 	.word	0x400e1428
   111c4:	400e1024 	.word	0x400e1024
   111c8:	400e0000 	.word	0x400e0000
   111cc:	400e0028 	.word	0x400e0028
   111d0:	aa000028 	.word	0xaa000028
   111d4:	4002c000 	.word	0x4002c000
   111d8:	400e1000 	.word	0x400e1000
   111dc:	e000e100 	.word	0xe000e100
   111e0:	200000b2 	.word	0x200000b2
   111e4:	20000034 	.word	0x20000034
   111e8:	2000020c 	.word	0x2000020c
   111ec:	400e1208 	.word	0x400e1208
   111f0:	400e1214 	.word	0x400e1214
   111f4:	400e1218 	.word	0x400e1218
   111f8:	400e1408 	.word	0x400e1408
   111fc:	400e1414 	.word	0x400e1414
   11200:	400e1418 	.word	0x400e1418
   11204:	400e1424 	.word	0x400e1424

00011208 <USART0_Handler>:
   11208:	4b44      	ldr	r3, [pc, #272]	; (1131c <USART0_Handler+0x114>)
    }
}
implementation
{
    void USART0_Handler() @C() @spontaneous()
    {
   1120a:	b570      	push	{r4, r5, r6, lr}
   1120c:	4798      	blx	r3
	{
	    return USART->csr.bits.txrdy == 1;
	}
	async command bool usart.isRXRdy()
	{
	    return USART->csr.bits.rxrdy == 1;
   1120e:	4b44      	ldr	r3, [pc, #272]	; (11320 <USART0_Handler+0x118>)
   11210:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart0.isRXRdy() && call usart0irq.isRXRdyIRQEnabled())
   11212:	07d1      	lsls	r1, r2, #31
   11214:	d52c      	bpl.n	11270 <USART0_Handler+0x68>
	{
	    USART0->idr.bits.rxrdy = 1;
	}
	async command bool usart0irq.isRXRdyIRQEnabled()
	{
	    return USART0->imr.bits.rxrdy == 1;
   11216:	691a      	ldr	r2, [r3, #16]
implementation
{
    void USART0_Handler() @C() @spontaneous()
    {
        call IRQWrapper.preamble();
        if (call usart0.isRXRdy() && call usart0irq.isRXRdyIRQEnabled())
   11218:	07d2      	lsls	r2, r2, #31
   1121a:	d529      	bpl.n	11270 <USART0_Handler+0x68>
		USART->mr.bits.clko = 1;
		USART->ttgr = 4;
	}
	async command uint8_t usart.readData()
	{
		return USART->rhr.bits.rxchr;
   1121c:	6998      	ldr	r0, [r3, #24]
    }

    async event void usart_irq.RXRdyFired()
    {
        uint8_t data = call usart.readData();
        if (!irqmode_spi)
   1121e:	4b41      	ldr	r3, [pc, #260]	; (11324 <USART0_Handler+0x11c>)
   11220:	7819      	ldrb	r1, [r3, #0]
   11222:	4b41      	ldr	r3, [pc, #260]	; (11328 <USART0_Handler+0x120>)
   11224:	b2c0      	uxtb	r0, r0
   11226:	b969      	cbnz	r1, 11244 <USART0_Handler+0x3c>
        {
            if (forwardRXIRQ)
            {
                signal UartStream.receivedByte(data);
            }
            if (rx_buf != NULL)
   11228:	681d      	ldr	r5, [r3, #0]
   1122a:	b30d      	cbz	r5, 11270 <USART0_Handler+0x68>
            {
                rx_buf[rx_ptr++] = data;
   1122c:	4a3f      	ldr	r2, [pc, #252]	; (1132c <USART0_Handler+0x124>)
   1122e:	8814      	ldrh	r4, [r2, #0]
   11230:	1c66      	adds	r6, r4, #1
   11232:	8016      	strh	r6, [r2, #0]
   11234:	5528      	strb	r0, [r5, r4]
                if (rx_ptr == rx_len)
   11236:	8810      	ldrh	r0, [r2, #0]
   11238:	4a3d      	ldr	r2, [pc, #244]	; (11330 <USART0_Handler+0x128>)
   1123a:	8812      	ldrh	r2, [r2, #0]
   1123c:	4290      	cmp	r0, r2
   1123e:	d117      	bne.n	11270 <USART0_Handler+0x68>
                {
                    uint8_t *bufcpy = rx_buf;
                    rx_buf = NULL;
   11240:	6019      	str	r1, [r3, #0]
   11242:	e015      	b.n	11270 <USART0_Handler+0x68>
                }
            }
        }
        else
        {
            if (rx_buf != NULL) rx_buf[rx_ptr] = data;
   11244:	6819      	ldr	r1, [r3, #0]
   11246:	4a39      	ldr	r2, [pc, #228]	; (1132c <USART0_Handler+0x124>)
   11248:	b109      	cbz	r1, 1124e <USART0_Handler+0x46>
   1124a:	8814      	ldrh	r4, [r2, #0]
   1124c:	5508      	strb	r0, [r1, r4]
            rx_ptr++;
   1124e:	8811      	ldrh	r1, [r2, #0]
   11250:	3101      	adds	r1, #1
   11252:	b289      	uxth	r1, r1
   11254:	8011      	strh	r1, [r2, #0]
            if (rx_ptr == tx_len)
   11256:	4a37      	ldr	r2, [pc, #220]	; (11334 <USART0_Handler+0x12c>)
   11258:	8812      	ldrh	r2, [r2, #0]
   1125a:	428a      	cmp	r2, r1
   1125c:	d108      	bne.n	11270 <USART0_Handler+0x68>
            {
                uint8_t *txbufcpy = tx_buf;
                uint8_t *rxbufcpy = rx_buf;
                rx_buf = NULL;
   1125e:	2200      	movs	r2, #0
   11260:	601a      	str	r2, [r3, #0]
                tx_buf = NULL;
   11262:	4b35      	ldr	r3, [pc, #212]	; (11338 <USART0_Handler+0x130>)
   11264:	601a      	str	r2, [r3, #0]
        enableUSART0IRQ();
	    USART0->ier.bits.rxrdy = 1;
	}
	async command void usart0irq.disableRXRdyIRQ()
	{
	    USART0->idr.bits.rxrdy = 1;
   11266:	4a2e      	ldr	r2, [pc, #184]	; (11320 <USART0_Handler+0x118>)
   11268:	68d3      	ldr	r3, [r2, #12]
   1126a:	f043 0301 	orr.w	r3, r3, #1
   1126e:	60d3      	str	r3, [r2, #12]
	{
		USART->thr.bits.txchr = d;
	}
	async command bool usart.isTXRdy()
	{
	    return USART->csr.bits.txrdy == 1;
   11270:	4b2b      	ldr	r3, [pc, #172]	; (11320 <USART0_Handler+0x118>)
   11272:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart0.isRXRdy() && call usart0irq.isRXRdyIRQEnabled())
        {
            signal usart0irq.RXRdyFired();
        }
        if (call usart0.isTXRdy() && call usart0irq.isTXRdyIRQEnabled())
   11274:	0796      	lsls	r6, r2, #30
   11276:	d54f      	bpl.n	11318 <USART0_Handler+0x110>
	{
	    return USART0->imr.bits.rxrdy == 1;
	}
	async command bool usart0irq.isTXRdyIRQEnabled()
	{
	    return USART0->imr.bits.txrdy == 1;
   11278:	691a      	ldr	r2, [r3, #16]
        call IRQWrapper.preamble();
        if (call usart0.isRXRdy() && call usart0irq.isRXRdyIRQEnabled())
        {
            signal usart0irq.RXRdyFired();
        }
        if (call usart0.isTXRdy() && call usart0irq.isTXRdyIRQEnabled())
   1127a:	0795      	lsls	r5, r2, #30
   1127c:	d54c      	bpl.n	11318 <USART0_Handler+0x110>
    default async event void UartStream.receiveDone( uint8_t* buf, uint16_t len, error_t error ){}
    default async event void UartStream.receivedByte( uint8_t byte ){}

    async event void usart_irq.TXRdyFired()
    {
        if (!irqmode_spi)
   1127e:	4a29      	ldr	r2, [pc, #164]	; (11324 <USART0_Handler+0x11c>)
   11280:	7811      	ldrb	r1, [r2, #0]
   11282:	4a2d      	ldr	r2, [pc, #180]	; (11338 <USART0_Handler+0x130>)
   11284:	bb19      	cbnz	r1, 112ce <USART0_Handler+0xc6>
        {
            if (tx_buf == NULL)
   11286:	6811      	ldr	r1, [r2, #0]
   11288:	b921      	cbnz	r1, 11294 <USART0_Handler+0x8c>
        enableUSART0IRQ();
        USART0->ier.bits.txrdy = 1;
    }
	async command void usart0irq.disableTXRdyIRQ()
	{
	    USART0->idr.bits.txrdy = 1;
   1128a:	68da      	ldr	r2, [r3, #12]
   1128c:	f042 0202 	orr.w	r2, r2, #2
   11290:	60da      	str	r2, [r3, #12]
   11292:	bd70      	pop	{r4, r5, r6, pc}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   11294:	2301      	movs	r3, #1
   11296:	f3ef 8010 	mrs	r0, PRIMASK
   1129a:	f383 8810 	msr	PRIMASK, r3
                return;
            }
            atomic
            {

                call usart.sendData(tx_buf[tx_ptr++]);
   1129e:	4927      	ldr	r1, [pc, #156]	; (1133c <USART0_Handler+0x134>)
   112a0:	6814      	ldr	r4, [r2, #0]
   112a2:	880b      	ldrh	r3, [r1, #0]
   112a4:	1c5a      	adds	r2, r3, #1
   112a6:	b292      	uxth	r2, r2
   112a8:	800a      	strh	r2, [r1, #0]
	{
		return USART->rhr.bits.rxchr;
	}
	async command void usart.sendData(uint8_t d)
	{
		USART->thr.bits.txchr = d;
   112aa:	5ce4      	ldrb	r4, [r4, r3]
   112ac:	4b1c      	ldr	r3, [pc, #112]	; (11320 <USART0_Handler+0x118>)
   112ae:	69d9      	ldr	r1, [r3, #28]
   112b0:	f364 0108 	bfi	r1, r4, #0, #9
   112b4:	61d9      	str	r1, [r3, #28]
                if (tx_ptr == tx_len)
   112b6:	491f      	ldr	r1, [pc, #124]	; (11334 <USART0_Handler+0x12c>)
   112b8:	8809      	ldrh	r1, [r1, #0]
   112ba:	4291      	cmp	r1, r2
   112bc:	d12a      	bne.n	11314 <USART0_Handler+0x10c>
                {
                    uint8_t * bufcpy;
                    bufcpy = tx_buf;
                    tx_buf = NULL;
   112be:	4a1e      	ldr	r2, [pc, #120]	; (11338 <USART0_Handler+0x130>)
   112c0:	2100      	movs	r1, #0
   112c2:	6011      	str	r1, [r2, #0]
   112c4:	68da      	ldr	r2, [r3, #12]
   112c6:	f042 0202 	orr.w	r2, r2, #2
   112ca:	60da      	str	r2, [r3, #12]
   112cc:	e022      	b.n	11314 <USART0_Handler+0x10c>
   112ce:	2301      	movs	r3, #1
   112d0:	f3ef 8010 	mrs	r0, PRIMASK
   112d4:	f383 8810 	msr	PRIMASK, r3
        }
        else
        {
            atomic
            {
                if (tx_buf == NULL)
   112d8:	6811      	ldr	r1, [r2, #0]
   112da:	4b18      	ldr	r3, [pc, #96]	; (1133c <USART0_Handler+0x134>)
   112dc:	4a10      	ldr	r2, [pc, #64]	; (11320 <USART0_Handler+0x118>)
   112de:	b939      	cbnz	r1, 112f0 <USART0_Handler+0xe8>
   112e0:	69d4      	ldr	r4, [r2, #28]
   112e2:	f361 0408 	bfi	r4, r1, #0, #9
   112e6:	61d4      	str	r4, [r2, #28]
                {
                    call usart.sendData(0);
                    tx_ptr++;
   112e8:	881a      	ldrh	r2, [r3, #0]
   112ea:	3201      	adds	r2, #1
   112ec:	801a      	strh	r2, [r3, #0]
   112ee:	e007      	b.n	11300 <USART0_Handler+0xf8>
                }
                else
                {
                    call usart.sendData(tx_buf[tx_ptr]);
   112f0:	881c      	ldrh	r4, [r3, #0]
   112f2:	5d0d      	ldrb	r5, [r1, r4]
   112f4:	69d1      	ldr	r1, [r2, #28]
                    tx_ptr++;
   112f6:	3401      	adds	r4, #1
   112f8:	f365 0108 	bfi	r1, r5, #0, #9
   112fc:	61d1      	str	r1, [r2, #28]
   112fe:	801c      	strh	r4, [r3, #0]
                }
                if (tx_ptr == tx_len)
   11300:	881a      	ldrh	r2, [r3, #0]
   11302:	4b0c      	ldr	r3, [pc, #48]	; (11334 <USART0_Handler+0x12c>)
   11304:	881b      	ldrh	r3, [r3, #0]
   11306:	429a      	cmp	r2, r3
   11308:	d104      	bne.n	11314 <USART0_Handler+0x10c>
   1130a:	4a05      	ldr	r2, [pc, #20]	; (11320 <USART0_Handler+0x118>)
   1130c:	68d3      	ldr	r3, [r2, #12]
   1130e:	f043 0302 	orr.w	r3, r3, #2
   11312:	60d3      	str	r3, [r2, #12]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   11314:	f380 8810 	msr	PRIMASK, r0
   11318:	bd70      	pop	{r4, r5, r6, pc}
   1131a:	bf00      	nop
   1131c:	000107e5 	.word	0x000107e5
   11320:	40024000 	.word	0x40024000
   11324:	20000009 	.word	0x20000009
   11328:	20000028 	.word	0x20000028
   1132c:	20000212 	.word	0x20000212
   11330:	20000056 	.word	0x20000056
   11334:	200000b0 	.word	0x200000b0
   11338:	20000020 	.word	0x20000020
   1133c:	2000003e 	.word	0x2000003e

00011340 <USART1_Handler>:
        }
        call IRQWrapper.postamble();
    }

    void USART1_Handler() @C() @spontaneous()
    {
   11340:	b570      	push	{r4, r5, r6, lr}
   11342:	4b44      	ldr	r3, [pc, #272]	; (11454 <USART1_Handler+0x114>)
   11344:	4798      	blx	r3
	{
	    return USART->csr.bits.txrdy == 1;
	}
	async command bool usart.isRXRdy()
	{
	    return USART->csr.bits.rxrdy == 1;
   11346:	4b44      	ldr	r3, [pc, #272]	; (11458 <USART1_Handler+0x118>)
   11348:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart1.isRXRdy() && call usart1irq.isRXRdyIRQEnabled())
   1134a:	07d6      	lsls	r6, r2, #31
   1134c:	d52c      	bpl.n	113a8 <USART1_Handler+0x68>
	{
	    USART1->idr.bits.rxrdy = 1;
	}
	async command bool usart1irq.isRXRdyIRQEnabled()
	{
	    return USART1->imr.bits.rxrdy == 1;
   1134e:	691a      	ldr	r2, [r3, #16]
    }

    void USART1_Handler() @C() @spontaneous()
    {
        call IRQWrapper.preamble();
        if (call usart1.isRXRdy() && call usart1irq.isRXRdyIRQEnabled())
   11350:	07d5      	lsls	r5, r2, #31
   11352:	d529      	bpl.n	113a8 <USART1_Handler+0x68>
		USART->mr.bits.clko = 1;
		USART->ttgr = 4;
	}
	async command uint8_t usart.readData()
	{
		return USART->rhr.bits.rxchr;
   11354:	6998      	ldr	r0, [r3, #24]
    }

    async event void usart_irq.RXRdyFired()
    {
        uint8_t data = call usart.readData();
        if (!irqmode_spi)
   11356:	4b41      	ldr	r3, [pc, #260]	; (1145c <USART1_Handler+0x11c>)
   11358:	7819      	ldrb	r1, [r3, #0]
   1135a:	4b41      	ldr	r3, [pc, #260]	; (11460 <USART1_Handler+0x120>)
   1135c:	b2c0      	uxtb	r0, r0
   1135e:	b969      	cbnz	r1, 1137c <USART1_Handler+0x3c>
        {
            if (forwardRXIRQ)
            {
                signal UartStream.receivedByte(data);
            }
            if (rx_buf != NULL)
   11360:	681d      	ldr	r5, [r3, #0]
   11362:	b30d      	cbz	r5, 113a8 <USART1_Handler+0x68>
            {
                rx_buf[rx_ptr++] = data;
   11364:	4a3f      	ldr	r2, [pc, #252]	; (11464 <USART1_Handler+0x124>)
   11366:	8814      	ldrh	r4, [r2, #0]
   11368:	1c66      	adds	r6, r4, #1
   1136a:	8016      	strh	r6, [r2, #0]
   1136c:	5528      	strb	r0, [r5, r4]
                if (rx_ptr == rx_len)
   1136e:	8810      	ldrh	r0, [r2, #0]
   11370:	4a3d      	ldr	r2, [pc, #244]	; (11468 <USART1_Handler+0x128>)
   11372:	8812      	ldrh	r2, [r2, #0]
   11374:	4290      	cmp	r0, r2
   11376:	d117      	bne.n	113a8 <USART1_Handler+0x68>
                {
                    uint8_t *bufcpy = rx_buf;
                    rx_buf = NULL;
   11378:	6019      	str	r1, [r3, #0]
   1137a:	e015      	b.n	113a8 <USART1_Handler+0x68>
                }
            }
        }
        else
        {
            if (rx_buf != NULL) rx_buf[rx_ptr] = data;
   1137c:	6819      	ldr	r1, [r3, #0]
   1137e:	4a39      	ldr	r2, [pc, #228]	; (11464 <USART1_Handler+0x124>)
   11380:	b109      	cbz	r1, 11386 <USART1_Handler+0x46>
   11382:	8814      	ldrh	r4, [r2, #0]
   11384:	5508      	strb	r0, [r1, r4]
            rx_ptr++;
   11386:	8811      	ldrh	r1, [r2, #0]
   11388:	3101      	adds	r1, #1
   1138a:	b289      	uxth	r1, r1
   1138c:	8011      	strh	r1, [r2, #0]
            if (rx_ptr == tx_len)
   1138e:	4a37      	ldr	r2, [pc, #220]	; (1146c <USART1_Handler+0x12c>)
   11390:	8812      	ldrh	r2, [r2, #0]
   11392:	428a      	cmp	r2, r1
   11394:	d108      	bne.n	113a8 <USART1_Handler+0x68>
            {
                uint8_t *txbufcpy = tx_buf;
                uint8_t *rxbufcpy = rx_buf;
                rx_buf = NULL;
   11396:	2200      	movs	r2, #0
   11398:	601a      	str	r2, [r3, #0]
                tx_buf = NULL;
   1139a:	4b35      	ldr	r3, [pc, #212]	; (11470 <USART1_Handler+0x130>)
   1139c:	601a      	str	r2, [r3, #0]
        enableUSART1IRQ();
	    USART1->ier.bits.rxrdy = 1;
	}
	async command void usart1irq.disableRXRdyIRQ()
	{
	    USART1->idr.bits.rxrdy = 1;
   1139e:	4a2e      	ldr	r2, [pc, #184]	; (11458 <USART1_Handler+0x118>)
   113a0:	68d3      	ldr	r3, [r2, #12]
   113a2:	f043 0301 	orr.w	r3, r3, #1
   113a6:	60d3      	str	r3, [r2, #12]
	{
		USART->thr.bits.txchr = d;
	}
	async command bool usart.isTXRdy()
	{
	    return USART->csr.bits.txrdy == 1;
   113a8:	4b2b      	ldr	r3, [pc, #172]	; (11458 <USART1_Handler+0x118>)
   113aa:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart1.isRXRdy() && call usart1irq.isRXRdyIRQEnabled())
        {
            signal usart1irq.RXRdyFired();
        }
        if (call usart1.isTXRdy() && call usart1irq.isTXRdyIRQEnabled())
   113ac:	0794      	lsls	r4, r2, #30
   113ae:	d54f      	bpl.n	11450 <USART1_Handler+0x110>
	{
	    return USART1->imr.bits.rxrdy == 1;
	}
	async command bool usart1irq.isTXRdyIRQEnabled()
	{
	    return USART1->imr.bits.txrdy == 1;
   113b0:	691a      	ldr	r2, [r3, #16]
        call IRQWrapper.preamble();
        if (call usart1.isRXRdy() && call usart1irq.isRXRdyIRQEnabled())
        {
            signal usart1irq.RXRdyFired();
        }
        if (call usart1.isTXRdy() && call usart1irq.isTXRdyIRQEnabled())
   113b2:	0790      	lsls	r0, r2, #30
   113b4:	d54c      	bpl.n	11450 <USART1_Handler+0x110>
    default async event void UartStream.receiveDone( uint8_t* buf, uint16_t len, error_t error ){}
    default async event void UartStream.receivedByte( uint8_t byte ){}

    async event void usart_irq.TXRdyFired()
    {
        if (!irqmode_spi)
   113b6:	4a29      	ldr	r2, [pc, #164]	; (1145c <USART1_Handler+0x11c>)
   113b8:	7811      	ldrb	r1, [r2, #0]
   113ba:	4a2d      	ldr	r2, [pc, #180]	; (11470 <USART1_Handler+0x130>)
   113bc:	bb19      	cbnz	r1, 11406 <USART1_Handler+0xc6>
        {
            if (tx_buf == NULL)
   113be:	6811      	ldr	r1, [r2, #0]
   113c0:	b921      	cbnz	r1, 113cc <USART1_Handler+0x8c>
        enableUSART1IRQ();
        USART1->ier.bits.txrdy = 1;
    }
	async command void usart1irq.disableTXRdyIRQ()
	{
	    USART1->idr.bits.txrdy = 1;
   113c2:	68da      	ldr	r2, [r3, #12]
   113c4:	f042 0202 	orr.w	r2, r2, #2
   113c8:	60da      	str	r2, [r3, #12]
   113ca:	bd70      	pop	{r4, r5, r6, pc}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   113cc:	2301      	movs	r3, #1
   113ce:	f3ef 8010 	mrs	r0, PRIMASK
   113d2:	f383 8810 	msr	PRIMASK, r3
                return;
            }
            atomic
            {

                call usart.sendData(tx_buf[tx_ptr++]);
   113d6:	4927      	ldr	r1, [pc, #156]	; (11474 <USART1_Handler+0x134>)
   113d8:	6814      	ldr	r4, [r2, #0]
   113da:	880b      	ldrh	r3, [r1, #0]
   113dc:	1c5a      	adds	r2, r3, #1
   113de:	b292      	uxth	r2, r2
   113e0:	800a      	strh	r2, [r1, #0]
	{
		return USART->rhr.bits.rxchr;
	}
	async command void usart.sendData(uint8_t d)
	{
		USART->thr.bits.txchr = d;
   113e2:	5ce4      	ldrb	r4, [r4, r3]
   113e4:	4b1c      	ldr	r3, [pc, #112]	; (11458 <USART1_Handler+0x118>)
   113e6:	69d9      	ldr	r1, [r3, #28]
   113e8:	f364 0108 	bfi	r1, r4, #0, #9
   113ec:	61d9      	str	r1, [r3, #28]
                if (tx_ptr == tx_len)
   113ee:	491f      	ldr	r1, [pc, #124]	; (1146c <USART1_Handler+0x12c>)
   113f0:	8809      	ldrh	r1, [r1, #0]
   113f2:	4291      	cmp	r1, r2
   113f4:	d12a      	bne.n	1144c <USART1_Handler+0x10c>
                {
                    uint8_t * bufcpy;
                    bufcpy = tx_buf;
                    tx_buf = NULL;
   113f6:	4a1e      	ldr	r2, [pc, #120]	; (11470 <USART1_Handler+0x130>)
   113f8:	2100      	movs	r1, #0
   113fa:	6011      	str	r1, [r2, #0]
   113fc:	68da      	ldr	r2, [r3, #12]
   113fe:	f042 0202 	orr.w	r2, r2, #2
   11402:	60da      	str	r2, [r3, #12]
   11404:	e022      	b.n	1144c <USART1_Handler+0x10c>
   11406:	2301      	movs	r3, #1
   11408:	f3ef 8010 	mrs	r0, PRIMASK
   1140c:	f383 8810 	msr	PRIMASK, r3
        }
        else
        {
            atomic
            {
                if (tx_buf == NULL)
   11410:	6811      	ldr	r1, [r2, #0]
   11412:	4b18      	ldr	r3, [pc, #96]	; (11474 <USART1_Handler+0x134>)
   11414:	4a10      	ldr	r2, [pc, #64]	; (11458 <USART1_Handler+0x118>)
   11416:	b939      	cbnz	r1, 11428 <USART1_Handler+0xe8>
   11418:	69d4      	ldr	r4, [r2, #28]
   1141a:	f361 0408 	bfi	r4, r1, #0, #9
   1141e:	61d4      	str	r4, [r2, #28]
                {
                    call usart.sendData(0);
                    tx_ptr++;
   11420:	881a      	ldrh	r2, [r3, #0]
   11422:	3201      	adds	r2, #1
   11424:	801a      	strh	r2, [r3, #0]
   11426:	e007      	b.n	11438 <USART1_Handler+0xf8>
                }
                else
                {
                    call usart.sendData(tx_buf[tx_ptr]);
   11428:	881c      	ldrh	r4, [r3, #0]
   1142a:	5d0d      	ldrb	r5, [r1, r4]
   1142c:	69d1      	ldr	r1, [r2, #28]
                    tx_ptr++;
   1142e:	3401      	adds	r4, #1
   11430:	f365 0108 	bfi	r1, r5, #0, #9
   11434:	61d1      	str	r1, [r2, #28]
   11436:	801c      	strh	r4, [r3, #0]
                }
                if (tx_ptr == tx_len)
   11438:	881a      	ldrh	r2, [r3, #0]
   1143a:	4b0c      	ldr	r3, [pc, #48]	; (1146c <USART1_Handler+0x12c>)
   1143c:	881b      	ldrh	r3, [r3, #0]
   1143e:	429a      	cmp	r2, r3
   11440:	d104      	bne.n	1144c <USART1_Handler+0x10c>
   11442:	4a05      	ldr	r2, [pc, #20]	; (11458 <USART1_Handler+0x118>)
   11444:	68d3      	ldr	r3, [r2, #12]
   11446:	f043 0302 	orr.w	r3, r3, #2
   1144a:	60d3      	str	r3, [r2, #12]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   1144c:	f380 8810 	msr	PRIMASK, r0
   11450:	bd70      	pop	{r4, r5, r6, pc}
   11452:	bf00      	nop
   11454:	000107e5 	.word	0x000107e5
   11458:	40028000 	.word	0x40028000
   1145c:	2000000c 	.word	0x2000000c
   11460:	20000004 	.word	0x20000004
   11464:	20000040 	.word	0x20000040
   11468:	20000050 	.word	0x20000050
   1146c:	2000005a 	.word	0x2000005a
   11470:	20000038 	.word	0x20000038
   11474:	2000004e 	.word	0x2000004e

00011478 <USART2_Handler>:
        }
        call IRQWrapper.postamble();
    }

    void USART2_Handler() @C() @spontaneous()
    {
   11478:	b570      	push	{r4, r5, r6, lr}
   1147a:	4b4b      	ldr	r3, [pc, #300]	; (115a8 <USART2_Handler+0x130>)
   1147c:	4798      	blx	r3
	{
	    return USART->csr.bits.txrdy == 1;
	}
	async command bool usart.isRXRdy()
	{
	    return USART->csr.bits.rxrdy == 1;
   1147e:	4b4b      	ldr	r3, [pc, #300]	; (115ac <USART2_Handler+0x134>)
   11480:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart2.isRXRdy() && call usart2irq.isRXRdyIRQEnabled())
   11482:	07d6      	lsls	r6, r2, #31
   11484:	d53b      	bpl.n	114fe <USART2_Handler+0x86>
	{
	    USART2->idr.bits.rxrdy = 1;
	}
	async command bool usart2irq.isRXRdyIRQEnabled()
	{
	    return USART2->imr.bits.rxrdy == 1;
   11486:	691a      	ldr	r2, [r3, #16]
    }

    void USART2_Handler() @C() @spontaneous()
    {
        call IRQWrapper.preamble();
        if (call usart2.isRXRdy() && call usart2irq.isRXRdyIRQEnabled())
   11488:	07d5      	lsls	r5, r2, #31
   1148a:	d538      	bpl.n	114fe <USART2_Handler+0x86>
		USART->mr.bits.clko = 1;
		USART->ttgr = 4;
	}
	async command uint8_t usart.readData()
	{
		return USART->rhr.bits.rxchr;
   1148c:	6998      	ldr	r0, [r3, #24]
    }

    async event void usart_irq.RXRdyFired()
    {
        uint8_t data = call usart.readData();
        if (!irqmode_spi)
   1148e:	4b48      	ldr	r3, [pc, #288]	; (115b0 <USART2_Handler+0x138>)
   11490:	7819      	ldrb	r1, [r3, #0]
   11492:	4b48      	ldr	r3, [pc, #288]	; (115b4 <USART2_Handler+0x13c>)
   11494:	b2c0      	uxtb	r0, r0
   11496:	b971      	cbnz	r1, 114b6 <USART2_Handler+0x3e>
        {
            if (forwardRXIRQ)
            {
                signal UartStream.receivedByte(data);
            }
            if (rx_buf != NULL)
   11498:	681d      	ldr	r5, [r3, #0]
   1149a:	2d00      	cmp	r5, #0
   1149c:	d02f      	beq.n	114fe <USART2_Handler+0x86>
            {
                rx_buf[rx_ptr++] = data;
   1149e:	4a46      	ldr	r2, [pc, #280]	; (115b8 <USART2_Handler+0x140>)
   114a0:	8814      	ldrh	r4, [r2, #0]
   114a2:	1c66      	adds	r6, r4, #1
   114a4:	8016      	strh	r6, [r2, #0]
   114a6:	5528      	strb	r0, [r5, r4]
                if (rx_ptr == rx_len)
   114a8:	8810      	ldrh	r0, [r2, #0]
   114aa:	4a44      	ldr	r2, [pc, #272]	; (115bc <USART2_Handler+0x144>)
   114ac:	8812      	ldrh	r2, [r2, #0]
   114ae:	4290      	cmp	r0, r2
   114b0:	d125      	bne.n	114fe <USART2_Handler+0x86>
                {
                    uint8_t *bufcpy = rx_buf;
                    rx_buf = NULL;
   114b2:	6019      	str	r1, [r3, #0]
   114b4:	e023      	b.n	114fe <USART2_Handler+0x86>
                }
            }
        }
        else
        {
            if (rx_buf != NULL) rx_buf[rx_ptr] = data;
   114b6:	6819      	ldr	r1, [r3, #0]
   114b8:	4a3f      	ldr	r2, [pc, #252]	; (115b8 <USART2_Handler+0x140>)
   114ba:	b109      	cbz	r1, 114c0 <USART2_Handler+0x48>
   114bc:	8814      	ldrh	r4, [r2, #0]
   114be:	5508      	strb	r0, [r1, r4]
            rx_ptr++;
   114c0:	8811      	ldrh	r1, [r2, #0]
   114c2:	3101      	adds	r1, #1
   114c4:	b289      	uxth	r1, r1
   114c6:	8011      	strh	r1, [r2, #0]
            if (rx_ptr == tx_len)
   114c8:	4a3d      	ldr	r2, [pc, #244]	; (115c0 <USART2_Handler+0x148>)
   114ca:	8812      	ldrh	r2, [r2, #0]
   114cc:	428a      	cmp	r2, r1
   114ce:	d116      	bne.n	114fe <USART2_Handler+0x86>
            {
                uint8_t *txbufcpy = tx_buf;
                uint8_t *rxbufcpy = rx_buf;
                rx_buf = NULL;
   114d0:	2000      	movs	r0, #0
            if (rx_buf != NULL) rx_buf[rx_ptr] = data;
            rx_ptr++;
            if (rx_ptr == tx_len)
            {
                uint8_t *txbufcpy = tx_buf;
                uint8_t *rxbufcpy = rx_buf;
   114d2:	6819      	ldr	r1, [r3, #0]
                rx_buf = NULL;
   114d4:	6018      	str	r0, [r3, #0]
                tx_buf = NULL;
   114d6:	4b3b      	ldr	r3, [pc, #236]	; (115c4 <USART2_Handler+0x14c>)
        enableUSART2IRQ();
	    USART2->ier.bits.rxrdy = 1;
	}
	async command void usart2irq.disableRXRdyIRQ()
	{
	    USART2->idr.bits.rxrdy = 1;
   114d8:	4a34      	ldr	r2, [pc, #208]	; (115ac <USART2_Handler+0x134>)
   114da:	6018      	str	r0, [r3, #0]
   114dc:	68d3      	ldr	r3, [r2, #12]
   114de:	f043 0301 	orr.w	r3, r3, #1
   114e2:	60d3      	str	r3, [r2, #12]
        return (PORT->pvr & MASK) != 0;
	}

	async command void IO.set()
	{
        PORT->ovrs = MASK;
   114e4:	4b38      	ldr	r3, [pc, #224]	; (115c8 <USART2_Handler+0x150>)
   114e6:	2280      	movs	r2, #128	; 0x80
   114e8:	655a      	str	r2, [r3, #84]	; 0x54

  async event void SpiPacket.sendDone(uint8_t* txBuf, uint8_t* rxBuf,
                                      uint16_t len, error_t error) {
    call CS.set();
    if (error == SUCCESS) {
      if (rxBuf[0] & 0x1) { // Odd opcode for notifications
   114ea:	780b      	ldrb	r3, [r1, #0]
   114ec:	07dc      	lsls	r4, r3, #31
   114ee:	d506      	bpl.n	114fe <USART2_Handler+0x86>
        switch (rxBuf[0]) {
   114f0:	2b01      	cmp	r3, #1
   114f2:	d002      	beq.n	114fa <USART2_Handler+0x82>
   114f4:	2b03      	cmp	r3, #3
   114f6:	d102      	bne.n	114fe <USART2_Handler+0x86>
   * @return SUCCESS if task was successfuly
   * posted; the semantics of a non-SUCCESS return value depend on the
   * implementation of this interface (the class of task).
   */
  
  async command error_t postTask();
   114f8:	2001      	movs	r0, #1
   114fa:	4b34      	ldr	r3, [pc, #208]	; (115cc <USART2_Handler+0x154>)
   114fc:	4798      	blx	r3
	{
		USART->thr.bits.txchr = d;
	}
	async command bool usart.isTXRdy()
	{
	    return USART->csr.bits.txrdy == 1;
   114fe:	4b2b      	ldr	r3, [pc, #172]	; (115ac <USART2_Handler+0x134>)
   11500:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart2.isRXRdy() && call usart2irq.isRXRdyIRQEnabled())
        {
            signal usart2irq.RXRdyFired();
        }
        if (call usart2.isTXRdy() && call usart2irq.isTXRdyIRQEnabled())
   11502:	0791      	lsls	r1, r2, #30
   11504:	d54f      	bpl.n	115a6 <USART2_Handler+0x12e>
	{
	    return USART2->imr.bits.rxrdy == 1;
	}
	async command bool usart2irq.isTXRdyIRQEnabled()
	{
	    return USART2->imr.bits.txrdy == 1;
   11506:	691a      	ldr	r2, [r3, #16]
        call IRQWrapper.preamble();
        if (call usart2.isRXRdy() && call usart2irq.isRXRdyIRQEnabled())
        {
            signal usart2irq.RXRdyFired();
        }
        if (call usart2.isTXRdy() && call usart2irq.isTXRdyIRQEnabled())
   11508:	0792      	lsls	r2, r2, #30
   1150a:	d54c      	bpl.n	115a6 <USART2_Handler+0x12e>
    default async event void UartStream.receiveDone( uint8_t* buf, uint16_t len, error_t error ){}
    default async event void UartStream.receivedByte( uint8_t byte ){}

    async event void usart_irq.TXRdyFired()
    {
        if (!irqmode_spi)
   1150c:	4a28      	ldr	r2, [pc, #160]	; (115b0 <USART2_Handler+0x138>)
   1150e:	7811      	ldrb	r1, [r2, #0]
   11510:	4a2c      	ldr	r2, [pc, #176]	; (115c4 <USART2_Handler+0x14c>)
   11512:	bb19      	cbnz	r1, 1155c <USART2_Handler+0xe4>
        {
            if (tx_buf == NULL)
   11514:	6811      	ldr	r1, [r2, #0]
   11516:	b921      	cbnz	r1, 11522 <USART2_Handler+0xaa>
        enableUSART2IRQ();
        USART2->ier.bits.txrdy = 1;
    }
	async command void usart2irq.disableTXRdyIRQ()
	{
	    USART2->idr.bits.txrdy = 1;
   11518:	68da      	ldr	r2, [r3, #12]
   1151a:	f042 0202 	orr.w	r2, r2, #2
   1151e:	60da      	str	r2, [r3, #12]
   11520:	bd70      	pop	{r4, r5, r6, pc}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   11522:	2301      	movs	r3, #1
   11524:	f3ef 8010 	mrs	r0, PRIMASK
   11528:	f383 8810 	msr	PRIMASK, r3
                return;
            }
            atomic
            {

                call usart.sendData(tx_buf[tx_ptr++]);
   1152c:	4928      	ldr	r1, [pc, #160]	; (115d0 <USART2_Handler+0x158>)
   1152e:	6814      	ldr	r4, [r2, #0]
   11530:	880b      	ldrh	r3, [r1, #0]
   11532:	1c5a      	adds	r2, r3, #1
   11534:	b292      	uxth	r2, r2
   11536:	800a      	strh	r2, [r1, #0]
	{
		return USART->rhr.bits.rxchr;
	}
	async command void usart.sendData(uint8_t d)
	{
		USART->thr.bits.txchr = d;
   11538:	5ce4      	ldrb	r4, [r4, r3]
   1153a:	4b1c      	ldr	r3, [pc, #112]	; (115ac <USART2_Handler+0x134>)
   1153c:	69d9      	ldr	r1, [r3, #28]
   1153e:	f364 0108 	bfi	r1, r4, #0, #9
   11542:	61d9      	str	r1, [r3, #28]
                if (tx_ptr == tx_len)
   11544:	491e      	ldr	r1, [pc, #120]	; (115c0 <USART2_Handler+0x148>)
   11546:	8809      	ldrh	r1, [r1, #0]
   11548:	4291      	cmp	r1, r2
   1154a:	d12a      	bne.n	115a2 <USART2_Handler+0x12a>
                {
                    uint8_t * bufcpy;
                    bufcpy = tx_buf;
                    tx_buf = NULL;
   1154c:	4a1d      	ldr	r2, [pc, #116]	; (115c4 <USART2_Handler+0x14c>)
   1154e:	2100      	movs	r1, #0
   11550:	6011      	str	r1, [r2, #0]
   11552:	68da      	ldr	r2, [r3, #12]
   11554:	f042 0202 	orr.w	r2, r2, #2
   11558:	60da      	str	r2, [r3, #12]
   1155a:	e022      	b.n	115a2 <USART2_Handler+0x12a>
   1155c:	2301      	movs	r3, #1
   1155e:	f3ef 8010 	mrs	r0, PRIMASK
   11562:	f383 8810 	msr	PRIMASK, r3
        }
        else
        {
            atomic
            {
                if (tx_buf == NULL)
   11566:	6811      	ldr	r1, [r2, #0]
   11568:	4b19      	ldr	r3, [pc, #100]	; (115d0 <USART2_Handler+0x158>)
   1156a:	4a10      	ldr	r2, [pc, #64]	; (115ac <USART2_Handler+0x134>)
   1156c:	b939      	cbnz	r1, 1157e <USART2_Handler+0x106>
   1156e:	69d4      	ldr	r4, [r2, #28]
   11570:	f361 0408 	bfi	r4, r1, #0, #9
   11574:	61d4      	str	r4, [r2, #28]
                {
                    call usart.sendData(0);
                    tx_ptr++;
   11576:	881a      	ldrh	r2, [r3, #0]
   11578:	3201      	adds	r2, #1
   1157a:	801a      	strh	r2, [r3, #0]
   1157c:	e007      	b.n	1158e <USART2_Handler+0x116>
                }
                else
                {
                    call usart.sendData(tx_buf[tx_ptr]);
   1157e:	881c      	ldrh	r4, [r3, #0]
   11580:	5d0d      	ldrb	r5, [r1, r4]
   11582:	69d1      	ldr	r1, [r2, #28]
                    tx_ptr++;
   11584:	3401      	adds	r4, #1
   11586:	f365 0108 	bfi	r1, r5, #0, #9
   1158a:	61d1      	str	r1, [r2, #28]
   1158c:	801c      	strh	r4, [r3, #0]
                }
                if (tx_ptr == tx_len)
   1158e:	881a      	ldrh	r2, [r3, #0]
   11590:	4b0b      	ldr	r3, [pc, #44]	; (115c0 <USART2_Handler+0x148>)
   11592:	881b      	ldrh	r3, [r3, #0]
   11594:	429a      	cmp	r2, r3
   11596:	d104      	bne.n	115a2 <USART2_Handler+0x12a>
   11598:	4a04      	ldr	r2, [pc, #16]	; (115ac <USART2_Handler+0x134>)
   1159a:	68d3      	ldr	r3, [r2, #12]
   1159c:	f043 0302 	orr.w	r3, r3, #2
   115a0:	60d3      	str	r3, [r2, #12]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   115a2:	f380 8810 	msr	PRIMASK, r0
   115a6:	bd70      	pop	{r4, r5, r6, pc}
   115a8:	000107e5 	.word	0x000107e5
   115ac:	4002c000 	.word	0x4002c000
   115b0:	2000001c 	.word	0x2000001c
   115b4:	20000018 	.word	0x20000018
   115b8:	2000004c 	.word	0x2000004c
   115bc:	2000005c 	.word	0x2000005c
   115c0:	2000004a 	.word	0x2000004a
   115c4:	20000010 	.word	0x20000010
   115c8:	400e1400 	.word	0x400e1400
   115cc:	00010851 	.word	0x00010851
   115d0:	20000208 	.word	0x20000208

000115d4 <USART3_Handler>:
        }
        call IRQWrapper.postamble();
    }

    void USART3_Handler() @C() @spontaneous()
    {
   115d4:	b570      	push	{r4, r5, r6, lr}
   115d6:	4b44      	ldr	r3, [pc, #272]	; (116e8 <USART3_Handler+0x114>)
   115d8:	4798      	blx	r3
	{
	    return USART->csr.bits.txrdy == 1;
	}
	async command bool usart.isRXRdy()
	{
	    return USART->csr.bits.rxrdy == 1;
   115da:	4b44      	ldr	r3, [pc, #272]	; (116ec <USART3_Handler+0x118>)
   115dc:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart3.isRXRdy() && call usart3irq.isRXRdyIRQEnabled())
   115de:	07d4      	lsls	r4, r2, #31
   115e0:	d52c      	bpl.n	1163c <USART3_Handler+0x68>
	{
	    USART3->idr.bits.rxrdy = 1;
	}
	async command bool usart3irq.isRXRdyIRQEnabled()
	{
	    return USART3->imr.bits.rxrdy == 1;
   115e2:	691a      	ldr	r2, [r3, #16]
    }

    void USART3_Handler() @C() @spontaneous()
    {
        call IRQWrapper.preamble();
        if (call usart3.isRXRdy() && call usart3irq.isRXRdyIRQEnabled())
   115e4:	07d0      	lsls	r0, r2, #31
   115e6:	d529      	bpl.n	1163c <USART3_Handler+0x68>
		USART->mr.bits.clko = 1;
		USART->ttgr = 4;
	}
	async command uint8_t usart.readData()
	{
		return USART->rhr.bits.rxchr;
   115e8:	6998      	ldr	r0, [r3, #24]
    }

    async event void usart_irq.RXRdyFired()
    {
        uint8_t data = call usart.readData();
        if (!irqmode_spi)
   115ea:	4b41      	ldr	r3, [pc, #260]	; (116f0 <USART3_Handler+0x11c>)
   115ec:	7819      	ldrb	r1, [r3, #0]
   115ee:	4b41      	ldr	r3, [pc, #260]	; (116f4 <USART3_Handler+0x120>)
   115f0:	b2c0      	uxtb	r0, r0
   115f2:	b969      	cbnz	r1, 11610 <USART3_Handler+0x3c>
        {
            if (forwardRXIRQ)
            {
                signal UartStream.receivedByte(data);
            }
            if (rx_buf != NULL)
   115f4:	681d      	ldr	r5, [r3, #0]
   115f6:	b30d      	cbz	r5, 1163c <USART3_Handler+0x68>
            {
                rx_buf[rx_ptr++] = data;
   115f8:	4a3f      	ldr	r2, [pc, #252]	; (116f8 <USART3_Handler+0x124>)
   115fa:	8814      	ldrh	r4, [r2, #0]
   115fc:	1c66      	adds	r6, r4, #1
   115fe:	8016      	strh	r6, [r2, #0]
   11600:	5528      	strb	r0, [r5, r4]
                if (rx_ptr == rx_len)
   11602:	8810      	ldrh	r0, [r2, #0]
   11604:	4a3d      	ldr	r2, [pc, #244]	; (116fc <USART3_Handler+0x128>)
   11606:	8812      	ldrh	r2, [r2, #0]
   11608:	4290      	cmp	r0, r2
   1160a:	d117      	bne.n	1163c <USART3_Handler+0x68>
                {
                    uint8_t *bufcpy = rx_buf;
                    rx_buf = NULL;
   1160c:	6019      	str	r1, [r3, #0]
   1160e:	e015      	b.n	1163c <USART3_Handler+0x68>
                }
            }
        }
        else
        {
            if (rx_buf != NULL) rx_buf[rx_ptr] = data;
   11610:	6819      	ldr	r1, [r3, #0]
   11612:	4a39      	ldr	r2, [pc, #228]	; (116f8 <USART3_Handler+0x124>)
   11614:	b109      	cbz	r1, 1161a <USART3_Handler+0x46>
   11616:	8814      	ldrh	r4, [r2, #0]
   11618:	5508      	strb	r0, [r1, r4]
            rx_ptr++;
   1161a:	8811      	ldrh	r1, [r2, #0]
   1161c:	3101      	adds	r1, #1
   1161e:	b289      	uxth	r1, r1
   11620:	8011      	strh	r1, [r2, #0]
            if (rx_ptr == tx_len)
   11622:	4a37      	ldr	r2, [pc, #220]	; (11700 <USART3_Handler+0x12c>)
   11624:	8812      	ldrh	r2, [r2, #0]
   11626:	428a      	cmp	r2, r1
   11628:	d108      	bne.n	1163c <USART3_Handler+0x68>
            {
                uint8_t *txbufcpy = tx_buf;
                uint8_t *rxbufcpy = rx_buf;
                rx_buf = NULL;
   1162a:	2200      	movs	r2, #0
   1162c:	601a      	str	r2, [r3, #0]
                tx_buf = NULL;
   1162e:	4b35      	ldr	r3, [pc, #212]	; (11704 <USART3_Handler+0x130>)
   11630:	601a      	str	r2, [r3, #0]
        enableUSART3IRQ();
	    USART3->ier.bits.rxrdy = 1;
	}
	async command void usart3irq.disableRXRdyIRQ()
	{
	    USART3->idr.bits.rxrdy = 1;
   11632:	4a2e      	ldr	r2, [pc, #184]	; (116ec <USART3_Handler+0x118>)
   11634:	68d3      	ldr	r3, [r2, #12]
   11636:	f043 0301 	orr.w	r3, r3, #1
   1163a:	60d3      	str	r3, [r2, #12]
	{
		USART->thr.bits.txchr = d;
	}
	async command bool usart.isTXRdy()
	{
	    return USART->csr.bits.txrdy == 1;
   1163c:	4b2b      	ldr	r3, [pc, #172]	; (116ec <USART3_Handler+0x118>)
   1163e:	695a      	ldr	r2, [r3, #20]
        call IRQWrapper.preamble();
        if (call usart3.isRXRdy() && call usart3irq.isRXRdyIRQEnabled())
        {
            signal usart3irq.RXRdyFired();
        }
        if (call usart3.isTXRdy() && call usart3irq.isTXRdyIRQEnabled())
   11640:	0791      	lsls	r1, r2, #30
   11642:	d54f      	bpl.n	116e4 <USART3_Handler+0x110>
	{
	    return USART3->imr.bits.rxrdy == 1;
	}
	async command bool usart3irq.isTXRdyIRQEnabled()
	{
	    return USART3->imr.bits.txrdy == 1;
   11644:	691a      	ldr	r2, [r3, #16]
        call IRQWrapper.preamble();
        if (call usart3.isRXRdy() && call usart3irq.isRXRdyIRQEnabled())
        {
            signal usart3irq.RXRdyFired();
        }
        if (call usart3.isTXRdy() && call usart3irq.isTXRdyIRQEnabled())
   11646:	0792      	lsls	r2, r2, #30
   11648:	d54c      	bpl.n	116e4 <USART3_Handler+0x110>
    default async event void UartStream.receiveDone( uint8_t* buf, uint16_t len, error_t error ){}
    default async event void UartStream.receivedByte( uint8_t byte ){}

    async event void usart_irq.TXRdyFired()
    {
        if (!irqmode_spi)
   1164a:	4a29      	ldr	r2, [pc, #164]	; (116f0 <USART3_Handler+0x11c>)
   1164c:	7811      	ldrb	r1, [r2, #0]
   1164e:	4a2d      	ldr	r2, [pc, #180]	; (11704 <USART3_Handler+0x130>)
   11650:	bb19      	cbnz	r1, 1169a <USART3_Handler+0xc6>
        {
            if (tx_buf == NULL)
   11652:	6811      	ldr	r1, [r2, #0]
   11654:	b921      	cbnz	r1, 11660 <USART3_Handler+0x8c>
        enableUSART3IRQ();
        USART3->ier.bits.txrdy = 1;
    }
	async command void usart3irq.disableTXRdyIRQ()
	{
	    USART3->idr.bits.txrdy = 1;
   11656:	68da      	ldr	r2, [r3, #12]
   11658:	f042 0202 	orr.w	r2, r2, #2
   1165c:	60da      	str	r2, [r3, #12]
   1165e:	bd70      	pop	{r4, r5, r6, pc}

inline __nesc_atomic_t __nesc_atomic_start() @spontaneous() __attribute__((always_inline))
{
	__nesc_atomic_t oldState = 0;
	__nesc_atomic_t newState = 1;
	asm volatile(
   11660:	2301      	movs	r3, #1
   11662:	f3ef 8010 	mrs	r0, PRIMASK
   11666:	f383 8810 	msr	PRIMASK, r3
                return;
            }
            atomic
            {

                call usart.sendData(tx_buf[tx_ptr++]);
   1166a:	4927      	ldr	r1, [pc, #156]	; (11708 <USART3_Handler+0x134>)
   1166c:	6814      	ldr	r4, [r2, #0]
   1166e:	880b      	ldrh	r3, [r1, #0]
   11670:	1c5a      	adds	r2, r3, #1
   11672:	b292      	uxth	r2, r2
   11674:	800a      	strh	r2, [r1, #0]
	{
		return USART->rhr.bits.rxchr;
	}
	async command void usart.sendData(uint8_t d)
	{
		USART->thr.bits.txchr = d;
   11676:	5ce4      	ldrb	r4, [r4, r3]
   11678:	4b1c      	ldr	r3, [pc, #112]	; (116ec <USART3_Handler+0x118>)
   1167a:	69d9      	ldr	r1, [r3, #28]
   1167c:	f364 0108 	bfi	r1, r4, #0, #9
   11680:	61d9      	str	r1, [r3, #28]
                if (tx_ptr == tx_len)
   11682:	491f      	ldr	r1, [pc, #124]	; (11700 <USART3_Handler+0x12c>)
   11684:	8809      	ldrh	r1, [r1, #0]
   11686:	4291      	cmp	r1, r2
   11688:	d12a      	bne.n	116e0 <USART3_Handler+0x10c>
                {
                    uint8_t * bufcpy;
                    bufcpy = tx_buf;
                    tx_buf = NULL;
   1168a:	4a1e      	ldr	r2, [pc, #120]	; (11704 <USART3_Handler+0x130>)
   1168c:	2100      	movs	r1, #0
   1168e:	6011      	str	r1, [r2, #0]
   11690:	68da      	ldr	r2, [r3, #12]
   11692:	f042 0202 	orr.w	r2, r2, #2
   11696:	60da      	str	r2, [r3, #12]
   11698:	e022      	b.n	116e0 <USART3_Handler+0x10c>
   1169a:	2301      	movs	r3, #1
   1169c:	f3ef 8010 	mrs	r0, PRIMASK
   116a0:	f383 8810 	msr	PRIMASK, r3
        }
        else
        {
            atomic
            {
                if (tx_buf == NULL)
   116a4:	6811      	ldr	r1, [r2, #0]
   116a6:	4b18      	ldr	r3, [pc, #96]	; (11708 <USART3_Handler+0x134>)
   116a8:	4a10      	ldr	r2, [pc, #64]	; (116ec <USART3_Handler+0x118>)
   116aa:	b939      	cbnz	r1, 116bc <USART3_Handler+0xe8>
   116ac:	69d4      	ldr	r4, [r2, #28]
   116ae:	f361 0408 	bfi	r4, r1, #0, #9
   116b2:	61d4      	str	r4, [r2, #28]
                {
                    call usart.sendData(0);
                    tx_ptr++;
   116b4:	881a      	ldrh	r2, [r3, #0]
   116b6:	3201      	adds	r2, #1
   116b8:	801a      	strh	r2, [r3, #0]
   116ba:	e007      	b.n	116cc <USART3_Handler+0xf8>
                }
                else
                {
                    call usart.sendData(tx_buf[tx_ptr]);
   116bc:	881c      	ldrh	r4, [r3, #0]
   116be:	5d0d      	ldrb	r5, [r1, r4]
   116c0:	69d1      	ldr	r1, [r2, #28]
                    tx_ptr++;
   116c2:	3401      	adds	r4, #1
   116c4:	f365 0108 	bfi	r1, r5, #0, #9
   116c8:	61d1      	str	r1, [r2, #28]
   116ca:	801c      	strh	r4, [r3, #0]
                }
                if (tx_ptr == tx_len)
   116cc:	881a      	ldrh	r2, [r3, #0]
   116ce:	4b0c      	ldr	r3, [pc, #48]	; (11700 <USART3_Handler+0x12c>)
   116d0:	881b      	ldrh	r3, [r3, #0]
   116d2:	429a      	cmp	r2, r3
   116d4:	d104      	bne.n	116e0 <USART3_Handler+0x10c>
   116d6:	4a05      	ldr	r2, [pc, #20]	; (116ec <USART3_Handler+0x118>)
   116d8:	68d3      	ldr	r3, [r2, #12]
   116da:	f043 0302 	orr.w	r3, r3, #2
   116de:	60d3      	str	r3, [r2, #12]
 
inline void __nesc_atomic_end(__nesc_atomic_t oldState) @spontaneous() __attribute__((always_inline))
{
	asm volatile("" : : : "memory"); // memory barrier
 
	asm volatile(
   116e0:	f380 8810 	msr	PRIMASK, r0
   116e4:	bd70      	pop	{r4, r5, r6, pc}
   116e6:	bf00      	nop
   116e8:	000107e5 	.word	0x000107e5
   116ec:	40030000 	.word	0x40030000
   116f0:	2000001d 	.word	0x2000001d
   116f4:	20000030 	.word	0x20000030
   116f8:	20000102 	.word	0x20000102
   116fc:	2000003c 	.word	0x2000003c
   11700:	20000052 	.word	0x20000052
   11704:	2000002c 	.word	0x2000002c
   11708:	20000106 	.word	0x20000106

0001170c <storm_vsnprintf>:
        *(pbuffer) = '\0';
        return 1;
    }

    int storm_vsnprintf(char *buffer, unsigned int buffer_len, const char *fmt, va_list va) @C() @spontaneous()
    {
   1170c:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
   11710:	4607      	mov	r7, r0
   11712:	b088      	sub	sp, #32
   11714:	4688      	mov	r8, r1
   11716:	4616      	mov	r6, r2
        char *pbuffer = buffer;
   11718:	4604      	mov	r4, r0
        char bf[24];
        char ch;

        while ((ch=*(fmt++))) {
   1171a:	7832      	ldrb	r2, [r6, #0]
   1171c:	1be0      	subs	r0, r4, r7
   1171e:	2a00      	cmp	r2, #0
   11720:	f000 809c 	beq.w	1185c <storm_vsnprintf+0x150>
            if ((unsigned int)((pbuffer - buffer) + 1) >= buffer_len)
   11724:	1c41      	adds	r1, r0, #1
   11726:	4541      	cmp	r1, r8
   11728:	f080 8098 	bcs.w	1185c <storm_vsnprintf+0x150>
                break;
            if (ch!='%')
   1172c:	2a25      	cmp	r2, #37	; 0x25
   1172e:	d004      	beq.n	1173a <storm_vsnprintf+0x2e>
            {
                if (!((unsigned int)((pbuffer - buffer) + 1) >= buffer_len))
                {
                    *(pbuffer++) = ch;
   11730:	7022      	strb	r2, [r4, #0]
                    *(pbuffer) = '\0';
   11732:	2200      	movs	r2, #0
    {
        char *pbuffer = buffer;
        char bf[24];
        char ch;

        while ((ch=*(fmt++))) {
   11734:	3601      	adds	r6, #1
            if (ch!='%')
            {
                if (!((unsigned int)((pbuffer - buffer) + 1) >= buffer_len))
                {
                    *(pbuffer++) = ch;
                    *(pbuffer) = '\0';
   11736:	7062      	strb	r2, [r4, #1]
   11738:	e08e      	b.n	11858 <storm_vsnprintf+0x14c>
            else {
                char zero_pad = 0;
                char *ptr;
                unsigned int len;

                ch=*(fmt++);
   1173a:	7875      	ldrb	r5, [r6, #1]

                /* Zero padding requested */
                if (ch=='0') {
   1173c:	2d30      	cmp	r5, #48	; 0x30
   1173e:	d002      	beq.n	11746 <storm_vsnprintf+0x3a>
            else {
                char zero_pad = 0;
                char *ptr;
                unsigned int len;

                ch=*(fmt++);
   11740:	3602      	adds	r6, #2
                    *(pbuffer++) = ch;
                    *(pbuffer) = '\0';
                }
            }
            else {
                char zero_pad = 0;
   11742:	2200      	movs	r2, #0
   11744:	e00a      	b.n	1175c <storm_vsnprintf+0x50>

                ch=*(fmt++);

                /* Zero padding requested */
                if (ch=='0') {
                    ch=*(fmt++);
   11746:	78b2      	ldrb	r2, [r6, #2]
                    if (ch == '\0')
   11748:	2a00      	cmp	r2, #0
   1174a:	f000 8087 	beq.w	1185c <storm_vsnprintf+0x150>
                        goto end;
                    if (ch >= '0' && ch <= '9')
   1174e:	3a30      	subs	r2, #48	; 0x30
   11750:	b2d2      	uxtb	r2, r2
                        zero_pad = ch - '0';
                    ch=*(fmt++);
   11752:	78f5      	ldrb	r5, [r6, #3]
                    *(pbuffer++) = ch;
                    *(pbuffer) = '\0';
                }
            }
            else {
                char zero_pad = 0;
   11754:	2a09      	cmp	r2, #9
   11756:	bf88      	it	hi
   11758:	2200      	movhi	r2, #0
                    ch=*(fmt++);
                    if (ch == '\0')
                        goto end;
                    if (ch >= '0' && ch <= '9')
                        zero_pad = ch - '0';
                    ch=*(fmt++);
   1175a:	3604      	adds	r6, #4
                }

                switch (ch) {
   1175c:	2d64      	cmp	r5, #100	; 0x64
   1175e:	d015      	beq.n	1178c <storm_vsnprintf+0x80>
   11760:	d807      	bhi.n	11772 <storm_vsnprintf+0x66>
   11762:	2d50      	cmp	r5, #80	; 0x50
   11764:	d030      	beq.n	117c8 <storm_vsnprintf+0xbc>
   11766:	d802      	bhi.n	1176e <storm_vsnprintf+0x62>
   11768:	2d00      	cmp	r5, #0
   1176a:	d077      	beq.n	1185c <storm_vsnprintf+0x150>
   1176c:	e06f      	b.n	1184e <storm_vsnprintf+0x142>
   1176e:	2d58      	cmp	r5, #88	; 0x58
   11770:	e00a      	b.n	11788 <storm_vsnprintf+0x7c>
   11772:	2d73      	cmp	r5, #115	; 0x73
   11774:	d051      	beq.n	1181a <storm_vsnprintf+0x10e>
   11776:	d804      	bhi.n	11782 <storm_vsnprintf+0x76>
   11778:	2d69      	cmp	r5, #105	; 0x69
   1177a:	d007      	beq.n	1178c <storm_vsnprintf+0x80>
   1177c:	2d70      	cmp	r5, #112	; 0x70
   1177e:	d023      	beq.n	117c8 <storm_vsnprintf+0xbc>
   11780:	e065      	b.n	1184e <storm_vsnprintf+0x142>
   11782:	2d75      	cmp	r5, #117	; 0x75
   11784:	d002      	beq.n	1178c <storm_vsnprintf+0x80>
   11786:	2d78      	cmp	r5, #120	; 0x78
   11788:	d161      	bne.n	1184e <storm_vsnprintf+0x142>
   1178a:	e025      	b.n	117d8 <storm_vsnprintf+0xcc>
                        goto end;

                    case 'u':
                    case 'd':
                    case 'i':
                         len = mini_itoa(va_arg(va, unsigned int), 10, 0, bf, zero_pad);
   1178c:	9200      	str	r2, [sp, #0]
   1178e:	ad02      	add	r5, sp, #8
   11790:	6818      	ldr	r0, [r3, #0]
   11792:	f8df c0d0 	ldr.w	ip, [pc, #208]	; 11864 <storm_vsnprintf+0x158>
   11796:	2200      	movs	r2, #0
   11798:	f103 0904 	add.w	r9, r3, #4
   1179c:	210a      	movs	r1, #10
   1179e:	462b      	mov	r3, r5
   117a0:	47e0      	blx	ip
                         {
                            unsigned int i;

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
   117a2:	1b3a      	subs	r2, r7, r4
   117a4:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   117a8:	4413      	add	r3, r2
   117aa:	4298      	cmp	r0, r3
   117ac:	bf28      	it	cs
   117ae:	4618      	movcs	r0, r3
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   117b0:	2200      	movs	r2, #0
   117b2:	4282      	cmp	r2, r0
   117b4:	d003      	beq.n	117be <storm_vsnprintf+0xb2>
                                *(pbuffer++) = bf[i];
   117b6:	5ca9      	ldrb	r1, [r5, r2]
   117b8:	54a1      	strb	r1, [r4, r2]

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   117ba:	3201      	adds	r2, #1
   117bc:	e7f9      	b.n	117b2 <storm_vsnprintf+0xa6>
   117be:	4414      	add	r4, r2
                                *(pbuffer++) = bf[i];
                            *(pbuffer) = '\0';
   117c0:	2300      	movs	r3, #0
   117c2:	7023      	strb	r3, [r4, #0]
                        goto end;

                    case 'u':
                    case 'd':
                    case 'i':
                         len = mini_itoa(va_arg(va, unsigned int), 10, 0, bf, zero_pad);
   117c4:	464b      	mov	r3, r9
                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
                                *(pbuffer++) = bf[i];
                            *(pbuffer) = '\0';
                        }
                        break;
   117c6:	e7a8      	b.n	1171a <storm_vsnprintf+0xe>
                    case 'p':
                    case 'P':
                        *(pbuffer++) = '0';
   117c8:	4622      	mov	r2, r4
   117ca:	2130      	movs	r1, #48	; 0x30
   117cc:	f802 1b02 	strb.w	r1, [r2], #2
                        *(pbuffer++) = 'x';
   117d0:	2178      	movs	r1, #120	; 0x78
   117d2:	7061      	strb	r1, [r4, #1]
   117d4:	4614      	mov	r4, r2
                        zero_pad = 8;
   117d6:	2208      	movs	r2, #8
   117d8:	3d58      	subs	r5, #88	; 0x58
                    case 'x':
                    case 'X':
                        len = mini_itoa(va_arg(va, unsigned int), 16, (ch=='X'), bf, zero_pad);
   117da:	9200      	str	r2, [sp, #0]
   117dc:	f10d 0908 	add.w	r9, sp, #8
   117e0:	426a      	negs	r2, r5
   117e2:	416a      	adcs	r2, r5
   117e4:	6818      	ldr	r0, [r3, #0]
   117e6:	4d1f      	ldr	r5, [pc, #124]	; (11864 <storm_vsnprintf+0x158>)
   117e8:	f103 0a04 	add.w	sl, r3, #4
   117ec:	2110      	movs	r1, #16
   117ee:	464b      	mov	r3, r9
   117f0:	47a8      	blx	r5
                        {
                            unsigned int i;

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
   117f2:	f108 33ff 	add.w	r3, r8, #4294967295	; 0xffffffff
   117f6:	1b3a      	subs	r2, r7, r4
   117f8:	4413      	add	r3, r2
   117fa:	4283      	cmp	r3, r0
   117fc:	bf38      	it	cc
   117fe:	4618      	movcc	r0, r3
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   11800:	2300      	movs	r3, #0
   11802:	4283      	cmp	r3, r0
   11804:	d004      	beq.n	11810 <storm_vsnprintf+0x104>
                                *(pbuffer++) = bf[i];
   11806:	f819 2003 	ldrb.w	r2, [r9, r3]
   1180a:	54e2      	strb	r2, [r4, r3]

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   1180c:	3301      	adds	r3, #1
   1180e:	e7f8      	b.n	11802 <storm_vsnprintf+0xf6>
   11810:	441c      	add	r4, r3
                                *(pbuffer++) = bf[i];
                            *(pbuffer) = '\0';
   11812:	2300      	movs	r3, #0
   11814:	7023      	strb	r3, [r4, #0]
                        *(pbuffer++) = '0';
                        *(pbuffer++) = 'x';
                        zero_pad = 8;
                    case 'x':
                    case 'X':
                        len = mini_itoa(va_arg(va, unsigned int), 16, (ch=='X'), bf, zero_pad);
   11816:	4653      	mov	r3, sl
                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
                                *(pbuffer++) = bf[i];
                            *(pbuffer) = '\0';
                        }
                        break;
   11818:	e77f      	b.n	1171a <storm_vsnprintf+0xe>
                            }
                        }
                        break;

                    case 's' :
                        ptr = va_arg(va, char*);
   1181a:	6819      	ldr	r1, [r3, #0]
   1181c:	1d18      	adds	r0, r3, #4
    #include <string.h>
    #include <stdarg.h>

    unsigned int mini_strlen(const char *s)
    {
        unsigned int len = 0;
   1181e:	2200      	movs	r2, #0
        while (s[len] != '\0') len++;
   11820:	5c8b      	ldrb	r3, [r1, r2]
   11822:	b10b      	cbz	r3, 11828 <storm_vsnprintf+0x11c>
   11824:	3201      	adds	r2, #1
   11826:	e7fb      	b.n	11820 <storm_vsnprintf+0x114>
                        ptr = va_arg(va, char*);
                        {
                            unsigned int i, len;
                            len = mini_strlen(ptr);

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
   11828:	f108 35ff 	add.w	r5, r8, #4294967295	; 0xffffffff
   1182c:	ebc4 0c07 	rsb	ip, r4, r7
   11830:	4465      	add	r5, ip
   11832:	42aa      	cmp	r2, r5
   11834:	bf28      	it	cs
   11836:	462a      	movcs	r2, r5
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   11838:	4293      	cmp	r3, r2
   1183a:	d003      	beq.n	11844 <storm_vsnprintf+0x138>
                                *(pbuffer++) = ptr[i];
   1183c:	5ccd      	ldrb	r5, [r1, r3]
   1183e:	54e5      	strb	r5, [r4, r3]

                            if (buffer_len - (pbuffer - buffer) - 1 < len)
                                len = buffer_len - (pbuffer - buffer) - 1;

                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
   11840:	3301      	adds	r3, #1
   11842:	e7f9      	b.n	11838 <storm_vsnprintf+0x12c>
   11844:	441c      	add	r4, r3
                                *(pbuffer++) = ptr[i];
                            *(pbuffer) = '\0';
   11846:	2300      	movs	r3, #0
   11848:	7023      	strb	r3, [r4, #0]
                            }
                        }
                        break;

                    case 's' :
                        ptr = va_arg(va, char*);
   1184a:	4603      	mov	r3, r0
                            /* Copy to buffer */
                            for (i = 0; i < len; i++)
                                *(pbuffer++) = ptr[i];
                            *(pbuffer) = '\0';
                        }
                        break;
   1184c:	e765      	b.n	1171a <storm_vsnprintf+0xe>

                    default:
                        {
                            if (!((unsigned int)((pbuffer - buffer) + 1) >= buffer_len))
                            {
                                *(pbuffer++) = (char)(va_arg(va, int));
   1184e:	681a      	ldr	r2, [r3, #0]
   11850:	7022      	strb	r2, [r4, #0]
                                *(pbuffer) = '\0';
   11852:	2200      	movs	r2, #0
   11854:	7062      	strb	r2, [r4, #1]

                    default:
                        {
                            if (!((unsigned int)((pbuffer - buffer) + 1) >= buffer_len))
                            {
                                *(pbuffer++) = (char)(va_arg(va, int));
   11856:	3304      	adds	r3, #4
   11858:	3401      	adds	r4, #1
   1185a:	e75e      	b.n	1171a <storm_vsnprintf+0xe>
                }
            }
        }
    end:
        return pbuffer - buffer;
    }
   1185c:	b008      	add	sp, #32
   1185e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
   11862:	bf00      	nop
   11864:	00010ad1 	.word	0x00010ad1

00011868 <storm_snprintf>:


    int storm_snprintf(char* buffer, unsigned int buffer_len, const char *fmt, ...) @C() @spontaneous()
    {
   11868:	b40c      	push	{r2, r3}
   1186a:	b513      	push	{r0, r1, r4, lr}
   1186c:	ab04      	add	r3, sp, #16
        int ret;
        va_list va;
        va_start(va, fmt);
        ret = storm_vsnprintf(buffer, buffer_len, fmt, va);
   1186e:	4c05      	ldr	r4, [pc, #20]	; (11884 <storm_snprintf+0x1c>)
        return pbuffer - buffer;
    }


    int storm_snprintf(char* buffer, unsigned int buffer_len, const char *fmt, ...) @C() @spontaneous()
    {
   11870:	f853 2b04 	ldr.w	r2, [r3], #4
        int ret;
        va_list va;
        va_start(va, fmt);
   11874:	9301      	str	r3, [sp, #4]
        ret = storm_vsnprintf(buffer, buffer_len, fmt, va);
   11876:	47a0      	blx	r4
        va_end(va);

        return ret;
    }
   11878:	b002      	add	sp, #8
   1187a:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   1187e:	b002      	add	sp, #8
   11880:	4770      	bx	lr
   11882:	bf00      	nop
   11884:	0001170d 	.word	0x0001170d

00011888 <storm_printf>:

    uint8_t storm_printf_buffer [256];

    int storm_printf(const char* fmt, ...) @C() @spontaneous()
    {
   11888:	b40f      	push	{r0, r1, r2, r3}
   1188a:	b513      	push	{r0, r1, r4, lr}
   1188c:	ab04      	add	r3, sp, #16
        int ret;
        uint32_t i;
        va_list va;
        va_start(va, fmt);
        ret = storm_vsnprintf(storm_printf_buffer, 256, fmt, va);
   1188e:	480e      	ldr	r0, [pc, #56]	; (118c8 <storm_printf+0x40>)
    }

    uint8_t storm_printf_buffer [256];

    int storm_printf(const char* fmt, ...) @C() @spontaneous()
    {
   11890:	f853 2b04 	ldr.w	r2, [r3], #4
        int ret;
        uint32_t i;
        va_list va;
        va_start(va, fmt);
        ret = storm_vsnprintf(storm_printf_buffer, 256, fmt, va);
   11894:	4c0d      	ldr	r4, [pc, #52]	; (118cc <storm_printf+0x44>)
    int storm_printf(const char* fmt, ...) @C() @spontaneous()
    {
        int ret;
        uint32_t i;
        va_list va;
        va_start(va, fmt);
   11896:	9301      	str	r3, [sp, #4]
        ret = storm_vsnprintf(storm_printf_buffer, 256, fmt, va);
   11898:	f44f 7180 	mov.w	r1, #256	; 0x100
   1189c:	47a0      	blx	r4
        va_end(va);

        for (i=0;i<ret;i++)
   1189e:	2300      	movs	r3, #0
   118a0:	4283      	cmp	r3, r0
   118a2:	d00b      	beq.n	118bc <storm_printf+0x34>
        {
            call UartByte.send(storm_printf_buffer[i]);
   118a4:	4a08      	ldr	r2, [pc, #32]	; (118c8 <storm_printf+0x40>)
   118a6:	5c9c      	ldrb	r4, [r3, r2]
	}
	async command bool usart.isTXRdy()
	{
	    return USART->csr.bits.txrdy == 1;
   118a8:	4a09      	ldr	r2, [pc, #36]	; (118d0 <storm_printf+0x48>)
   118aa:	6951      	ldr	r1, [r2, #20]
    * @param byte The byte to send.
    * @return SUCCESS if byte was sent, FAIL otherwise.
    */
    async command error_t UartByte.send( uint8_t byte )
    {
        while (! call usart.isTXRdy());
   118ac:	0789      	lsls	r1, r1, #30
   118ae:	d5fb      	bpl.n	118a8 <storm_printf+0x20>
	{
		return USART->rhr.bits.rxchr;
	}
	async command void usart.sendData(uint8_t d)
	{
		USART->thr.bits.txchr = d;
   118b0:	69d1      	ldr	r1, [r2, #28]
   118b2:	f364 0108 	bfi	r1, r4, #0, #9
   118b6:	61d1      	str	r1, [r2, #28]
        va_list va;
        va_start(va, fmt);
        ret = storm_vsnprintf(storm_printf_buffer, 256, fmt, va);
        va_end(va);

        for (i=0;i<ret;i++)
   118b8:	3301      	adds	r3, #1
   118ba:	e7f1      	b.n	118a0 <storm_printf+0x18>
        {
            call UartByte.send(storm_printf_buffer[i]);
        }

        return ret;
    }
   118bc:	4618      	mov	r0, r3
   118be:	b002      	add	sp, #8
   118c0:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
   118c4:	b004      	add	sp, #16
   118c6:	4770      	bx	lr
   118c8:	20000108 	.word	0x20000108
   118cc:	0001170d 	.word	0x0001170d
   118d0:	40030000 	.word	0x40030000

000118d4 <storm_trace>:
    static uint8_t volatile * const stim1_8 = ((volatile uint8_t*)     0xE0000004);

    //These functions write to the ITM, so are much faster than printf, for
    //hotpath debugging
    void storm_trace(const char* s) @C() @spontaneous()
    {
   118d4:	3801      	subs	r0, #1
        while(*s != 0)
   118d6:	f810 3f01 	ldrb.w	r3, [r0, #1]!
   118da:	b133      	cbz	r3, 118ea <storm_trace+0x16>
        {
            while( *stim0_32 == 0 );
   118dc:	f04f 4260 	mov.w	r2, #3758096384	; 0xe0000000
   118e0:	6811      	ldr	r1, [r2, #0]
   118e2:	2900      	cmp	r1, #0
   118e4:	d0fa      	beq.n	118dc <storm_trace+0x8>
            *stim0_8 = *s;
   118e6:	7013      	strb	r3, [r2, #0]
   118e8:	e7f5      	b.n	118d6 <storm_trace+0x2>
            s++;
        }
    }
   118ea:	4770      	bx	lr

000118ec <storm_trace8>:
    void storm_trace8(uint8_t v) @C() @spontaneous()
    {
        while( *stim1_32 == 0 );
   118ec:	4b02      	ldr	r3, [pc, #8]	; (118f8 <storm_trace8+0xc>)
   118ee:	681a      	ldr	r2, [r3, #0]
   118f0:	2a00      	cmp	r2, #0
   118f2:	d0fb      	beq.n	118ec <storm_trace8>
        *stim1_8 = v;
   118f4:	7018      	strb	r0, [r3, #0]
   118f6:	4770      	bx	lr
   118f8:	e0000004 	.word	0xe0000004

000118fc <storm_trace16>:
    }
    void storm_trace16(uint16_t v) @C() @spontaneous()
    {
        while( *stim1_32 == 0 );
   118fc:	4b02      	ldr	r3, [pc, #8]	; (11908 <storm_trace16+0xc>)
   118fe:	681a      	ldr	r2, [r3, #0]
   11900:	2a00      	cmp	r2, #0
   11902:	d0fb      	beq.n	118fc <storm_trace16>
        *stim1_16 = v;
   11904:	8018      	strh	r0, [r3, #0]
   11906:	4770      	bx	lr
   11908:	e0000004 	.word	0xe0000004

0001190c <storm_trace32>:
    }
    void storm_trace32(uint32_t v) @C() @spontaneous()
    {
        while( *stim1_32 == 0 );
   1190c:	4b02      	ldr	r3, [pc, #8]	; (11918 <storm_trace32+0xc>)
   1190e:	681a      	ldr	r2, [r3, #0]
   11910:	2a00      	cmp	r2, #0
   11912:	d0fb      	beq.n	1190c <storm_trace32>
        *stim1_32 = v;
   11914:	6018      	str	r0, [r3, #0]
   11916:	4770      	bx	lr
   11918:	e0000004 	.word	0xe0000004

0001191c <Dummy_Handler>:
extern uint32_t _estack;

int main(void);

void Dummy_Handler(void)
{
   1191c:	e7fe      	b.n	1191c <Dummy_Handler>
	...

00011920 <Reset_Handler>:
	 * linker file puts it
	 */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
   11920:	4b10      	ldr	r3, [pc, #64]	; (11964 <Reset_Handler+0x44>)
   11922:	4a11      	ldr	r2, [pc, #68]	; (11968 <Reset_Handler+0x48>)
   11924:	4293      	cmp	r3, r2
	TWIM3_Handler,        // 78
	LCDCA_Handler         // 79
};

void Reset_Handler(void)
{
   11926:	b510      	push	{r4, lr}
   11928:	461c      	mov	r4, r3
	 * linker file puts it
	 */
	pSrc = &_etext;
	pDest = &_srelocate;

	if (pSrc != pDest) {
   1192a:	d001      	beq.n	11930 <Reset_Handler+0x10>
   1192c:	2300      	movs	r3, #0
   1192e:	e001      	b.n	11934 <Reset_Handler+0x14>
   11930:	4b0e      	ldr	r3, [pc, #56]	; (1196c <Reset_Handler+0x4c>)
   11932:	e007      	b.n	11944 <Reset_Handler+0x24>
		for (; pDest < &_erelocate;) {
   11934:	490e      	ldr	r1, [pc, #56]	; (11970 <Reset_Handler+0x50>)
   11936:	18d0      	adds	r0, r2, r3
   11938:	4288      	cmp	r0, r1
   1193a:	d2f9      	bcs.n	11930 <Reset_Handler+0x10>
			*pDest++ = *pSrc++;
   1193c:	58e1      	ldr	r1, [r4, r3]
   1193e:	50d1      	str	r1, [r2, r3]
   11940:	3304      	adds	r3, #4
   11942:	e7f7      	b.n	11934 <Reset_Handler+0x14>
		}
	}

	/* Clear the zero segment */
	for (pDest = &_szero; pDest < &_ezero;) {
   11944:	4a0b      	ldr	r2, [pc, #44]	; (11974 <Reset_Handler+0x54>)
   11946:	4293      	cmp	r3, r2
   11948:	d203      	bcs.n	11952 <Reset_Handler+0x32>
		*pDest++ = 0;
   1194a:	2200      	movs	r2, #0
   1194c:	f843 2b04 	str.w	r2, [r3], #4
   11950:	e7f8      	b.n	11944 <Reset_Handler+0x24>
	/* Initialize the C library */
	//XTA
//	__libc_init_array();

    //Workaround for SB.02 hardware bug
    *((uint32_t volatile * ) 0x400E1004) = 1 << 14; //GPER
   11952:	4a09      	ldr	r2, [pc, #36]	; (11978 <Reset_Handler+0x58>)
   11954:	f44f 4380 	mov.w	r3, #16384	; 0x4000
   11958:	6013      	str	r3, [r2, #0]
    *((uint32_t volatile * ) 0x400E1054) = 1 << 14; //OVR
   1195a:	6513      	str	r3, [r2, #80]	; 0x50
    *((uint32_t volatile * ) 0x400E1044) = 1 << 14; //ODER
   1195c:	6413      	str	r3, [r2, #64]	; 0x40

	/* Branch to main function */
	main();
   1195e:	4b07      	ldr	r3, [pc, #28]	; (1197c <Reset_Handler+0x5c>)
   11960:	4798      	blx	r3
   11962:	bd10      	pop	{r4, pc}
   11964:	00011a34 	.word	0x00011a34
   11968:	20000000 	.word	0x20000000
   1196c:	20000004 	.word	0x20000004
   11970:	20000004 	.word	0x20000004
   11974:	20000218 	.word	0x20000218
   11978:	400e1004 	.word	0x400e1004
   1197c:	00010f39 	.word	0x00010f39

00011980 <memset>:
   11980:	b4f0      	push	{r4, r5, r6, r7}
   11982:	0784      	lsls	r4, r0, #30
   11984:	d043      	beq.n	11a0e <memset+0x8e>
   11986:	1e54      	subs	r4, r2, #1
   11988:	2a00      	cmp	r2, #0
   1198a:	d03e      	beq.n	11a0a <memset+0x8a>
   1198c:	b2cd      	uxtb	r5, r1
   1198e:	4603      	mov	r3, r0
   11990:	e003      	b.n	1199a <memset+0x1a>
   11992:	1e62      	subs	r2, r4, #1
   11994:	2c00      	cmp	r4, #0
   11996:	d038      	beq.n	11a0a <memset+0x8a>
   11998:	4614      	mov	r4, r2
   1199a:	f803 5b01 	strb.w	r5, [r3], #1
   1199e:	079a      	lsls	r2, r3, #30
   119a0:	d1f7      	bne.n	11992 <memset+0x12>
   119a2:	2c03      	cmp	r4, #3
   119a4:	d92a      	bls.n	119fc <memset+0x7c>
   119a6:	b2cd      	uxtb	r5, r1
   119a8:	ea45 2505 	orr.w	r5, r5, r5, lsl #8
   119ac:	2c0f      	cmp	r4, #15
   119ae:	ea45 4505 	orr.w	r5, r5, r5, lsl #16
   119b2:	d915      	bls.n	119e0 <memset+0x60>
   119b4:	f1a4 0710 	sub.w	r7, r4, #16
   119b8:	093f      	lsrs	r7, r7, #4
   119ba:	f103 0610 	add.w	r6, r3, #16
   119be:	eb06 1607 	add.w	r6, r6, r7, lsl #4
   119c2:	461a      	mov	r2, r3
   119c4:	6015      	str	r5, [r2, #0]
   119c6:	6055      	str	r5, [r2, #4]
   119c8:	6095      	str	r5, [r2, #8]
   119ca:	60d5      	str	r5, [r2, #12]
   119cc:	3210      	adds	r2, #16
   119ce:	42b2      	cmp	r2, r6
   119d0:	d1f8      	bne.n	119c4 <memset+0x44>
   119d2:	f004 040f 	and.w	r4, r4, #15
   119d6:	3701      	adds	r7, #1
   119d8:	2c03      	cmp	r4, #3
   119da:	eb03 1307 	add.w	r3, r3, r7, lsl #4
   119de:	d90d      	bls.n	119fc <memset+0x7c>
   119e0:	461e      	mov	r6, r3
   119e2:	4622      	mov	r2, r4
   119e4:	3a04      	subs	r2, #4
   119e6:	2a03      	cmp	r2, #3
   119e8:	f846 5b04 	str.w	r5, [r6], #4
   119ec:	d8fa      	bhi.n	119e4 <memset+0x64>
   119ee:	1f22      	subs	r2, r4, #4
   119f0:	f022 0203 	bic.w	r2, r2, #3
   119f4:	3204      	adds	r2, #4
   119f6:	4413      	add	r3, r2
   119f8:	f004 0403 	and.w	r4, r4, #3
   119fc:	b12c      	cbz	r4, 11a0a <memset+0x8a>
   119fe:	b2c9      	uxtb	r1, r1
   11a00:	441c      	add	r4, r3
   11a02:	f803 1b01 	strb.w	r1, [r3], #1
   11a06:	42a3      	cmp	r3, r4
   11a08:	d1fb      	bne.n	11a02 <memset+0x82>
   11a0a:	bcf0      	pop	{r4, r5, r6, r7}
   11a0c:	4770      	bx	lr
   11a0e:	4614      	mov	r4, r2
   11a10:	4603      	mov	r3, r0
   11a12:	e7c6      	b.n	119a2 <memset+0x22>

00011a14 <NVIC>:
   11a14:	e100 e000                                   ....

00011a18 <USART0>:
   11a18:	4000 4002                                   .@.@

00011a1c <USART1>:
   11a1c:	8000 4002                                   ...@

00011a20 <USART2>:
   11a20:	c000 4002                                   ...@

00011a24 <USART3>:
   11a24:	0000 4003                                   ...@

00011a28 <PM>:
   11a28:	0000 400e                                   ...@

00011a2c <SYSTICK>:
   11a2c:	e010 e000                                   ....

00011a30 <GPIO_PORT_A>:
   11a30:	1000 400e                                   ...@
